//! C Code Generator for Frozen Functions
//! Generates optimized C code from CFG

const std = @import("std");
const opcodes = @import("opcodes.zig");
const parser = @import("bytecode_parser.zig");
const cfg_mod = @import("cfg_builder.zig");

const Opcode = opcodes.Opcode;
const Instruction = parser.Instruction;
const Operand = parser.Operand;
const CFG = cfg_mod.CFG;
const BasicBlock = cfg_mod.BasicBlock;
const Allocator = std.mem.Allocator;

/// Code generation options
pub const CodeGenOptions = struct {
    /// Function name to generate
    func_name: []const u8 = "frozen_func",
    /// Generate type-specialized fast paths
    type_specialize: bool = true,
    /// Include debug comments
    debug_comments: bool = true,
    /// Maximum stack size
    max_stack: u16 = 256,
    /// Number of arguments
    arg_count: u16 = 0,
    /// Number of local variables
    var_count: u16 = 0,
    /// Generate optimized int-only code (no JSValue stack)
    optimize_int: bool = true,
};

/// C code generator
pub const CodeGenerator = struct {
    allocator: Allocator,
    cfg: *const CFG,
    options: CodeGenOptions,
    output: std.ArrayListUnmanaged(u8),

    pub fn init(allocator: Allocator, cfg: *const CFG, options: CodeGenOptions) CodeGenerator {
        return .{
            .allocator = allocator,
            .cfg = cfg,
            .options = options,
            .output = .{},
        };
    }

    pub fn deinit(self: *CodeGenerator) void {
        self.output.deinit(self.allocator);
    }

    /// Write a string to output
    fn write(self: *CodeGenerator, str: []const u8) !void {
        try self.output.appendSlice(self.allocator, str);
    }

    /// Write formatted string to output
    fn print(self: *CodeGenerator, comptime fmt: []const u8, args: anytype) !void {
        var buf: [8192]u8 = undefined;
        const slice = std.fmt.bufPrint(&buf, fmt, args) catch return error.FormatError;
        try self.output.appendSlice(self.allocator, slice);
    }

    /// Generate complete C file
    pub fn generate(self: *CodeGenerator) ![]const u8 {
        // Header
        try self.emitHeader();

        // Function signature
        try self.emitFunctionStart();

        // Local variables
        try self.emitLocals();

        // Basic blocks
        for (self.cfg.blocks.items) |*block| {
            try self.emitBlock(block);
        }

        // Exception handler
        try self.emitExceptionHandler();

        // Function end
        try self.emitFunctionEnd();

        // Init function
        try self.emitInitFunction();

        return self.output.items;
    }

    fn emitHeader(self: *CodeGenerator) !void {
        try self.print(
            \\/*
            \\ * Frozen function: {s}
            \\ * Auto-generated by edgebox-freeze
            \\ */
            \\
            \\#include "quickjs.h"
            \\#include "cutils.h"
            \\#include <string.h>
            \\
            \\/* Forward declaration */
            \\static JSValue {s}(JSContext *ctx, JSValueConst this_val,
            \\                   int argc, JSValueConst *argv);
            \\
            \\/* Type checking helpers */
            \\static inline int js_is_int(JSValue v) {{
            \\    return JS_VALUE_GET_TAG(v) == JS_TAG_INT;
            \\}}
            \\
            \\static inline int32_t js_get_int(JSValue v) {{
            \\    return JS_VALUE_GET_INT(v);
            \\}}
            \\
            \\static inline int js_is_both_int(JSValue a, JSValue b) {{
            \\    return js_is_int(a) && js_is_int(b);
            \\}}
            \\
            \\
        , .{ self.options.func_name, self.options.func_name });
    }

    fn emitFunctionStart(self: *CodeGenerator) !void {
        try self.print(
            \\static JSValue {s}(JSContext *ctx, JSValueConst this_val,
            \\                   int argc, JSValueConst *argv)
            \\{{
            \\
        , .{self.options.func_name});
    }

    fn emitLocals(self: *CodeGenerator) !void {
        try self.print(
            \\    /* Stack and locals */
            \\    JSValue stack[{d}];
            \\    int sp = 0;
            \\    JSValue ret_val = JS_UNDEFINED;
            \\
        , .{self.options.max_stack});

        // Local variables array
        if (self.options.var_count > 0) {
            try self.print(
                \\    JSValue locals[{d}];
                \\    for (int i = 0; i < {d}; i++) locals[i] = JS_UNDEFINED;
                \\
            , .{ self.options.var_count, self.options.var_count });
        }

        try self.write("\n");
    }

    fn emitBlock(self: *CodeGenerator, block: *const BasicBlock) !void {
        // Block label
        try self.print("block_{d}:\n", .{block.id});

        if (self.options.debug_comments) {
            try self.print("    /* PC {d}-{d}, {d} instructions */\n", .{
                block.start_pc,
                block.end_pc,
                block.instructions.len,
            });
        }

        // Emit each instruction
        for (block.instructions) |instr| {
            try self.emitInstruction(instr);
        }

        try self.write("\n");
    }

    fn emitInstruction(self: *CodeGenerator, instr: Instruction) !void {
        const info = instr.getInfo();

        if (self.options.debug_comments) {
            try self.print("    /* {d}: {s} */\n", .{ instr.pc, info.name });
        }

        switch (instr.opcode) {
            // Push constants
            .push_minus1, .push_0, .push_1, .push_2, .push_3, .push_4, .push_5, .push_6, .push_7 => {
                const val = opcodes.getImplicitInt(instr.opcode) orelse 0;
                try self.print("    stack[sp++] = JS_NewInt32(ctx, {d});\n", .{val});
            },
            .push_i8 => try self.print("    stack[sp++] = JS_NewInt32(ctx, {d});\n", .{instr.operand.i8}),
            .push_i16 => try self.print("    stack[sp++] = JS_NewInt32(ctx, {d});\n", .{instr.operand.i16}),
            .push_i32 => try self.print("    stack[sp++] = JS_NewInt32(ctx, {d});\n", .{instr.operand.i32}),
            .undefined => try self.write("    stack[sp++] = JS_UNDEFINED;\n"),
            .null => try self.write("    stack[sp++] = JS_NULL;\n"),
            .push_true => try self.write("    stack[sp++] = JS_TRUE;\n"),
            .push_false => try self.write("    stack[sp++] = JS_FALSE;\n"),
            .push_empty_string => try self.write("    stack[sp++] = JS_NewString(ctx, \"\");\n"),

            // Stack manipulation
            .drop => try self.write("    JS_FreeValue(ctx, stack[--sp]);\n"),
            .dup => try self.write("    stack[sp] = JS_DupValue(ctx, stack[sp-1]); sp++;\n"),
            .swap => try self.write("    { JSValue tmp = stack[sp-1]; stack[sp-1] = stack[sp-2]; stack[sp-2] = tmp; }\n"),
            .nip => try self.write("    JS_FreeValue(ctx, stack[sp-2]); stack[sp-2] = stack[sp-1]; sp--;\n"),

            // Argument access
            .get_arg0, .get_arg1, .get_arg2, .get_arg3 => {
                const idx = opcodes.getImplicitArg(instr.opcode) orelse 0;
                try self.print("    stack[sp++] = (argc > {d}) ? JS_DupValue(ctx, argv[{d}]) : JS_UNDEFINED;\n", .{ idx, idx });
            },
            .get_arg => {
                const idx = instr.operand.arg;
                try self.print("    stack[sp++] = (argc > {d}) ? JS_DupValue(ctx, argv[{d}]) : JS_UNDEFINED;\n", .{ idx, idx });
            },

            // Local variable access
            .get_loc0, .get_loc1, .get_loc2, .get_loc3 => {
                const idx = opcodes.getImplicitLocal(instr.opcode) orelse 0;
                try self.print("    stack[sp++] = JS_DupValue(ctx, locals[{d}]);\n", .{idx});
            },
            .get_loc, .get_loc8 => {
                const idx = switch (instr.operand) {
                    .loc => |v| v,
                    else => 0,
                };
                try self.print("    stack[sp++] = JS_DupValue(ctx, locals[{d}]);\n", .{idx});
            },
            .put_loc0, .put_loc1, .put_loc2, .put_loc3 => {
                const idx = opcodes.getImplicitLocal(instr.opcode) orelse 0;
                try self.print("    JS_FreeValue(ctx, locals[{d}]); locals[{d}] = stack[--sp];\n", .{ idx, idx });
            },

            // Arithmetic with type specialization
            .add => try self.emitBinaryArithInt("+"),
            .sub => try self.emitBinaryArithInt("-"),
            .mul => try self.emitBinaryArithInt("*"),
            .neg => try self.write("    stack[sp-1] = JS_NewInt32(ctx, -js_get_int(stack[sp-1]));\n"),
            .inc => try self.write("    stack[sp-1] = JS_NewInt32(ctx, js_get_int(stack[sp-1]) + 1);\n"),
            .dec => try self.write("    stack[sp-1] = JS_NewInt32(ctx, js_get_int(stack[sp-1]) - 1);\n"),

            // Bitwise
            .@"and" => try self.emitBitwiseOp("&"),
            .@"or" => try self.emitBitwiseOp("|"),
            .xor => try self.emitBitwiseOp("^"),
            .shl => try self.emitBitwiseOp("<<"),
            .sar => try self.emitBitwiseOp(">>"),
            .not => try self.write("    stack[sp-1] = JS_NewInt32(ctx, ~js_get_int(stack[sp-1]));\n"),

            // Comparison with type specialization
            .lt => try self.emitCompareInt("<"),
            .lte => try self.emitCompareInt("<="),
            .gt => try self.emitCompareInt(">"),
            .gte => try self.emitCompareInt(">="),
            .eq, .strict_eq => try self.write("    { JSValue a = stack[sp-2], b = stack[sp-1]; sp--; stack[sp-1] = JS_NewBool(ctx, js_get_int(a) == js_get_int(b)); }\n"),
            .neq, .strict_neq => try self.write("    { JSValue a = stack[sp-2], b = stack[sp-1]; sp--; stack[sp-1] = JS_NewBool(ctx, js_get_int(a) != js_get_int(b)); }\n"),

            // Logical
            .lnot => try self.write("    stack[sp-1] = JS_NewBool(ctx, !JS_ToBool(ctx, stack[sp-1]));\n"),

            // Type checks
            .is_undefined => try self.write("    stack[sp-1] = JS_NewBool(ctx, JS_IsUndefined(stack[sp-1]));\n"),
            .is_null => try self.write("    stack[sp-1] = JS_NewBool(ctx, JS_IsNull(stack[sp-1]));\n"),

            // Control flow
            .if_false, .if_false8 => {
                const target = instr.getJumpTarget() orelse 0;
                const target_block = self.cfg.pc_to_block.get(target) orelse 0;
                try self.print(
                    \\    if (!JS_ToBool(ctx, stack[--sp])) goto block_{d};
                    \\
                , .{target_block});
            },
            .if_true, .if_true8 => {
                const target = instr.getJumpTarget() orelse 0;
                const target_block = self.cfg.pc_to_block.get(target) orelse 0;
                try self.print(
                    \\    if (JS_ToBool(ctx, stack[--sp])) goto block_{d};
                    \\
                , .{target_block});
            },
            .goto, .goto8, .goto16 => {
                const target = instr.getJumpTarget() orelse 0;
                const target_block = self.cfg.pc_to_block.get(target) orelse 0;
                try self.print("    goto block_{d};\n", .{target_block});
            },

            // Return
            .@"return" => {
                try self.write("    ret_val = stack[--sp];\n");
                try self.write("    goto done;\n");
            },
            .return_undef => {
                try self.write("    ret_val = JS_UNDEFINED;\n");
                try self.write("    goto done;\n");
            },

            // Function calls
            .call0, .call1, .call2, .call3 => {
                const argc = opcodes.getImplicitCallArgc(instr.opcode) orelse 0;
                try self.emitCall(argc);
            },
            .call => {
                const argc = switch (instr.operand) {
                    .u16 => |v| v,
                    else => 0,
                };
                try self.emitCall(argc);
            },

            // Global variable access
            .get_var => {
                const atom = switch (instr.operand) {
                    .atom => |v| v,
                    else => 0,
                };
                try self.print(
                    \\    stack[sp++] = JS_GetGlobalVar(ctx, {d}, 0);
                    \\
                , .{atom});
            },

            // Closure variable access - for self-recursion, push a marker
            // that will be detected by the call handler
            .get_var_ref0, .get_var_ref1, .get_var_ref2, .get_var_ref3 => {
                // For self-recursive functions, closure var 0 is typically 'this function'
                // Push a special marker that call handler will detect for direct recursion
                try self.write("    stack[sp++] = JS_MKVAL(JS_TAG_INT, 0xDEADBEEF); /* self-ref marker */\n");
            },
            .get_var_ref => {
                try self.write("    stack[sp++] = JS_MKVAL(JS_TAG_INT, 0xDEADBEEF); /* self-ref marker */\n");
            },

            // Object creation
            .object => try self.write("    stack[sp++] = JS_NewObject(ctx);\n"),

            // NOP
            .nop => {},

            // Throw
            .throw => {
                try self.write("    JS_Throw(ctx, stack[--sp]);\n");
                try self.write("    goto exception;\n");
            },

            // Unsupported - emit runtime error
            else => {
                try self.print("    /* UNSUPPORTED: {s} */\n", .{info.name});
                try self.write("    JS_ThrowInternalError(ctx, \"Unsupported opcode\");\n");
                try self.write("    goto exception;\n");
            },
        }
    }

    /// Emit binary arithmetic with int fast path
    fn emitBinaryArithInt(self: *CodeGenerator, op: []const u8) !void {
        try self.print(
            \\    {{
            \\        int64_t r = (int64_t)js_get_int(stack[sp-2]) {s} (int64_t)js_get_int(stack[sp-1]);
            \\        sp--;
            \\        stack[sp-1] = JS_NewInt32(ctx, (int32_t)r);
            \\    }}
            \\
        , .{op});
    }

    /// Emit bitwise operation
    fn emitBitwiseOp(self: *CodeGenerator, op: []const u8) !void {
        try self.print(
            \\    {{
            \\        int32_t a = js_get_int(stack[sp-2]);
            \\        int32_t b = js_get_int(stack[sp-1]);
            \\        sp--;
            \\        stack[sp-1] = JS_NewInt32(ctx, a {s} b);
            \\    }}
            \\
        , .{op});
    }

    /// Emit comparison with int fast path
    fn emitCompareInt(self: *CodeGenerator, op: []const u8) !void {
        try self.print(
            \\    {{
            \\        int cmp = js_get_int(stack[sp-2]) {s} js_get_int(stack[sp-1]);
            \\        sp--;
            \\        stack[sp-1] = JS_NewBool(ctx, cmp);
            \\    }}
            \\
        , .{op});
    }

    /// Emit function call with self-recursion detection
    fn emitCall(self: *CodeGenerator, argc: u16) !void {
        // Check if this is a self-recursive call (function on stack is our marker)
        try self.print(
            \\    {{
            \\        JSValue func = stack[sp - {d} - 1];
            \\        /* Check for self-recursion marker (0xDEADBEEF) */
            \\        if (JS_VALUE_GET_TAG(func) == JS_TAG_INT && JS_VALUE_GET_INT(func) == 0xDEADBEEF) {{
            \\            /* Direct self-recursive call */
            \\            JSValue call_argv[{d}];
            \\            for (int i = 0; i < {d}; i++) call_argv[i] = stack[sp - {d} + i];
            \\            sp -= {d} + 1;  /* pop args and marker */
            \\            JSValue result = {s}(ctx, JS_UNDEFINED, {d}, call_argv);
            \\            for (int i = 0; i < {d}; i++) JS_FreeValue(ctx, call_argv[i]);
            \\            if (JS_IsException(result)) goto exception;
            \\            stack[sp++] = result;
            \\        }} else {{
            \\            /* Regular function call */
            \\            JSValue *call_argv = &stack[sp - {d}];
            \\            JSValue result = JS_Call(ctx, func, JS_UNDEFINED, {d}, call_argv);
            \\            for (int i = 0; i < {d}; i++) JS_FreeValue(ctx, call_argv[i]);
            \\            JS_FreeValue(ctx, func);
            \\            sp -= {d} + 1;
            \\            if (JS_IsException(result)) goto exception;
            \\            stack[sp++] = result;
            \\        }}
            \\    }}
            \\
        , .{ argc, argc, argc, argc, argc, self.options.func_name, argc, argc, argc, argc, argc, argc });
    }

    fn emitExceptionHandler(self: *CodeGenerator) !void {
        try self.write(
            \\
            \\exception:
            \\    while (sp > 0) JS_FreeValue(ctx, stack[--sp]);
            \\    return JS_EXCEPTION;
            \\
            \\done:
            \\    while (sp > 0) JS_FreeValue(ctx, stack[--sp]);
            \\    return ret_val;
            \\
        );
    }

    fn emitFunctionEnd(self: *CodeGenerator) !void {
        try self.write("}\n\n");
    }

    fn emitInitFunction(self: *CodeGenerator) !void {
        try self.print(
            \\int {s}_init(JSContext *ctx)
            \\{{
            \\    JSValue global = JS_GetGlobalObject(ctx);
            \\    JSValue func = JS_NewCFunction(ctx, {s}, "{s}", {d});
            \\    JS_SetPropertyStr(ctx, global, "{s}", func);
            \\    JS_FreeValue(ctx, global);
            \\    return 0;
            \\}}
            \\
        , .{
            self.options.func_name,
            self.options.func_name,
            self.options.func_name,
            self.options.arg_count,
            self.options.func_name,
        });
    }
};

/// Generate frozen C code from instructions
pub fn generateFrozenCode(
    allocator: Allocator,
    instructions: []const Instruction,
    options: CodeGenOptions,
) ![]const u8 {
    var cfg = try cfg_mod.buildCFG(allocator, instructions);
    defer cfg.deinit();

    var gen = CodeGenerator.init(allocator, &cfg, options);
    defer gen.deinit();

    const code = try gen.generate();
    return try allocator.dupe(u8, code);
}

test "generate simple function" {
    const instrs = [_]Instruction{
        .{ .pc = 0, .opcode = .get_arg0, .operand = .{ .implicit_arg = 0 }, .size = 1 },
        .{ .pc = 1, .opcode = .push_1, .operand = .{ .implicit_int = 1 }, .size = 1 },
        .{ .pc = 2, .opcode = .add, .operand = .{ .none = {} }, .size = 1 },
        .{ .pc = 3, .opcode = .@"return", .operand = .{ .none = {} }, .size = 1 },
    };

    const code = try generateFrozenCode(std.testing.allocator, &instrs, .{
        .func_name = "test_add_one",
        .arg_count = 1,
    });
    defer std.testing.allocator.free(code);

    // Check that output contains expected elements
    try std.testing.expect(std.mem.indexOf(u8, code, "test_add_one") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "JS_NewInt32") != null);
}
