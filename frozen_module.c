/*
 * Frozen Module - All bytecode unrolled to C
 * Generated by edgebox-freeze
 *
 * This replaces QuickJS interpreter with direct C execution.
 * Expected speedup: 10-20x for CPU-bound code.
 */

#include "quickjs.h"
#include <stdint.h>
#include <math.h>

#ifndef likely
#define likely(x) __builtin_expect(!!(x), 1)
#endif
#ifndef unlikely
#define unlikely(x) __builtin_expect(!!(x), 0)
#endif

/* Call stack limit (matches Node.js behavior) */
#ifndef FROZEN_MAX_CALL_DEPTH
#define FROZEN_MAX_CALL_DEPTH 10000
#endif
static int frozen_call_depth = 0;

/* Stack overflow check macro - returns RangeError like Node.js */
#define FROZEN_CHECK_STACK(ctx) do { \
    if (unlikely(frozen_call_depth >= FROZEN_MAX_CALL_DEPTH)) { \
        return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded"); \
    } \
    frozen_call_depth++; \
} while(0)
#define FROZEN_EXIT_STACK() (frozen_call_depth--)

/* Stack operations with bounds checking */
#define PUSH(v) do { \
    if (unlikely(sp >= max_stack)) { \
        FROZEN_EXIT_STACK(); \
        return JS_ThrowRangeError(ctx, "Operand stack overflow"); \
    } \
    stack[sp++] = (v); \
} while(0)
#define POP() (stack[--sp])
#define TOP() (stack[sp-1])
#define SET_TOP(v) (stack[sp-1] = (v))

/* SMI-optimized dup/free - skip refcount for immediate values (int, bool, etc) */
#define FROZEN_DUP(ctx, v) (JS_VALUE_HAS_REF_COUNT(v) ? JS_DupValue(ctx, v) : (v))
#define FROZEN_FREE(ctx, v) do { if (JS_VALUE_HAS_REF_COUNT(v)) JS_FreeValue(ctx, v); } while(0)

/* SMI (Small Integer) arithmetic helpers - zero allocation fast path */
/* Uses JS_MKVAL for int32 results (no context/allocation needed) */
/* Falls back to float64 only on overflow or non-int input */
static inline JSValue frozen_add(JSContext *ctx, JSValue a, JSValue b) {
    if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
        int64_t r = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
        if (likely((int32_t)r == r)) return JS_MKVAL(JS_TAG_INT, (int32_t)r);
        return JS_NewFloat64(ctx, (double)r);
    }
    double da, db;
    if (JS_ToFloat64(ctx, &da, a)) return JS_EXCEPTION;
    if (JS_ToFloat64(ctx, &db, b)) return JS_EXCEPTION;
    return JS_NewFloat64(ctx, da + db);
}
static inline JSValue frozen_sub(JSContext *ctx, JSValue a, JSValue b) {
    if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
        int64_t r = (int64_t)JS_VALUE_GET_INT(a) - JS_VALUE_GET_INT(b);
        if (likely((int32_t)r == r)) return JS_MKVAL(JS_TAG_INT, (int32_t)r);
        return JS_NewFloat64(ctx, (double)r);
    }
    double da, db;
    if (JS_ToFloat64(ctx, &da, a)) return JS_EXCEPTION;
    if (JS_ToFloat64(ctx, &db, b)) return JS_EXCEPTION;
    return JS_NewFloat64(ctx, da - db);
}
static inline JSValue frozen_mul(JSContext *ctx, JSValue a, JSValue b) {
    if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
        int64_t r = (int64_t)JS_VALUE_GET_INT(a) * JS_VALUE_GET_INT(b);
        if (likely((int32_t)r == r)) return JS_MKVAL(JS_TAG_INT, (int32_t)r);
        return JS_NewFloat64(ctx, (double)r);
    }
    double da, db;
    if (JS_ToFloat64(ctx, &da, a)) return JS_EXCEPTION;
    if (JS_ToFloat64(ctx, &db, b)) return JS_EXCEPTION;
    return JS_NewFloat64(ctx, da * db);
}
static inline JSValue frozen_div(JSContext *ctx, JSValue a, JSValue b) {
    double da, db;
    if (JS_ToFloat64(ctx, &da, a)) return JS_EXCEPTION;
    if (JS_ToFloat64(ctx, &db, b)) return JS_EXCEPTION;
    return JS_NewFloat64(ctx, da / db);
}
static inline JSValue frozen_mod(JSContext *ctx, JSValue a, JSValue b) {
    if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
        int32_t ia = JS_VALUE_GET_INT(a);
        int32_t ib = JS_VALUE_GET_INT(b);
        if (unlikely(ib == 0)) return JS_NewFloat64(ctx, NAN);
        if (unlikely(ib == -1 && ia == INT32_MIN)) return JS_MKVAL(JS_TAG_INT, 0);
        return JS_MKVAL(JS_TAG_INT, ia % ib);
    }
    double da, db;
    if (JS_ToFloat64(ctx, &da, a)) return JS_EXCEPTION;
    if (JS_ToFloat64(ctx, &db, b)) return JS_EXCEPTION;
    return JS_NewFloat64(ctx, fmod(da, db));
}
static inline int frozen_lt(JSContext *ctx, JSValue a, JSValue b) {
    if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
        return JS_VALUE_GET_INT(a) < JS_VALUE_GET_INT(b);
    }
    double da, db;
    if (JS_ToFloat64(ctx, &da, a)) return 0;
    if (JS_ToFloat64(ctx, &db, b)) return 0;
    return da < db;
}
static inline int frozen_lte(JSContext *ctx, JSValue a, JSValue b) {
    if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
        return JS_VALUE_GET_INT(a) <= JS_VALUE_GET_INT(b);
    }
    double da, db;
    if (JS_ToFloat64(ctx, &da, a)) return 0;
    if (JS_ToFloat64(ctx, &db, b)) return 0;
    return da <= db;
}
static inline int frozen_gt(JSContext *ctx, JSValue a, JSValue b) {
    if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
        return JS_VALUE_GET_INT(a) > JS_VALUE_GET_INT(b);
    }
    double da, db;
    if (JS_ToFloat64(ctx, &da, a)) return 0;
    if (JS_ToFloat64(ctx, &db, b)) return 0;
    return da > db;
}
static inline int frozen_gte(JSContext *ctx, JSValue a, JSValue b) {
    if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
        return JS_VALUE_GET_INT(a) >= JS_VALUE_GET_INT(b);
    }
    double da, db;
    if (JS_ToFloat64(ctx, &da, a)) return 0;
    if (JS_ToFloat64(ctx, &db, b)) return 0;
    return da >= db;
}
static inline int frozen_eq(JSContext *ctx, JSValue a, JSValue b) {
    if (JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT) {
        return JS_VALUE_GET_INT(a) == JS_VALUE_GET_INT(b);
    }
    double da, db;
    if (JS_ToFloat64(ctx, &da, a)) return 0;
    if (JS_ToFloat64(ctx, &db, b)) return 0;
    return da == db;
}
static inline int frozen_neq(JSContext *ctx, JSValue a, JSValue b) {
    return !frozen_eq(ctx, a, b);
}

/* Bitwise helpers - always convert to int32 per JS spec */
static inline JSValue frozen_and(JSContext *ctx, JSValue a, JSValue b) {
    int32_t ia, ib;
    JS_ToInt32(ctx, &ia, a); JS_ToInt32(ctx, &ib, b);
    return JS_MKVAL(JS_TAG_INT, ia & ib);
}
static inline JSValue frozen_or(JSContext *ctx, JSValue a, JSValue b) {
    int32_t ia, ib;
    JS_ToInt32(ctx, &ia, a); JS_ToInt32(ctx, &ib, b);
    return JS_MKVAL(JS_TAG_INT, ia | ib);
}
static inline JSValue frozen_xor(JSContext *ctx, JSValue a, JSValue b) {
    int32_t ia, ib;
    JS_ToInt32(ctx, &ia, a); JS_ToInt32(ctx, &ib, b);
    return JS_MKVAL(JS_TAG_INT, ia ^ ib);
}
static inline JSValue frozen_shl(JSContext *ctx, JSValue a, JSValue b) {
    int32_t ia, ib;
    JS_ToInt32(ctx, &ia, a); JS_ToInt32(ctx, &ib, b);
    return JS_MKVAL(JS_TAG_INT, ia << (ib & 0x1f));
}
static inline JSValue frozen_sar(JSContext *ctx, JSValue a, JSValue b) {
    int32_t ia, ib;
    JS_ToInt32(ctx, &ia, a); JS_ToInt32(ctx, &ib, b);
    return JS_MKVAL(JS_TAG_INT, ia >> (ib & 0x1f));
}
static inline JSValue frozen_shr(JSContext *ctx, JSValue a, JSValue b) {
    uint32_t ua; int32_t ib;
    JS_ToUint32(ctx, &ua, a); JS_ToInt32(ctx, &ib, b);
    return JS_NewUint32(ctx, ua >> (ib & 0x1f));
}
static inline JSValue frozen_not(JSContext *ctx, JSValue a) {
    int32_t ia;
    JS_ToInt32(ctx, &ia, a);
    return JS_MKVAL(JS_TAG_INT, ~ia);
}
static inline JSValue frozen_neg(JSContext *ctx, JSValue a) {
    if (JS_VALUE_GET_TAG(a) == JS_TAG_INT) {
        int32_t v = JS_VALUE_GET_INT(a);
        if (v == INT32_MIN) return JS_NewFloat64(ctx, 2147483648.0);
        return JS_MKVAL(JS_TAG_INT, -v);
    }
    double d;
    JS_ToFloat64(ctx, &d, a);
    return JS_NewFloat64(ctx, -d);
}

/* Array access helpers - use public QuickJS API */
static inline JSValue frozen_array_get(JSContext *ctx, JSValue obj, JSValue idx) {
    if (JS_VALUE_GET_TAG(idx) == JS_TAG_INT) {
        int32_t i = JS_VALUE_GET_INT(idx);
        if (i >= 0) return JS_GetPropertyUint32(ctx, obj, (uint32_t)i);  /* Fast path */
        return JS_GetPropertyInt64(ctx, obj, i);
    }
    JSAtom atom = JS_ValueToAtom(ctx, idx);
    if (atom == JS_ATOM_NULL) return JS_EXCEPTION;
    JSValue val = JS_GetProperty(ctx, obj, atom);
    JS_FreeAtom(ctx, atom);
    return val;
}
static inline int frozen_array_set(JSContext *ctx, JSValue obj, JSValue idx, JSValue val) {
    if (JS_VALUE_GET_TAG(idx) == JS_TAG_INT) {
        return JS_SetPropertyInt64(ctx, obj, JS_VALUE_GET_INT(idx), val);
    }
    JSAtom atom = JS_ValueToAtom(ctx, idx);
    if (atom == JS_ATOM_NULL) return -1;
    int r = JS_SetProperty(ctx, obj, atom, val);
    JS_FreeAtom(ctx, atom);
    return r;
}
static inline int64_t frozen_get_length(JSContext *ctx, JSValue obj) {
    int64_t len = 0;
    JS_GetLength(ctx, obj, &len);  /* Direct API - faster than JS_GetPropertyStr */
    return len;
}

/* SIMD-accelerated int32 array operations (4 elements at once) */
#ifdef __wasm__
#include <wasm_simd128.h>

/* SIMD int32 array sum - processes 4 elements per iteration */
static inline int64_t frozen_sum_int32_array_simd(JSContext *ctx, JSValue arr, int64_t len) {
    v128_t sum_vec = wasm_i32x4_splat(0);  /* Initialize 4-lane sum to 0 */
    int64_t i = 0;

    /* SIMD loop: process 4 int32s at once */
    for (; i + 4 <= len; i += 4) {
        int32_t vals[4];
        int all_int32 = 1;

        /* Load and check 4 values */
        for (int j = 0; j < 4; j++) {
            JSValue val = JS_GetPropertyUint32(ctx, arr, (uint32_t)(i + j));
            if (likely(JS_VALUE_GET_TAG(val) == JS_TAG_INT)) {
                vals[j] = JS_VALUE_GET_INT(val);
            } else {
                JS_FreeValue(ctx, val);
                all_int32 = 0;
                break;
            }
        }

        if (all_int32) {
            /* Load 4 int32s into SIMD register */
            v128_t vec = wasm_v128_load(vals);
            /* Vectorized add */
            sum_vec = wasm_i32x4_add(sum_vec, vec);
        } else {
            /* Type guard failed - fall back to scalar */
            return -1;
        }
    }

    /* Horizontal sum: reduce 4 lanes to single value */
    int32_t partial[4];
    wasm_v128_store(partial, sum_vec);
    int64_t sum = (int64_t)partial[0] + partial[1] + partial[2] + partial[3];

    /* Scalar remainder */
    for (; i < len; i++) {
        JSValue val = JS_GetPropertyUint32(ctx, arr, (uint32_t)i);
        if (likely(JS_VALUE_GET_TAG(val) == JS_TAG_INT)) {
            sum += JS_VALUE_GET_INT(val);
        } else {
            JS_FreeValue(ctx, val);
            return -1;  /* Type guard failed */
        }
    }

    return sum;
}
#endif /* __wasm__ */

static inline JSValue frozen_pow(JSContext *ctx, JSValue a, JSValue b) {
    double da, db;
    if (JS_ToFloat64(ctx, &da, a)) return JS_EXCEPTION;
    if (JS_ToFloat64(ctx, &db, b)) return JS_EXCEPTION;
    return JS_NewFloat64(ctx, pow(da, db));
}
static inline JSValue frozen_typeof(JSContext *ctx, JSValue v) {
    const char *s;
    int tag = JS_VALUE_GET_TAG(v);
    switch(tag) {
    case JS_TAG_UNDEFINED: s = "undefined"; break;
    case JS_TAG_NULL: s = "object"; break;
    case JS_TAG_STRING: s = "string"; break;
    case JS_TAG_INT: case JS_TAG_FLOAT64: s = "number"; break;
    case JS_TAG_BOOL: s = "boolean"; break;
    case JS_TAG_BIG_INT: s = "bigint"; break;
    case JS_TAG_SYMBOL: s = "symbol"; break;
    case JS_TAG_OBJECT:
        if (JS_IsFunction(ctx, v)) s = "function";
        else s = "object";
        break;
    default: s = "unknown"; break;
    }
    return JS_NewString(ctx, s);
}
static inline int frozen_in(JSContext *ctx, JSValue key, JSValue obj) {
    JSAtom atom = JS_ValueToAtom(ctx, key);
    if (atom == JS_ATOM_NULL) return -1;
    int r = JS_HasProperty(ctx, obj, atom);
    JS_FreeAtom(ctx, atom);
    return r;
}
static JSValue frozen_fib(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* Pure native int64 implementation - zero JSValue overhead */
/* Depth parameter added for WAMR AOT+SIMD stack safety */
#define frozen_fib_MAX_DEPTH 5000

static int64_t frozen_fib_native_impl(int64_t n, int depth) {
    if (unlikely(depth >= frozen_fib_MAX_DEPTH)) return -1;
    if (n < 2) return n;
    return frozen_fib_native_impl(n - 1, depth + 1) + frozen_fib_native_impl(n - 2, depth + 1);
}

static int64_t frozen_fib_native(int64_t n) {
    return frozen_fib_native_impl(n, 0);
}

static JSValue frozen_fib(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    FROZEN_CHECK_STACK(ctx);
    if (argc > 0 && JS_VALUE_GET_TAG(argv[0]) == JS_TAG_INT) {
        int64_t n = JS_VALUE_GET_INT(argv[0]);
        int64_t result = frozen_fib_native(n);
        FROZEN_EXIT_STACK();
        if (result >= -2147483648LL && result <= 2147483647LL)
            return JS_MKVAL(JS_TAG_INT, (int32_t)result);
        return JS_NewFloat64(ctx, (double)result);
    }
    /* Fallback for non-int input */
    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}
int frozen_fib_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_fib, "__frozen_fib", 1);
    JS_SetPropertyStr(ctx, global, "__frozen_fib", func);
    JS_FreeValue(ctx, global);
    return 0;
}

/*
 * Initialize all frozen functions
 * Call this after creating JSContext
 */
int frozen_init(JSContext *ctx)
{
    (void)ctx;
    /* Functions are registered individually via their *_init() calls */
    /* Call each function's init: */
    frozen_fib_init(ctx);
    return 0;
}
