/// EdgeBox Static WASM Entry Point
/// Executes pre-compiled bytecode from qjsc (embedded at build time)
///
/// Build pipeline:
///   1. qjsc -s -N bundle bundle.js > bundle_compiled.c
///   2. zig build wasm-static (compiles bundle_compiled.c with QuickJS)
///   3. wizer (pre-initializes runtime)
///   4. wasmedge --compile (AOT)
///
/// This eliminates JS parsing entirely - bytecode is loaded directly.
const std = @import("std");
const quickjs = @import("quickjs_core.zig");
const wasm_fetch = @import("wasm_fetch.zig");
const wasi_tty = @import("wasi_tty.zig");
const wasi_process = @import("wasi_process.zig");
const wizer_mod = @import("wizer_init.zig");

// ============================================================================
// External bytecode from bundle_compiled.c (generated by qjsc)
// ============================================================================

// Import C symbols from bundle_compiled.c
// The C file declares: const uint32_t bundle_size; const uint8_t bundle[];
extern fn get_bundle_ptr() callconv(.c) [*]const u8;
extern fn get_bundle_size() callconv(.c) u32;

// ============================================================================
// Host Bridge Dispatch Functions (6 imports instead of 50)
// ============================================================================

// Single dispatch function per module - reduces WASM link time
extern "edgebox_http" fn http_dispatch(opcode: u32, a1: u32, a2: u32, a3: u32, a4: u32, a5: u32, a6: u32, a7: u32, a8: u32) i32;
extern "edgebox_spawn" fn spawn_dispatch(opcode: u32, a1: u32, a2: u32, a3: u32, a4: u32) i32;
extern "edgebox_file" fn file_dispatch(opcode: u32, a1: u32, a2: u32, a3: u32, a4: u32) i32;
extern "edgebox_zlib" fn zlib_dispatch(opcode: u32, a1: u32, a2: u32) i32;
extern "edgebox_crypto" fn crypto_dispatch(opcode: u32, a1: u32, a2: u32, a3: u32, a4: u32, a5: u32, a6: u32) i32;
extern "edgebox_socket" fn socket_dispatch(opcode: u32, a1: u32, a2: u32, a3: u32) i32;

// HTTP opcodes
const HTTP_OP_REQUEST: u32 = 0;
const HTTP_OP_GET_RESPONSE_LEN: u32 = 1;
const HTTP_OP_GET_RESPONSE: u32 = 2;
const HTTP_OP_START_ASYNC: u32 = 3;
const HTTP_OP_POLL: u32 = 4;
const HTTP_OP_RESPONSE_LEN: u32 = 5;
const HTTP_OP_RESPONSE: u32 = 6;
const HTTP_OP_FREE: u32 = 7;

// Spawn opcodes
const SPAWN_OP_START: u32 = 0;
const SPAWN_OP_POLL: u32 = 1;
const SPAWN_OP_OUTPUT_LEN: u32 = 2;
const SPAWN_OP_OUTPUT: u32 = 3;
const SPAWN_OP_FREE: u32 = 4;

// File opcodes
const FILE_OP_READ_START: u32 = 0;
const FILE_OP_WRITE_START: u32 = 1;
const FILE_OP_POLL: u32 = 2;
const FILE_OP_RESULT_LEN: u32 = 3;
const FILE_OP_RESULT: u32 = 4;
const FILE_OP_FREE: u32 = 5;

// Zlib opcodes
const ZLIB_OP_GZIP: u32 = 0;
const ZLIB_OP_GUNZIP: u32 = 1;
const ZLIB_OP_DEFLATE: u32 = 2;
const ZLIB_OP_INFLATE: u32 = 3;
const ZLIB_OP_GET_RESULT: u32 = 4;

// Crypto opcodes
const CRYPTO_OP_AES_GCM_ENCRYPT: u32 = 0;
const CRYPTO_OP_AES_GCM_DECRYPT: u32 = 1;
const CRYPTO_OP_GET_RESULT: u32 = 2;
const CRYPTO_OP_RANDOM_BYTES: u32 = 3;

// Socket opcodes
const SOCKET_OP_CREATE: u32 = 0;
const SOCKET_OP_BIND: u32 = 1;
const SOCKET_OP_LISTEN: u32 = 2;
const SOCKET_OP_ACCEPT: u32 = 3;
const SOCKET_OP_CONNECT: u32 = 4;
const SOCKET_OP_WRITE: u32 = 5;
const SOCKET_OP_READ: u32 = 6;
const SOCKET_OP_GET_READ_DATA: u32 = 7;
const SOCKET_OP_CLOSE: u32 = 8;
const SOCKET_OP_STATE: u32 = 9;

// ============================================================================
// Wrapper functions that call dispatch (maintain existing API)
// ============================================================================

// HTTP wrappers
fn request(url_ptr: [*]const u8, url_len: u32, method_ptr: [*]const u8, method_len: u32, headers_ptr: [*]const u8, headers_len: u32, body_ptr: [*]const u8, body_len: u32) i32 {
    return http_dispatch(HTTP_OP_REQUEST, @intFromPtr(url_ptr), url_len, @intFromPtr(method_ptr), method_len, @intFromPtr(headers_ptr), headers_len, @intFromPtr(body_ptr), body_len);
}
fn get_response_len() i32 {
    return http_dispatch(HTTP_OP_GET_RESPONSE_LEN, 0, 0, 0, 0, 0, 0, 0, 0);
}
fn get_response(dest_ptr: [*]u8) i32 {
    return http_dispatch(HTTP_OP_GET_RESPONSE, @intFromPtr(dest_ptr), 0, 0, 0, 0, 0, 0, 0);
}
fn start_async(url_ptr: [*]const u8, url_len: u32, method_ptr: [*]const u8, method_len: u32, headers_ptr: [*]const u8, headers_len: u32, body_ptr: [*]const u8, body_len: u32) i32 {
    return http_dispatch(HTTP_OP_START_ASYNC, @intFromPtr(url_ptr), url_len, @intFromPtr(method_ptr), method_len, @intFromPtr(headers_ptr), headers_len, @intFromPtr(body_ptr), body_len);
}
fn http_poll(request_id: u32) i32 {
    return http_dispatch(HTTP_OP_POLL, request_id, 0, 0, 0, 0, 0, 0, 0);
}
fn http_response_len(request_id: u32) i32 {
    return http_dispatch(HTTP_OP_RESPONSE_LEN, request_id, 0, 0, 0, 0, 0, 0, 0);
}
fn http_response(request_id: u32, dest_ptr: [*]u8) i32 {
    return http_dispatch(HTTP_OP_RESPONSE, request_id, @intFromPtr(dest_ptr), 0, 0, 0, 0, 0, 0);
}
fn http_free(request_id: u32) i32 {
    return http_dispatch(HTTP_OP_FREE, request_id, 0, 0, 0, 0, 0, 0, 0);
}

// Spawn wrappers
fn spawn_start(cmd_ptr: [*]const u8, cmd_len: u32, args_ptr: [*]const u8, args_len: u32) i32 {
    return spawn_dispatch(SPAWN_OP_START, @intFromPtr(cmd_ptr), cmd_len, @intFromPtr(args_ptr), args_len);
}
fn spawn_poll(spawn_id: u32) i32 {
    return spawn_dispatch(SPAWN_OP_POLL, spawn_id, 0, 0, 0);
}
fn spawn_output_len(spawn_id: u32) i32 {
    return spawn_dispatch(SPAWN_OP_OUTPUT_LEN, spawn_id, 0, 0, 0);
}
fn spawn_output(spawn_id: u32, dest_ptr: [*]u8) i32 {
    return spawn_dispatch(SPAWN_OP_OUTPUT, spawn_id, @intFromPtr(dest_ptr), 0, 0);
}
fn spawn_free(spawn_id: u32) i32 {
    return spawn_dispatch(SPAWN_OP_FREE, spawn_id, 0, 0, 0);
}

// File wrappers
fn file_read_start(path_ptr: [*]const u8, path_len: u32) i32 {
    return file_dispatch(FILE_OP_READ_START, @intFromPtr(path_ptr), path_len, 0, 0);
}
fn file_write_start(path_ptr: [*]const u8, path_len: u32, data_ptr: [*]const u8, data_len: u32) i32 {
    return file_dispatch(FILE_OP_WRITE_START, @intFromPtr(path_ptr), path_len, @intFromPtr(data_ptr), data_len);
}
fn file_poll(request_id: u32) i32 {
    return file_dispatch(FILE_OP_POLL, request_id, 0, 0, 0);
}
fn file_result_len(request_id: u32) i32 {
    return file_dispatch(FILE_OP_RESULT_LEN, request_id, 0, 0, 0);
}
fn file_result(request_id: u32, dest_ptr: [*]u8) i32 {
    return file_dispatch(FILE_OP_RESULT, request_id, @intFromPtr(dest_ptr), 0, 0);
}
fn file_free(request_id: u32) i32 {
    return file_dispatch(FILE_OP_FREE, request_id, 0, 0, 0);
}

// Zlib wrappers
fn gzip(data_ptr: [*]const u8, data_len: u32) i32 {
    return zlib_dispatch(ZLIB_OP_GZIP, @intFromPtr(data_ptr), data_len);
}
fn gunzip(data_ptr: [*]const u8, data_len: u32) i32 {
    return zlib_dispatch(ZLIB_OP_GUNZIP, @intFromPtr(data_ptr), data_len);
}
fn deflate(data_ptr: [*]const u8, data_len: u32) i32 {
    return zlib_dispatch(ZLIB_OP_DEFLATE, @intFromPtr(data_ptr), data_len);
}
fn inflate(data_ptr: [*]const u8, data_len: u32) i32 {
    return zlib_dispatch(ZLIB_OP_INFLATE, @intFromPtr(data_ptr), data_len);
}
fn zlib_get_result(dest_ptr: [*]u8) i32 {
    return zlib_dispatch(ZLIB_OP_GET_RESULT, @intFromPtr(dest_ptr), 0);
}

// Crypto wrappers
fn aes_gcm_encrypt(key_ptr: [*]const u8, key_len: u32, iv_ptr: [*]const u8, iv_len: u32, data_ptr: [*]const u8, data_len: u32) i32 {
    return crypto_dispatch(CRYPTO_OP_AES_GCM_ENCRYPT, @intFromPtr(key_ptr), key_len, @intFromPtr(iv_ptr), iv_len, @intFromPtr(data_ptr), data_len);
}
fn aes_gcm_decrypt(key_ptr: [*]const u8, key_len: u32, iv_ptr: [*]const u8, iv_len: u32, data_ptr: [*]const u8, data_len: u32) i32 {
    return crypto_dispatch(CRYPTO_OP_AES_GCM_DECRYPT, @intFromPtr(key_ptr), key_len, @intFromPtr(iv_ptr), iv_len, @intFromPtr(data_ptr), data_len);
}
fn crypto_get_result(dest_ptr: [*]u8) i32 {
    return crypto_dispatch(CRYPTO_OP_GET_RESULT, @intFromPtr(dest_ptr), 0, 0, 0, 0, 0);
}
fn random_bytes(dest_ptr: [*]u8, size: u32) i32 {
    return crypto_dispatch(CRYPTO_OP_RANDOM_BYTES, @intFromPtr(dest_ptr), size, 0, 0, 0, 0);
}

// Socket wrappers
fn socket_create() i32 {
    return socket_dispatch(SOCKET_OP_CREATE, 0, 0, 0);
}
fn socket_bind(socket_id: u32, port: u32) i32 {
    return socket_dispatch(SOCKET_OP_BIND, socket_id, port, 0);
}
fn socket_listen(socket_id: u32, backlog: u32) i32 {
    return socket_dispatch(SOCKET_OP_LISTEN, socket_id, backlog, 0);
}
fn socket_accept(socket_id: u32) i32 {
    return socket_dispatch(SOCKET_OP_ACCEPT, socket_id, 0, 0);
}
fn socket_connect(socket_id: u32, port: u32) i32 {
    return socket_dispatch(SOCKET_OP_CONNECT, socket_id, port, 0);
}
fn socket_write(socket_id: u32, data_ptr: [*]const u8, data_len: u32) i32 {
    return socket_dispatch(SOCKET_OP_WRITE, socket_id, @intFromPtr(data_ptr), data_len);
}
fn socket_read(socket_id: u32, max_len: u32) i32 {
    return socket_dispatch(SOCKET_OP_READ, socket_id, max_len, 0);
}
fn socket_get_read_data(socket_id: u32, dest_ptr: [*]u8) i32 {
    return socket_dispatch(SOCKET_OP_GET_READ_DATA, socket_id, @intFromPtr(dest_ptr), 0);
}
fn socket_close(socket_id: u32) i32 {
    return socket_dispatch(SOCKET_OP_CLOSE, socket_id, 0, 0);
}
fn socket_state(socket_id: u32) i32 {
    return socket_dispatch(SOCKET_OP_STATE, socket_id, 0, 0);
}

// We need to provide these C bridge functions since Zig can't directly import C arrays
// They'll be added to bundle_compiled.c by the build process

// ============================================================================
// Wizer Pre-initialization Export
// ============================================================================

export fn wizer_init() void {
    wizer_mod.wizer_init();
}

// ============================================================================
// Main Entry Point
// ============================================================================

// Global allocator for native bindings
var global_allocator: ?std.mem.Allocator = null;

// Startup timing for cold start measurement
var startup_time_ns: i128 = 0;

/// Get current time in nanoseconds (WASI clock)
fn getTimeNs() i128 {
    if (@import("builtin").target.os.tag == .wasi) {
        var ts: u64 = undefined;
        const rc = std.os.wasi.clock_time_get(.MONOTONIC, 1, &ts);
        if (rc == .SUCCESS) {
            return @as(i128, ts);
        }
    }
    return std.time.nanoTimestamp();
}

// Debug flag - check for EDGEBOX_DEBUG env var
var debug_enabled: bool = false;

fn debugPrint(comptime fmt: []const u8, args: anytype) void {
    if (debug_enabled) {
        std.debug.print("[EDGEBOX DEBUG] " ++ fmt, args);
    }
}

pub fn main() !void {
    startup_time_ns = getTimeNs();

    // Check debug mode early via WASI environ
    if (@import("builtin").target.os.tag == .wasi) {
        var environ_count: usize = 0;
        var environ_buf_size: usize = 0;
        _ = std.os.wasi.environ_sizes_get(&environ_count, &environ_buf_size);
        // For simplicity, we'll enable debug if any arg is --debug
    }

    // Use page_allocator for WASM - GPA's invalid free detection causes issues
    // with large JS bundles that may have quirky memory patterns in QuickJS
    const allocator = std.heap.page_allocator;
    global_allocator = allocator;

    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    // Check for debug via env or args
    if (std.posix.getenv("EDGEBOX_DEBUG")) |_| {
        debug_enabled = true;
    }

    // Check for debug and benchmark/cold-start flags
    for (args) |arg| {
        if (std.mem.eql(u8, arg, "--debug")) {
            debug_enabled = true;
        }
        if (std.mem.eql(u8, arg, "--cold-start") or std.mem.eql(u8, arg, "--benchmark")) {
            const end_time = getTimeNs();
            const startup_ms = @as(f64, @floatFromInt(end_time - startup_time_ns)) / 1_000_000.0;
            const wizer_status = if (wizer_mod.isWizerInitialized()) " (Wizer+Static)" else " (Static)";
            std.debug.print("Cold start{s}: {d:.2}ms\n", .{ wizer_status, startup_ms });
            if (std.mem.eql(u8, arg, "--cold-start")) return;
            break;
        }
    }

    debugPrint("Starting EdgeBox Static WASM\n", .{});
    debugPrint("Args count: {d}\n", .{args.len});
    for (args, 0..) |arg, i| {
        debugPrint("  arg[{d}]: {s}\n", .{ i, arg });
    }

    // WIZER FAST PATH: Use pre-initialized runtime
    const wizer_initialized = wizer_mod.isWizerInitialized();

    if (wizer_initialized) {
        runWithWizerRuntime(args) catch |err| {
            std.debug.print("Static runtime error: {}\n", .{err});
            std.process.exit(1);
        };
        std.process.exit(0);
    }

    // SLOW PATH: Initialize runtime and run bytecode
    var runtime = try quickjs.Runtime.init(allocator);
    defer runtime.deinit();

    qjs.js_std_init_handlers(runtime.inner);
    qjs.JS_SetHostPromiseRejectionTracker(runtime.inner, silentPromiseRejectionTracker, null);

    var c_argv = try allocator.alloc([*c]u8, args.len);
    defer allocator.free(c_argv);
    for (args, 0..) |arg, i| {
        c_argv[i] = @constCast(@ptrCast(arg.ptr));
    }

    var context = try runtime.newStdContextWithArgs(@intCast(c_argv.len), c_argv.ptr);
    defer context.deinit();

    const ctx = context.inner;
    registerWizerNativeBindings(ctx);
    importStdModules(&context) catch {};
    try executeBytecode(&context);
}

// ============================================================================
// Wizer Fast Path
// ============================================================================

const qjs = quickjs.c;

fn runWithWizerRuntime(args: []const [:0]u8) !void {
    const ctx = wizer_mod.getContext() orelse return error.WizerNotInitialized;

    // Initialize std handlers for event loop
    const rt = qjs.JS_GetRuntime(ctx);
    qjs.js_std_init_handlers(rt);
    qjs.JS_SetHostPromiseRejectionTracker(rt, silentPromiseRejectionTracker, null);

    // Set scriptArgs for process.argv
    const global = qjs.JS_GetGlobalObject(ctx);
    defer qjs.JS_FreeValue(ctx, global);

    const script_args = qjs.JS_NewArray(ctx);
    var idx: u32 = 0;
    for (args) |arg| {
        const str = qjs.JS_NewStringLen(ctx, arg.ptr, arg.len);
        _ = qjs.JS_SetPropertyUint32(ctx, script_args, idx, str);
        idx += 1;
    }
    _ = qjs.JS_SetPropertyStr(ctx, global, "scriptArgs", script_args);

    // Register print function
    const print_func = qjs.JS_NewCFunction(ctx, printNative, "print", 1);
    _ = qjs.JS_SetPropertyStr(ctx, global, "print", print_func);

    // Rebind console to use new print (wizer print is stale)
    const console_init =
        \\globalThis.console = globalThis.console || {};
        \\globalThis.console.log = function() { print.apply(null, arguments); };
        \\globalThis.console.error = function() { print.apply(null, ['[ERROR]'].concat(Array.prototype.slice.call(arguments))); };
        \\globalThis.console.warn = function() { print.apply(null, ['[WARN]'].concat(Array.prototype.slice.call(arguments))); };
        \\globalThis.console.info = function() { print.apply(null, arguments); };
        \\globalThis.console.debug = function() { print.apply(null, arguments); };
        \\globalThis.console.trace = function() { print.apply(null, arguments); try { throw new Error(); } catch(e) { print(e.stack); } };
        \\globalThis.console.dir = function(obj) { print(JSON.stringify(obj, null, 2)); };
        \\globalThis.console.time = globalThis.console.time || function() {};
        \\globalThis.console.timeEnd = globalThis.console.timeEnd || function() {};
        \\globalThis.console.assert = function(cond, msg) { if (!cond) print('[ASSERT]', msg || 'Assertion failed'); };
    ;
    const console_result = qjs.JS_Eval(ctx, console_init.ptr, console_init.len, "<console>", qjs.JS_EVAL_TYPE_GLOBAL);
    qjs.JS_FreeValue(ctx, console_result);

    // Register native bindings and init polyfills
    registerWizerNativeBindings(ctx);
    importWizerStdModules(ctx);
    initWizerPolyfills(ctx);

    // Execute bytecode
    try executeBytecodeRaw(ctx);
}

/// Native print function (minimal, replaces js_std_add_helpers version)
fn printNative(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    var i: usize = 0;
    var nwritten: usize = 0;
    while (i < @as(usize, @intCast(argc))) : (i += 1) {
        if (i > 0) {
            const space_iov = [_]std.os.wasi.ciovec_t{.{ .base = " ", .len = 1 }};
            _ = std.os.wasi.fd_write(1, &space_iov, 1, &nwritten);
        }
        var len: usize = undefined;
        const str = qjs.JS_ToCStringLen(ctx, &len, argv[i]);
        if (str != null) {
            const str_iov = [_]std.os.wasi.ciovec_t{.{ .base = str, .len = len }};
            _ = std.os.wasi.fd_write(1, &str_iov, 1, &nwritten);
            qjs.JS_FreeCString(ctx, str);
        }
    }
    const nl_iov = [_]std.os.wasi.ciovec_t{.{ .base = "\n", .len = 1 }};
    _ = std.os.wasi.fd_write(1, &nl_iov, 1, &nwritten);
    return qjs.JS_UNDEFINED;
}

/// Execute bytecode using Context wrapper
fn executeBytecode(context: *quickjs.Context) !void {
    const ctx = context.inner;
    std.debug.print("[executeBytecode] Starting\n", .{});

    // Get bytecode pointer and size from C bridge functions
    const bytecode_ptr = get_bundle_ptr();
    const bytecode_len = get_bundle_size();
    std.debug.print("[executeBytecode] Bytecode size: {d} bytes\n", .{bytecode_len});

    // Load bytecode object
    std.debug.print("[executeBytecode] Loading bytecode object\n", .{});
    const func = qjs.JS_ReadObject(ctx, bytecode_ptr, bytecode_len, qjs.JS_READ_OBJ_BYTECODE);
    if (qjs.JS_IsException(func)) {
        std.debug.print("Failed to load bytecode\n", .{});
        if (context.getException()) |exc| {
            defer exc.free();
            if (exc.toStringSlice()) |msg| {
                std.debug.print("Exception: {s}\n", .{msg});
            }
        }
        return error.BytecodeLoadFailed;
    }
    std.debug.print("[executeBytecode] Bytecode loaded OK\n", .{});

    // Re-register native bindings AFTER loading bytecode (in case scope changes)
    std.debug.print("[executeBytecode] Re-registering native bindings\n", .{});
    registerNativeBindings(context);

    // Also try setting a marker to verify registration works
    const global2 = qjs.JS_GetGlobalObject(ctx);
    const marker2 = qjs.JS_NewBool(ctx, true);
    _ = qjs.JS_SetPropertyStr(ctx, global2, "__after_bytecode_load", marker2);
    qjs.JS_FreeValue(ctx, global2);

    // Execute the bytecode
    std.debug.print("[executeBytecode] Calling JS_EvalFunction\n", .{});
    const result = qjs.JS_EvalFunction(ctx, func);
    std.debug.print("[executeBytecode] JS_EvalFunction returned\n", .{});
    if (qjs.JS_IsException(result)) {
        std.debug.print("Bytecode execution failed\n", .{});
        if (context.getException()) |exc| {
            defer exc.free();
            if (exc.toStringSlice()) |msg| {
                std.debug.print("Exception: {s}\n", .{msg});
            }
        }
        return error.ExecutionFailed;
    }
    qjs.JS_FreeValue(ctx, result);
    std.debug.print("[executeBytecode] Execution complete\n", .{});

    // Run the standard event loop - this handles both promises and timers together
    std.debug.print("[executeBytecode] Starting js_std_loop\n", .{});
    _ = qjs.js_std_loop(ctx);
    std.debug.print("[executeBytecode] js_std_loop returned\n", .{});
}

/// Execute bytecode using raw JSContext (Wizer path)
fn executeBytecodeRaw(ctx: *qjs.JSContext) !void {
    debugPrint("executeBytecodeRaw: Getting bytecode pointer\n", .{});
    const bytecode_ptr = get_bundle_ptr();
    const bytecode_len = get_bundle_size();
    debugPrint("executeBytecodeRaw: Bytecode at {*}, size={d} bytes\n", .{ bytecode_ptr, bytecode_len });

    if (bytecode_len == 0) {
        std.debug.print("ERROR: Bytecode is empty (0 bytes)!\n", .{});
        return error.BytecodeLoadFailed;
    }

    debugPrint("executeBytecodeRaw: Loading bytecode object\n", .{});
    const func = qjs.JS_ReadObject(ctx, bytecode_ptr, bytecode_len, qjs.JS_READ_OBJ_BYTECODE);
    if (qjs.JS_IsException(func)) {
        std.debug.print("ERROR: Failed to load bytecode (JS_ReadObject returned exception)\n", .{});
        printWizerException(ctx);
        return error.BytecodeLoadFailed;
    }
    debugPrint("executeBytecodeRaw: Bytecode loaded successfully\n", .{});

    debugPrint("executeBytecodeRaw: Executing bytecode via JS_EvalFunction\n", .{});
    const result = qjs.JS_EvalFunction(ctx, func);
    if (qjs.JS_IsException(result)) {
        std.debug.print("ERROR: Bytecode execution failed (JS_EvalFunction returned exception)\n", .{});
        printWizerException(ctx);
        return error.ExecutionFailed;
    }
    debugPrint("executeBytecodeRaw: Execution completed without exception\n", .{});
    qjs.JS_FreeValue(ctx, result);

    // Run pending Promise jobs (microtasks) first
    // This is critical because js_std_loop may return early if there are no timers/I/O
    {
        const rt = qjs.JS_GetRuntime(ctx);
        var pending_ctx: ?*qjs.JSContext = null;
        while (qjs.JS_ExecutePendingJob(rt, &pending_ctx) > 0) {}
    }

    // Run the standard event loop for async operations
    // This handles timers, promises, and I/O events
    // Note: js_std_init_handlers was already called in runWithWizerRuntime
    debugPrint("executeBytecodeRaw: Starting js_std_loop event loop\n", .{});
    const loop_result = qjs.js_std_loop(ctx);
    if (loop_result != 0) {
        debugPrint("executeBytecodeRaw: js_std_loop returned error: {d}\n", .{loop_result});
    }
    debugPrint("executeBytecodeRaw: Event loop completed\n", .{});
}

// ============================================================================
// Bindings and Polyfills
// ============================================================================

/// Bind dynamic state (process.argv, process.env)
fn bindDynamicState(ctx: *qjs.JSContext, args: []const [:0]u8) void {
    const dynamic_init =
        \\globalThis.process = globalThis.process || {};
        \\globalThis.process.version = 'v20.0.0';
        \\globalThis.process.versions = { node: '20.0.0' };
        \\globalThis.process.platform = 'wasi';
        \\globalThis.process.arch = 'wasm32';
        \\globalThis.process.exit = (code) => { if (typeof std !== 'undefined') std.exit(code || 0); };
        \\globalThis.process.cwd = () => std.getenv('PWD') || '/';
        \\globalThis.process.env = new Proxy({}, {
        \\    get(t, n) { return typeof n === 'symbol' ? undefined : std.getenv(String(n)); },
        \\    has(t, n) { return typeof n !== 'symbol' && std.getenv(String(n)) !== undefined; }
        \\});
        \\import * as std from 'std';
        \\globalThis.std = std;
    ;

    const val = qjs.JS_Eval(ctx, dynamic_init.ptr, dynamic_init.len, "<dynamic>", qjs.JS_EVAL_TYPE_MODULE);
    if (qjs.JS_IsException(val)) {
        std.debug.print("Dynamic init failed\n", .{});
        printWizerException(ctx);
    }
    qjs.JS_FreeValue(ctx, val);

    // Set process.argv
    const global = qjs.JS_GetGlobalObject(ctx);
    defer qjs.JS_FreeValue(ctx, global);

    const process = qjs.JS_GetPropertyStr(ctx, global, "process");
    defer qjs.JS_FreeValue(ctx, process);

    const argv_arr = qjs.JS_NewArray(ctx);
    var idx: u32 = 0;

    const node_str = qjs.JS_NewString(ctx, "node");
    _ = qjs.JS_SetPropertyUint32(ctx, argv_arr, idx, node_str);
    idx += 1;

    for (args[1..]) |arg| {
        const str = qjs.JS_NewStringLen(ctx, arg.ptr, arg.len);
        _ = qjs.JS_SetPropertyUint32(ctx, argv_arr, idx, str);
        idx += 1;
    }

    _ = qjs.JS_SetPropertyStr(ctx, process, "argv", argv_arr);
}

/// Register native bindings for Wizer context
fn registerWizerNativeBindings(ctx: *qjs.JSContext) void {
    const global = qjs.JS_GetGlobalObject(ctx);
    defer qjs.JS_FreeValue(ctx, global);

    inline for (.{
        .{ "__edgebox_fetch", nativeFetch, 4 },
        // Async HTTP bindings
        .{ "__edgebox_fetch_start", nativeFetchStart, 4 },
        .{ "__edgebox_fetch_poll", nativeFetchPoll, 1 },
        .{ "__edgebox_fetch_response", nativeFetchGetResponse, 1 },
        // Async Spawn bindings
        .{ "__edgebox_spawn_start", nativeSpawnStart, 1 },
        .{ "__edgebox_spawn_poll", nativeSpawnPoll, 1 },
        .{ "__edgebox_spawn_output", nativeSpawnGetOutput, 1 },
        // Async File I/O bindings
        .{ "__edgebox_file_read_start", nativeFileReadStart, 1 },
        .{ "__edgebox_file_write_start", nativeFileWriteStart, 2 },
        .{ "__edgebox_file_poll", nativeFilePoll, 1 },
        .{ "__edgebox_file_result", nativeFileGetResult, 1 },
        // Other bindings
        .{ "__edgebox_isatty", nativeIsatty, 1 },
        .{ "__edgebox_get_terminal_size", nativeGetTerminalSize, 0 },
        .{ "__edgebox_read_stdin", nativeReadStdin, 1 },
        .{ "__edgebox_spawn", nativeSpawn, 4 },
        // fs bindings
        .{ "__edgebox_fs_read", nativeFsRead, 1 },
        .{ "__edgebox_fs_write", nativeFsWrite, 2 },
        .{ "__edgebox_fs_append", nativeFsAppend, 2 },
        .{ "__edgebox_fs_exists", nativeFsExists, 1 },
        .{ "__edgebox_fs_stat", nativeFsStat, 1 },
        .{ "__edgebox_fs_readdir", nativeFsReaddir, 1 },
        .{ "__edgebox_fs_mkdir", nativeFsMkdir, 2 },
        .{ "__edgebox_fs_unlink", nativeFsUnlink, 1 },
        .{ "__edgebox_fs_rmdir", nativeFsRmdir, 2 },
        .{ "__edgebox_fs_rename", nativeFsRename, 2 },
        .{ "__edgebox_fs_copy", nativeFsCopy, 2 },
        .{ "__edgebox_cwd", nativeCwd, 0 },
        .{ "__edgebox_homedir", nativeHomedir, 0 },
        // crypto bindings
        .{ "__edgebox_hash", nativeHash, 2 },
        .{ "__edgebox_hmac", nativeHmac, 3 },
        // zlib bindings
        .{ "__edgebox_gzip", nativeGzip, 1 },
        .{ "__edgebox_gunzip", nativeGunzip, 1 },
        .{ "__edgebox_deflate", nativeDeflate, 1 },
        .{ "__edgebox_inflate", nativeInflate, 1 },
        // crypto AES bindings
        .{ "__edgebox_aes_gcm_encrypt", nativeAesGcmEncrypt, 3 },
        .{ "__edgebox_aes_gcm_decrypt", nativeAesGcmDecrypt, 3 },
        .{ "__edgebox_random_bytes", nativeRandomBytes, 1 },
        // socket bindings
        .{ "__edgebox_socket_create", nativeSocketCreate, 0 },
        .{ "__edgebox_socket_bind", nativeSocketBind, 2 },
        .{ "__edgebox_socket_listen", nativeSocketListen, 2 },
        .{ "__edgebox_socket_accept", nativeSocketAccept, 1 },
        .{ "__edgebox_socket_connect", nativeSocketConnect, 2 },
        .{ "__edgebox_socket_write", nativeSocketWrite, 2 },
        .{ "__edgebox_socket_read", nativeSocketRead, 2 },
        .{ "__edgebox_socket_close", nativeSocketClose, 1 },
        .{ "__edgebox_socket_state", nativeSocketState, 1 },
    }) |binding| {
        const func = qjs.JS_NewCFunction(ctx, binding[1], binding[0], binding[2]);
        _ = qjs.JS_SetPropertyStr(ctx, global, binding[0], func);
    }
}

/// Import std/os modules for Wizer path (raw JSContext)
/// CRITICAL: This must be called before bytecode execution so polyfills can use std/os
fn importWizerStdModules(ctx: *qjs.JSContext) void {
    const module_imports =
        \\import * as std from 'std';
        \\import * as os from 'os';
        \\globalThis.std = std;
        \\globalThis._os = os;
    ;

    const result = qjs.JS_Eval(
        ctx,
        module_imports.ptr,
        module_imports.len,
        "<std-import>",
        qjs.JS_EVAL_TYPE_MODULE,
    );

    if (qjs.JS_IsException(result)) {
        debugPrint("importWizerStdModules: Failed to import std/os modules\n", .{});
        printWizerException(ctx);
    } else {
        qjs.JS_FreeValue(ctx, result);
        debugPrint("importWizerStdModules: std/os modules imported successfully\n", .{});
    }
}

/// Bind dynamic state to Wizer-snapshotted polyfills (runtime)
/// Most polyfills are pre-loaded by Wizer at build time. This only binds:
/// 1. process.argv/env (from WASI runtime)
/// 2. fs module (needs std.loadFile and _os.stat from QuickJS modules)
fn initWizerPolyfills(ctx: *qjs.JSContext) void {
    debugPrint("initWizerPolyfills: Binding dynamic state to Wizer polyfills\n", .{});

    // Minimal runtime bindings - bind WASI functions to pre-defined fs module
    const runtime_bindings =
        \\// === Bind dynamic process.env from WASI ===
        \\(function() {
        \\    var g = globalThis, p = g.process, m = g._modules;
        \\    if (typeof std !== 'undefined' && std.getenv) {
        \\        p.env.HOME = std.getenv('HOME') || '/';
        \\        p.env.PWD = std.getenv('PWD') || '/';
        \\        p.env.PATH = std.getenv('PATH') || '/usr/bin';
        \\        p.env.USER = std.getenv('USER') || 'root';
        \\    }
        \\    p.argv = ['node'].concat(g.scriptArgs || []);
        \\    // Bind WASI to pre-defined fs stub
        \\    var fs = m['fs'];
        \\    fs._std = std; fs._os = _os;
        \\    m['node:fs'] = fs;
        \\    m['fs/promises'] = fs.promises;
        \\    m['node:fs/promises'] = fs.promises;
        \\})();
    ;

    const result = qjs.JS_Eval(
        ctx,
        runtime_bindings.ptr,
        runtime_bindings.len,
        "<runtime-bindings>",
        qjs.JS_EVAL_TYPE_GLOBAL,
    );

    if (qjs.JS_IsException(result)) {
        debugPrint("initWizerPolyfills: Failed to bind runtime state\n", .{});
        printWizerException(ctx);
    } else {
        qjs.JS_FreeValue(ctx, result);
        debugPrint("initWizerPolyfills: Runtime bindings complete\n", .{});
    }
}

/// Simple test function that returns 42
fn nativeTestFunc(ctx: ?*qjs.JSContext, _: qjs.JSValue, _: c_int, _: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    return qjs.JS_NewInt32(ctx, 42);
}

/// Register native bindings using Context wrapper
fn registerNativeBindings(context: *quickjs.Context) void {
    // Register a simple test function first
    context.registerGlobalFunction("__edgebox_test42", nativeTestFunc, 0);
    context.registerGlobalFunction("__edgebox_fetch", nativeFetch, 4);
    // Async HTTP bindings
    context.registerGlobalFunction("__edgebox_fetch_start", nativeFetchStart, 4);
    context.registerGlobalFunction("__edgebox_fetch_poll", nativeFetchPoll, 1);
    context.registerGlobalFunction("__edgebox_fetch_response", nativeFetchGetResponse, 1);
    // Async Spawn bindings
    context.registerGlobalFunction("__edgebox_spawn_start", nativeSpawnStart, 1);
    context.registerGlobalFunction("__edgebox_spawn_poll", nativeSpawnPoll, 1);
    context.registerGlobalFunction("__edgebox_spawn_output", nativeSpawnGetOutput, 1);
    // Async File I/O bindings
    context.registerGlobalFunction("__edgebox_file_read_start", nativeFileReadStart, 1);
    context.registerGlobalFunction("__edgebox_file_write_start", nativeFileWriteStart, 2);
    context.registerGlobalFunction("__edgebox_file_poll", nativeFilePoll, 1);
    context.registerGlobalFunction("__edgebox_file_result", nativeFileGetResult, 1);
    // Other bindings
    context.registerGlobalFunction("__edgebox_isatty", nativeIsatty, 1);
    context.registerGlobalFunction("__edgebox_get_terminal_size", nativeGetTerminalSize, 0);
    context.registerGlobalFunction("__edgebox_read_stdin", nativeReadStdin, 1);
    context.registerGlobalFunction("__edgebox_spawn", nativeSpawn, 4);
    // fs bindings
    context.registerGlobalFunction("__edgebox_fs_read", nativeFsRead, 1);
    context.registerGlobalFunction("__edgebox_fs_write", nativeFsWrite, 2);
    context.registerGlobalFunction("__edgebox_fs_append", nativeFsAppend, 2);
    context.registerGlobalFunction("__edgebox_fs_exists", nativeFsExists, 1);
    context.registerGlobalFunction("__edgebox_fs_stat", nativeFsStat, 1);
    context.registerGlobalFunction("__edgebox_fs_readdir", nativeFsReaddir, 1);
    context.registerGlobalFunction("__edgebox_fs_mkdir", nativeFsMkdir, 2);
    context.registerGlobalFunction("__edgebox_fs_unlink", nativeFsUnlink, 1);
    context.registerGlobalFunction("__edgebox_fs_rmdir", nativeFsRmdir, 2);
    context.registerGlobalFunction("__edgebox_fs_rename", nativeFsRename, 2);
    context.registerGlobalFunction("__edgebox_fs_copy", nativeFsCopy, 2);
    context.registerGlobalFunction("__edgebox_cwd", nativeCwd, 0);
    context.registerGlobalFunction("__edgebox_homedir", nativeHomedir, 0);
    // zlib bindings
    context.registerGlobalFunction("__edgebox_gzip", nativeGzip, 1);
    context.registerGlobalFunction("__edgebox_gunzip", nativeGunzip, 1);
    context.registerGlobalFunction("__edgebox_deflate", nativeDeflate, 1);
    context.registerGlobalFunction("__edgebox_inflate", nativeInflate, 1);
    // crypto AES bindings
    context.registerGlobalFunction("__edgebox_aes_gcm_encrypt", nativeAesGcmEncrypt, 3);
    context.registerGlobalFunction("__edgebox_aes_gcm_decrypt", nativeAesGcmDecrypt, 3);
    context.registerGlobalFunction("__edgebox_random_bytes", nativeRandomBytes, 1);
    // socket bindings
    context.registerGlobalFunction("__edgebox_socket_create", nativeSocketCreate, 0);
    context.registerGlobalFunction("__edgebox_socket_bind", nativeSocketBind, 2);
    context.registerGlobalFunction("__edgebox_socket_listen", nativeSocketListen, 2);
    context.registerGlobalFunction("__edgebox_socket_accept", nativeSocketAccept, 1);
    context.registerGlobalFunction("__edgebox_socket_connect", nativeSocketConnect, 2);
    context.registerGlobalFunction("__edgebox_socket_write", nativeSocketWrite, 2);
    context.registerGlobalFunction("__edgebox_socket_read", nativeSocketRead, 2);
    context.registerGlobalFunction("__edgebox_socket_close", nativeSocketClose, 1);
    context.registerGlobalFunction("__edgebox_socket_state", nativeSocketState, 1);
}

/// Import std/os modules - NOTE: This doesn't work for pre-compiled bytecode
/// because the module scope is separate. The polyfills have fallback implementations.
fn importStdModules(context: *quickjs.Context) !void {
    // TODO: Find a way to make std/os available to bytecode
    // For now, polyfills will use fallback implementations
    _ = context;
}

/// Print exception (Wizer path) with full stack trace
fn printWizerException(ctx: *qjs.JSContext) void {
    const exc = qjs.JS_GetException(ctx);
    defer qjs.JS_FreeValue(ctx, exc);

    // Get exception message
    var len: usize = undefined;
    const cstr = qjs.JS_ToCStringLen(ctx, &len, exc);
    if (cstr != null) {
        std.debug.print("Exception: {s}\n", .{cstr[0..len]});
        qjs.JS_FreeCString(ctx, cstr);
    } else {
        std.debug.print("Exception: (unable to convert to string)\n", .{});
    }

    // Try to get stack trace
    const stack_prop = qjs.JS_GetPropertyStr(ctx, exc, "stack");
    defer qjs.JS_FreeValue(ctx, stack_prop);

    if (!qjs.JS_IsUndefined(stack_prop) and !qjs.JS_IsNull(stack_prop)) {
        var stack_len: usize = undefined;
        const stack_cstr = qjs.JS_ToCStringLen(ctx, &stack_len, stack_prop);
        if (stack_cstr != null) {
            std.debug.print("Stack trace:\n{s}\n", .{stack_cstr[0..stack_len]});
            qjs.JS_FreeCString(ctx, stack_cstr);
        }
    }

    // Try to get the exception name/type
    const name_prop = qjs.JS_GetPropertyStr(ctx, exc, "name");
    defer qjs.JS_FreeValue(ctx, name_prop);

    if (!qjs.JS_IsUndefined(name_prop) and !qjs.JS_IsNull(name_prop)) {
        var name_len: usize = undefined;
        const name_cstr = qjs.JS_ToCStringLen(ctx, &name_len, name_prop);
        if (name_cstr != null) {
            std.debug.print("Exception type: {s}\n", .{name_cstr[0..name_len]});
            qjs.JS_FreeCString(ctx, name_cstr);
        }
    }
}

// ============================================================================
// Promise Rejection Handler
// ============================================================================

/// Silent promise rejection tracker - prevents QuickJS from calling exit(1) on unhandled rejections
/// In WASM, exit() doesn't work properly, causing an infinite loop of "Possibly unhandled promise rejection"
fn silentPromiseRejectionTracker(
    ctx: ?*qjs.JSContext,
    _: qjs.JSValue, // promise
    reason: qjs.JSValue,
    is_handled: bool,
    _: ?*anyopaque, // opaque
) callconv(.c) void {
    // Only log if debug is enabled and the rejection is NOT handled
    if (debug_enabled and !is_handled) {
        var len: usize = undefined;
        const reason_str = qjs.JS_ToCStringLen(ctx, &len, reason);
        if (reason_str != null) {
            std.debug.print("[EDGEBOX] Unhandled promise rejection: {s}\n", .{reason_str[0..len]});
            qjs.JS_FreeCString(ctx, reason_str);
        }
    }
    // Do nothing - don't exit, don't add to rejected list
    // This prevents the infinite loop in js_std_promise_rejection_check
}

// ============================================================================
// Native Binding Implementations (same as wasm_main.zig)
// ============================================================================

inline fn jsBool(val: bool) qjs.JSValue {
    return if (val) qjs.JS_TRUE else qjs.JS_FALSE;
}

fn getStringArg(ctx: ?*qjs.JSContext, val: qjs.JSValue) ?[]const u8 {
    var len: usize = undefined;
    const cstr = qjs.JS_ToCStringLen(ctx, &len, val);
    if (cstr == null) return null;
    return cstr[0..len];
}

fn freeStringArg(ctx: ?*qjs.JSContext, str: []const u8) void {
    qjs.JS_FreeCString(ctx, str.ptr);
}

fn nativeFetch(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "fetch requires url argument");

    const url = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "url must be a string");
    defer freeStringArg(ctx, url);

    std.debug.print("[nativeFetch] URL: {s}\n", .{url});

    const method = if (argc >= 2 and !qjs.JS_IsUndefined(argv[1]) and !qjs.JS_IsNull(argv[1]))
        getStringArg(ctx, argv[1]) orelse "GET"
    else
        "GET";
    const method_owned = argc >= 2 and !qjs.JS_IsUndefined(argv[1]) and !qjs.JS_IsNull(argv[1]) and getStringArg(ctx, argv[1]) != null;
    defer if (method_owned) freeStringArg(ctx, method);

    // Headers JSON (argv[2]) - for now we pass empty
    const headers_json: []const u8 = "";

    const body = if (argc >= 4 and !qjs.JS_IsUndefined(argv[3]) and !qjs.JS_IsNull(argv[3]))
        getStringArg(ctx, argv[3])
    else
        null;
    defer if (body) |b| freeStringArg(ctx, b);

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    // Call host HTTP bridge
    const status = request(
        url.ptr,
        @intCast(url.len),
        method.ptr,
        @intCast(method.len),
        headers_json.ptr,
        @intCast(headers_json.len),
        if (body) |b| b.ptr else "".ptr,
        if (body) |b| @intCast(b.len) else 0,
    );

    if (status < 0) {
        return switch (status) {
            -1 => qjs.JS_ThrowTypeError(ctx, "Invalid URL"),
            -2 => qjs.JS_ThrowInternalError(ctx, "HTTP request failed"),
            else => qjs.JS_ThrowInternalError(ctx, "Unknown HTTP error"),
        };
    }

    // Get response from host
    const response_len = get_response_len();
    if (response_len <= 0) {
        return qjs.JS_ThrowInternalError(ctx, "Empty response from host");
    }

    // Allocate buffer and copy response
    const response_buf = allocator.alloc(u8, @intCast(response_len)) catch {
        return qjs.JS_ThrowInternalError(ctx, "Out of memory");
    };
    defer allocator.free(response_buf);

    _ = get_response(response_buf.ptr);

    // Parse JSON response: {"status": N, "ok": bool, "body": "...", "headers": {...}}
    var parsed = std.json.parseFromSlice(std.json.Value, allocator, response_buf, .{}) catch {
        return qjs.JS_ThrowInternalError(ctx, "Failed to parse response JSON");
    };
    defer parsed.deinit();

    const obj = qjs.JS_NewObject(ctx);

    if (parsed.value == .object) {
        const map = &parsed.value.object;

        // Status
        if (map.get("status")) |s| {
            if (s == .integer) {
                _ = qjs.JS_SetPropertyStr(ctx, obj, "status", qjs.JS_NewInt32(ctx, @intCast(s.integer)));
            }
        }

        // Ok
        if (map.get("ok")) |o| {
            if (o == .bool) {
                _ = qjs.JS_SetPropertyStr(ctx, obj, "ok", jsBool(o.bool));
            }
        }

        // Body
        if (map.get("body")) |b| {
            if (b == .string) {
                _ = qjs.JS_SetPropertyStr(ctx, obj, "body", qjs.JS_NewStringLen(ctx, b.string.ptr, b.string.len));
            }
        }

        // Headers (empty object for now)
        _ = qjs.JS_SetPropertyStr(ctx, obj, "headers", qjs.JS_NewObject(ctx));
    }

    return obj;
}

// ============================================================================
// Async HTTP Native Bindings
// ============================================================================

/// Start an async HTTP request - returns request ID
fn nativeFetchStart(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "fetch requires url argument");

    const url = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "url must be a string");
    defer freeStringArg(ctx, url);

    const method = if (argc >= 2 and !qjs.JS_IsUndefined(argv[1]) and !qjs.JS_IsNull(argv[1]))
        getStringArg(ctx, argv[1]) orelse "GET"
    else
        "GET";
    const method_owned = argc >= 2 and !qjs.JS_IsUndefined(argv[1]) and !qjs.JS_IsNull(argv[1]) and getStringArg(ctx, argv[1]) != null;
    defer if (method_owned) freeStringArg(ctx, method);

    const headers_json: []const u8 = "";

    const body = if (argc >= 4 and !qjs.JS_IsUndefined(argv[3]) and !qjs.JS_IsNull(argv[3]))
        getStringArg(ctx, argv[3])
    else
        null;
    defer if (body) |b| freeStringArg(ctx, b);

    // Call host to start async request
    const request_id = start_async(
        url.ptr,
        @intCast(url.len),
        method.ptr,
        @intCast(method.len),
        headers_json.ptr,
        @intCast(headers_json.len),
        if (body) |b| b.ptr else "".ptr,
        if (body) |b| @intCast(b.len) else 0,
    );

    if (request_id < 0) {
        return switch (request_id) {
            -1 => qjs.JS_ThrowTypeError(ctx, "Invalid URL"),
            -3 => qjs.JS_ThrowInternalError(ctx, "Domain not allowed"),
            -4 => qjs.JS_ThrowInternalError(ctx, "Too many pending requests"),
            else => qjs.JS_ThrowInternalError(ctx, "Failed to start request"),
        };
    }

    return qjs.JS_NewInt32(ctx, request_id);
}

/// Poll an async HTTP request - returns 0=pending, 1=complete, <0=error
fn nativeFetchPoll(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_NewInt32(ctx, -1);

    var request_id: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &request_id, argv[0]) < 0) {
        return qjs.JS_NewInt32(ctx, -1);
    }

    const status = http_poll(@intCast(request_id));
    return qjs.JS_NewInt32(ctx, status);
}

/// Get response for a completed async request
fn nativeFetchGetResponse(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "request_id required");

    var request_id: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &request_id, argv[0]) < 0) {
        return qjs.JS_ThrowTypeError(ctx, "invalid request_id");
    }

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    // Get response length
    const response_len = http_response_len(@intCast(request_id));
    if (response_len <= 0) {
        return qjs.JS_ThrowInternalError(ctx, "No response available");
    }

    // Allocate buffer and copy response
    const response_buf = allocator.alloc(u8, @intCast(response_len)) catch {
        return qjs.JS_ThrowInternalError(ctx, "Out of memory");
    };
    defer allocator.free(response_buf);

    _ = http_response(@intCast(request_id), response_buf.ptr);

    // Parse JSON response
    var parsed = std.json.parseFromSlice(std.json.Value, allocator, response_buf, .{}) catch {
        return qjs.JS_ThrowInternalError(ctx, "Failed to parse response JSON");
    };
    defer parsed.deinit();

    const obj = qjs.JS_NewObject(ctx);

    if (parsed.value == .object) {
        const map = &parsed.value.object;

        if (map.get("status")) |s| {
            if (s == .integer) {
                _ = qjs.JS_SetPropertyStr(ctx, obj, "status", qjs.JS_NewInt32(ctx, @intCast(s.integer)));
            }
        }

        if (map.get("ok")) |o| {
            if (o == .bool) {
                _ = qjs.JS_SetPropertyStr(ctx, obj, "ok", jsBool(o.bool));
            }
        }

        if (map.get("body")) |b| {
            if (b == .string) {
                _ = qjs.JS_SetPropertyStr(ctx, obj, "body", qjs.JS_NewStringLen(ctx, b.string.ptr, b.string.len));
            }
        }

        _ = qjs.JS_SetPropertyStr(ctx, obj, "headers", qjs.JS_NewObject(ctx));
    }

    // Free the async request
    _ = http_free(@intCast(request_id));

    return obj;
}

// ============================================================================
// Async Spawn Native Bindings
// ============================================================================

/// Start an async spawn - returns spawn ID
fn nativeSpawnStart(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "spawn requires command argument");

    const command = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "command must be a string");
    defer freeStringArg(ctx, command);

    // Call host spawn_start
    const spawn_id = spawn_start(
        command.ptr,
        @intCast(command.len),
        "".ptr, // args (unused for now)
        0,
    );

    if (spawn_id < 0) {
        return switch (spawn_id) {
            -1 => qjs.JS_ThrowTypeError(ctx, "Invalid command"),
            -2 => qjs.JS_ThrowInternalError(ctx, "Empty command"),
            -3 => qjs.JS_ThrowInternalError(ctx, "Failed to spawn process"),
            -4 => qjs.JS_ThrowInternalError(ctx, "Too many pending spawns"),
            else => qjs.JS_ThrowInternalError(ctx, "Spawn failed"),
        };
    }

    return qjs.JS_NewInt32(ctx, spawn_id);
}

/// Poll an async spawn - returns 0=running, 1=done, <0=error
fn nativeSpawnPoll(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_NewInt32(ctx, -1);

    var spawn_id: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &spawn_id, argv[0]) < 0) {
        return qjs.JS_NewInt32(ctx, -1);
    }

    const status = spawn_poll(@intCast(spawn_id));
    return qjs.JS_NewInt32(ctx, status);
}

/// Get spawn output - returns {stdout, stderr, exitCode}
fn nativeSpawnGetOutput(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "spawn_id required");

    var spawn_id: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &spawn_id, argv[0]) < 0) {
        return qjs.JS_ThrowTypeError(ctx, "invalid spawn_id");
    }

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    // Get output length (this also builds the JSON)
    const output_len = spawn_output_len(@intCast(spawn_id));
    if (output_len <= 0) {
        return qjs.JS_ThrowInternalError(ctx, "No output available");
    }

    // Allocate buffer and copy output
    const output_buf = allocator.alloc(u8, @intCast(output_len)) catch {
        return qjs.JS_ThrowInternalError(ctx, "Out of memory");
    };
    defer allocator.free(output_buf);

    _ = spawn_output(@intCast(spawn_id), output_buf.ptr);

    // Parse JSON response: {"exitCode": N, "stdout": "...", "stderr": "..."}
    var parsed = std.json.parseFromSlice(std.json.Value, allocator, output_buf, .{}) catch {
        return qjs.JS_ThrowInternalError(ctx, "Failed to parse output JSON");
    };
    defer parsed.deinit();

    const obj = qjs.JS_NewObject(ctx);

    if (parsed.value == .object) {
        const map = &parsed.value.object;

        if (map.get("exitCode")) |e| {
            if (e == .integer) {
                _ = qjs.JS_SetPropertyStr(ctx, obj, "exitCode", qjs.JS_NewInt32(ctx, @intCast(e.integer)));
            }
        }

        if (map.get("stdout")) |s| {
            if (s == .string) {
                _ = qjs.JS_SetPropertyStr(ctx, obj, "stdout", qjs.JS_NewStringLen(ctx, s.string.ptr, s.string.len));
            }
        }

        if (map.get("stderr")) |s| {
            if (s == .string) {
                _ = qjs.JS_SetPropertyStr(ctx, obj, "stderr", qjs.JS_NewStringLen(ctx, s.string.ptr, s.string.len));
            }
        }
    }

    // Free the spawn request
    _ = spawn_free(@intCast(spawn_id));

    return obj;
}

// ============================================================================
// Async File I/O Native Bindings
// ============================================================================

/// Start an async file read - returns request ID
fn nativeFileReadStart(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "file read requires path argument");

    const path = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "path must be a string");
    defer freeStringArg(ctx, path);

    // Call host to start async file read
    const request_id = file_read_start(path.ptr, @intCast(path.len));

    if (request_id < 0) {
        return switch (request_id) {
            -1 => qjs.JS_ThrowTypeError(ctx, "Invalid path"),
            -4 => qjs.JS_ThrowInternalError(ctx, "Too many pending file operations"),
            else => qjs.JS_ThrowInternalError(ctx, "Failed to start file read"),
        };
    }

    return qjs.JS_NewInt32(ctx, request_id);
}

/// Start an async file write - returns request ID
fn nativeFileWriteStart(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "file write requires path and data arguments");

    const path = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "path must be a string");
    defer freeStringArg(ctx, path);

    const data = getStringArg(ctx, argv[1]) orelse
        return qjs.JS_ThrowTypeError(ctx, "data must be a string");
    defer freeStringArg(ctx, data);

    // Call host to start async file write
    const request_id = file_write_start(path.ptr, @intCast(path.len), data.ptr, @intCast(data.len));

    if (request_id < 0) {
        return switch (request_id) {
            -1 => qjs.JS_ThrowTypeError(ctx, "Invalid path"),
            -2 => qjs.JS_ThrowTypeError(ctx, "Invalid data"),
            -4 => qjs.JS_ThrowInternalError(ctx, "Too many pending file operations"),
            else => qjs.JS_ThrowInternalError(ctx, "Failed to start file write"),
        };
    }

    return qjs.JS_NewInt32(ctx, request_id);
}

/// Poll an async file operation - returns 0=pending, 1=complete, <0=error
fn nativeFilePoll(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_NewInt32(ctx, -1);

    var request_id: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &request_id, argv[0]) < 0) {
        return qjs.JS_NewInt32(ctx, -1);
    }

    const status = file_poll(@intCast(request_id));
    return qjs.JS_NewInt32(ctx, status);
}

/// Get result for a completed file operation
/// For reads: returns file content as string
/// For writes: returns bytes written as number
fn nativeFileGetResult(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "request_id required");

    var request_id: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &request_id, argv[0]) < 0) {
        return qjs.JS_ThrowTypeError(ctx, "invalid request_id");
    }

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    // Check poll status first
    const status = file_poll(@intCast(request_id));
    if (status == 0) {
        return qjs.JS_ThrowInternalError(ctx, "Operation still pending");
    }

    // Get result length
    const res_len = file_result_len(@intCast(request_id));

    if (res_len < 0) {
        // Error - res_len is negative of error message length
        const err_len: usize = @intCast(-res_len);
        const err_buf = allocator.alloc(u8, err_len) catch {
            _ = file_free(@intCast(request_id));
            return qjs.JS_ThrowInternalError(ctx, "Out of memory");
        };
        defer allocator.free(err_buf);

        _ = file_result(@intCast(request_id), err_buf.ptr);
        _ = file_free(@intCast(request_id));

        // Return error as exception
        return qjs.JS_ThrowInternalError(ctx, @ptrCast(err_buf.ptr));
    }

    if (res_len == 0) {
        // Write operation with 0 bytes or empty read
        _ = file_free(@intCast(request_id));
        return qjs.JS_NewInt32(ctx, 0);
    }

    // Allocate buffer and copy result
    const result_buf = allocator.alloc(u8, @intCast(res_len)) catch {
        _ = file_free(@intCast(request_id));
        return qjs.JS_ThrowInternalError(ctx, "Out of memory");
    };
    defer allocator.free(result_buf);

    const copied = file_result(@intCast(request_id), result_buf.ptr);
    _ = file_free(@intCast(request_id));

    if (copied < 0) {
        return qjs.JS_ThrowInternalError(ctx, "Failed to get result");
    }

    // Return as string (for read) or the string representation of data
    return qjs.JS_NewStringLen(ctx, result_buf.ptr, @intCast(copied));
}

// ============================================================================
// Zlib Native Bindings
// ============================================================================

/// Gzip compress - returns base64-encoded result
fn nativeGzip(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "gzip requires data argument");

    const data = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "data must be a string");
    defer freeStringArg(ctx, data);

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    // Call host gzip function
    const result_len = gzip(data.ptr, @intCast(data.len));
    if (result_len < 0) {
        return qjs.JS_ThrowInternalError(ctx, "Compression failed");
    }

    // Get compressed data
    const result_buf = allocator.alloc(u8, @intCast(result_len)) catch {
        return qjs.JS_ThrowInternalError(ctx, "Out of memory");
    };
    defer allocator.free(result_buf);

    _ = zlib_get_result(result_buf.ptr);

    // Return as binary string (each byte as char code)
    return qjs.JS_NewStringLen(ctx, result_buf.ptr, @intCast(result_len));
}

/// Gunzip decompress
fn nativeGunzip(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "gunzip requires data argument");

    const data = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "data must be a string");
    defer freeStringArg(ctx, data);

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    const result_len = gunzip(data.ptr, @intCast(data.len));
    if (result_len < 0) {
        return qjs.JS_ThrowInternalError(ctx, "Decompression failed");
    }

    const result_buf = allocator.alloc(u8, @intCast(result_len)) catch {
        return qjs.JS_ThrowInternalError(ctx, "Out of memory");
    };
    defer allocator.free(result_buf);

    _ = zlib_get_result(result_buf.ptr);
    return qjs.JS_NewStringLen(ctx, result_buf.ptr, @intCast(result_len));
}

/// Deflate compress (zlib format)
fn nativeDeflate(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "deflate requires data argument");

    const data = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "data must be a string");
    defer freeStringArg(ctx, data);

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    const result_len = deflate(data.ptr, @intCast(data.len));
    if (result_len < 0) {
        return qjs.JS_ThrowInternalError(ctx, "Compression failed");
    }

    const result_buf = allocator.alloc(u8, @intCast(result_len)) catch {
        return qjs.JS_ThrowInternalError(ctx, "Out of memory");
    };
    defer allocator.free(result_buf);

    _ = zlib_get_result(result_buf.ptr);
    return qjs.JS_NewStringLen(ctx, result_buf.ptr, @intCast(result_len));
}

/// Inflate decompress (zlib format)
fn nativeInflate(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "inflate requires data argument");

    const data = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "data must be a string");
    defer freeStringArg(ctx, data);

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    const result_len = inflate(data.ptr, @intCast(data.len));
    if (result_len < 0) {
        return qjs.JS_ThrowInternalError(ctx, "Decompression failed");
    }

    const result_buf = allocator.alloc(u8, @intCast(result_len)) catch {
        return qjs.JS_ThrowInternalError(ctx, "Out of memory");
    };
    defer allocator.free(result_buf);

    _ = zlib_get_result(result_buf.ptr);
    return qjs.JS_NewStringLen(ctx, result_buf.ptr, @intCast(result_len));
}

// ============================================================================
// Crypto AES Native Bindings
// ============================================================================

/// AES-GCM encrypt - takes key, iv, data (all binary strings)
fn nativeAesGcmEncrypt(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 3) return qjs.JS_ThrowTypeError(ctx, "aes_gcm_encrypt requires key, iv, data arguments");

    const key = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "key must be a string");
    defer freeStringArg(ctx, key);

    const iv = getStringArg(ctx, argv[1]) orelse
        return qjs.JS_ThrowTypeError(ctx, "iv must be a string");
    defer freeStringArg(ctx, iv);

    const data = getStringArg(ctx, argv[2]) orelse
        return qjs.JS_ThrowTypeError(ctx, "data must be a string");
    defer freeStringArg(ctx, data);

    if (key.len != 32) {
        return qjs.JS_ThrowTypeError(ctx, "AES-256-GCM requires 32-byte key");
    }
    if (iv.len != 12) {
        return qjs.JS_ThrowTypeError(ctx, "AES-GCM requires 12-byte IV");
    }

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    const result_len = aes_gcm_encrypt(key.ptr, @intCast(key.len), iv.ptr, @intCast(iv.len), data.ptr, @intCast(data.len));
    if (result_len < 0) {
        return qjs.JS_ThrowInternalError(ctx, "Encryption failed");
    }

    const result_buf = allocator.alloc(u8, @intCast(result_len)) catch {
        return qjs.JS_ThrowInternalError(ctx, "Out of memory");
    };
    defer allocator.free(result_buf);

    _ = crypto_get_result(result_buf.ptr);
    return qjs.JS_NewStringLen(ctx, result_buf.ptr, @intCast(result_len));
}

/// AES-GCM decrypt - takes key, iv, ciphertext+tag (all binary strings)
fn nativeAesGcmDecrypt(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 3) return qjs.JS_ThrowTypeError(ctx, "aes_gcm_decrypt requires key, iv, data arguments");

    const key = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "key must be a string");
    defer freeStringArg(ctx, key);

    const iv = getStringArg(ctx, argv[1]) orelse
        return qjs.JS_ThrowTypeError(ctx, "iv must be a string");
    defer freeStringArg(ctx, iv);

    const data = getStringArg(ctx, argv[2]) orelse
        return qjs.JS_ThrowTypeError(ctx, "data must be a string");
    defer freeStringArg(ctx, data);

    if (key.len != 32) {
        return qjs.JS_ThrowTypeError(ctx, "AES-256-GCM requires 32-byte key");
    }
    if (iv.len != 12) {
        return qjs.JS_ThrowTypeError(ctx, "AES-GCM requires 12-byte IV");
    }
    if (data.len < 16) {
        return qjs.JS_ThrowTypeError(ctx, "Ciphertext must include 16-byte auth tag");
    }

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    const result_len = aes_gcm_decrypt(key.ptr, @intCast(key.len), iv.ptr, @intCast(iv.len), data.ptr, @intCast(data.len));
    if (result_len < 0) {
        return qjs.JS_ThrowInternalError(ctx, "Decryption failed - authentication error");
    }

    const result_buf = allocator.alloc(u8, @intCast(result_len)) catch {
        return qjs.JS_ThrowInternalError(ctx, "Out of memory");
    };
    defer allocator.free(result_buf);

    _ = crypto_get_result(result_buf.ptr);
    return qjs.JS_NewStringLen(ctx, result_buf.ptr, @intCast(result_len));
}

/// Generate cryptographically secure random bytes
fn nativeRandomBytes(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "randomBytes requires size argument");

    var size: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &size, argv[0]) < 0 or size < 0 or size > 65536) {
        return qjs.JS_ThrowTypeError(ctx, "size must be 0-65536");
    }

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    const result_buf = allocator.alloc(u8, @intCast(size)) catch {
        return qjs.JS_ThrowInternalError(ctx, "Out of memory");
    };
    defer allocator.free(result_buf);

    const written = random_bytes(result_buf.ptr, @intCast(size));
    if (written < 0) {
        return qjs.JS_ThrowInternalError(ctx, "Failed to generate random bytes");
    }

    return qjs.JS_NewStringLen(ctx, result_buf.ptr, @intCast(written));
}

// ============================================================================
// Socket Native Bindings
// ============================================================================

/// Create a new socket - returns socket ID
fn nativeSocketCreate(ctx: ?*qjs.JSContext, _: qjs.JSValue, _: c_int, _: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    const result = socket_create();
    if (result < 0) {
        return qjs.JS_ThrowInternalError(ctx, "Failed to create socket");
    }
    return qjs.JS_NewInt32(ctx, result);
}

/// Bind socket to a port
fn nativeSocketBind(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "bind requires socket_id and port");

    var socket_id: i32 = 0;
    var port: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &socket_id, argv[0]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid socket_id");
    if (qjs.JS_ToInt32(ctx, &port, argv[1]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid port");

    const result = socket_bind(@intCast(socket_id), @intCast(port));
    return qjs.JS_NewInt32(ctx, result);
}

/// Listen on socket
fn nativeSocketListen(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "listen requires socket_id and backlog");

    var socket_id: i32 = 0;
    var backlog: i32 = 128;
    if (qjs.JS_ToInt32(ctx, &socket_id, argv[0]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid socket_id");
    if (argc >= 2) _ = qjs.JS_ToInt32(ctx, &backlog, argv[1]);

    const result = socket_listen(@intCast(socket_id), @intCast(backlog));
    return qjs.JS_NewInt32(ctx, result);
}

/// Accept connection - returns new socket ID or 0 if no pending connection
fn nativeSocketAccept(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "accept requires socket_id");

    var socket_id: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &socket_id, argv[0]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid socket_id");

    const result = socket_accept(@intCast(socket_id));
    return qjs.JS_NewInt32(ctx, result);
}

/// Connect to a port
fn nativeSocketConnect(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "connect requires socket_id and port");

    var socket_id: i32 = 0;
    var port: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &socket_id, argv[0]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid socket_id");
    if (qjs.JS_ToInt32(ctx, &port, argv[1]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid port");

    const result = socket_connect(@intCast(socket_id), @intCast(port));
    return qjs.JS_NewInt32(ctx, result);
}

/// Write data to socket
fn nativeSocketWrite(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "write requires socket_id and data");

    var socket_id: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &socket_id, argv[0]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid socket_id");

    const data = getStringArg(ctx, argv[1]) orelse return qjs.JS_ThrowTypeError(ctx, "data must be string");
    defer freeStringArg(ctx, data);

    const result = socket_write(@intCast(socket_id), data.ptr, @intCast(data.len));
    return qjs.JS_NewInt32(ctx, result);
}

/// Read from socket - returns data as string
fn nativeSocketRead(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "read requires socket_id");

    var socket_id: i32 = 0;
    var max_len: i32 = 8192;
    if (qjs.JS_ToInt32(ctx, &socket_id, argv[0]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid socket_id");
    if (argc >= 2) _ = qjs.JS_ToInt32(ctx, &max_len, argv[1]);

    const allocator = global_allocator orelse return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    const bytes_read = socket_read(@intCast(socket_id), @intCast(max_len));
    if (bytes_read < 0) {
        if (bytes_read == -4) {
            // Connection closed - return null
            return qjs.JS_NULL;
        }
        return qjs.JS_ThrowInternalError(ctx, "Read failed");
    }
    if (bytes_read == 0) {
        // No data available (non-blocking)
        return qjs.JS_NewStringLen(ctx, "", 0);
    }

    // Get the data
    const result_buf = allocator.alloc(u8, @intCast(bytes_read)) catch {
        return qjs.JS_ThrowInternalError(ctx, "Out of memory");
    };
    defer allocator.free(result_buf);

    _ = socket_get_read_data(@intCast(socket_id), result_buf.ptr);
    return qjs.JS_NewStringLen(ctx, result_buf.ptr, @intCast(bytes_read));
}

/// Close socket
fn nativeSocketClose(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "close requires socket_id");

    var socket_id: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &socket_id, argv[0]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid socket_id");

    const result = socket_close(@intCast(socket_id));
    return qjs.JS_NewInt32(ctx, result);
}

/// Get socket state
fn nativeSocketState(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "state requires socket_id");

    var socket_id: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &socket_id, argv[0]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid socket_id");

    const result = socket_state(@intCast(socket_id));
    return qjs.JS_NewInt32(ctx, result);
}

fn nativeIsatty(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return jsBool(false);

    var fd: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &fd, argv[0]) < 0) {
        return jsBool(false);
    }

    return jsBool(wasi_tty.isatty(fd));
}

fn nativeGetTerminalSize(ctx: ?*qjs.JSContext, _: qjs.JSValue, _: c_int, _: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    const size = wasi_tty.getTerminalSize() orelse {
        const obj = qjs.JS_NewObject(ctx);
        _ = qjs.JS_SetPropertyStr(ctx, obj, "rows", qjs.JS_NewInt32(ctx, 24));
        _ = qjs.JS_SetPropertyStr(ctx, obj, "cols", qjs.JS_NewInt32(ctx, 80));
        return obj;
    };

    const obj = qjs.JS_NewObject(ctx);
    _ = qjs.JS_SetPropertyStr(ctx, obj, "rows", qjs.JS_NewInt32(ctx, size.rows));
    _ = qjs.JS_SetPropertyStr(ctx, obj, "cols", qjs.JS_NewInt32(ctx, size.cols));
    return obj;
}

fn nativeReadStdin(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    var max_size: i32 = 1024;
    if (argc >= 1) {
        _ = qjs.JS_ToInt32(ctx, &max_size, argv[0]);
    }
    if (max_size <= 0) max_size = 1024;

    const line = wasi_tty.readLine(allocator, @intCast(max_size)) catch |err| {
        return qjs.JS_ThrowInternalError(ctx, "read error: %d", @intFromError(err));
    } orelse {
        return qjs.JS_NULL;
    };
    defer allocator.free(line);

    return qjs.JS_NewStringLen(ctx, line.ptr, line.len);
}

fn nativeSpawn(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "spawn requires command argument");

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    const command = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "command must be a string");
    defer freeStringArg(ctx, command);

    var cmd = wasi_process.Command.init(allocator, command);
    defer cmd.deinit();

    // Parse args array
    if (argc >= 2 and qjs.JS_IsArray(argv[1])) {
        const arr_len_val = qjs.JS_GetPropertyStr(ctx, argv[1], "length");
        var arr_len: i32 = 0;
        _ = qjs.JS_ToInt32(ctx, &arr_len, arr_len_val);
        qjs.JS_FreeValue(ctx, arr_len_val);

        var i: u32 = 0;
        while (i < @as(u32, @intCast(arr_len))) : (i += 1) {
            const elem = qjs.JS_GetPropertyUint32(ctx, argv[1], i);
            defer qjs.JS_FreeValue(ctx, elem);

            if (getStringArg(ctx, elem)) |arg_str| {
                const arg_copy = allocator.dupe(u8, arg_str) catch {
                    return qjs.JS_ThrowInternalError(ctx, "out of memory");
                };
                freeStringArg(ctx, arg_str);
                _ = cmd.arg(arg_copy) catch {
                    allocator.free(arg_copy);
                    return qjs.JS_ThrowInternalError(ctx, "out of memory");
                };
            }
        }
    }

    // Set stdin
    if (argc >= 3 and !qjs.JS_IsNull(argv[2]) and !qjs.JS_IsUndefined(argv[2])) {
        if (getStringArg(ctx, argv[2])) |stdin_data| {
            _ = cmd.setStdin(stdin_data);
        }
    }

    // Set timeout
    if (argc >= 4) {
        var timeout: i32 = 30000;
        _ = qjs.JS_ToInt32(ctx, &timeout, argv[3]);
        if (timeout > 0) {
            _ = cmd.setTimeout(@intCast(timeout));
        }
    }

    var result = cmd.output() catch |err| {
        return switch (err) {
            wasi_process.ProcessError.CommandFailed => qjs.JS_ThrowInternalError(ctx, "Command failed"),
            wasi_process.ProcessError.TimedOut => qjs.JS_ThrowInternalError(ctx, "Command timed out"),
            wasi_process.ProcessError.OutOfMemory => qjs.JS_ThrowInternalError(ctx, "Out of memory"),
            wasi_process.ProcessError.InvalidCommand => qjs.JS_ThrowTypeError(ctx, "Invalid command"),
            wasi_process.ProcessError.PermissionDenied => qjs.JS_ThrowTypeError(ctx, "Permission denied: command not in allowed list"),
        };
    };
    defer result.deinit();

    const obj = qjs.JS_NewObject(ctx);
    _ = qjs.JS_SetPropertyStr(ctx, obj, "exitCode", qjs.JS_NewInt32(ctx, result.exit_code));

    if (result.stdout.len > 0) {
        _ = qjs.JS_SetPropertyStr(ctx, obj, "stdout", qjs.JS_NewStringLen(ctx, result.stdout.ptr, result.stdout.len));
    } else {
        _ = qjs.JS_SetPropertyStr(ctx, obj, "stdout", qjs.JS_NewString(ctx, ""));
    }

    if (result.stderr.len > 0) {
        _ = qjs.JS_SetPropertyStr(ctx, obj, "stderr", qjs.JS_NewStringLen(ctx, result.stderr.ptr, result.stderr.len));
    } else {
        _ = qjs.JS_SetPropertyStr(ctx, obj, "stderr", qjs.JS_NewString(ctx, ""));
    }

    return obj;
}

// ============================================================================
// File System Native Bindings
// ============================================================================

/// Read file contents
fn nativeFsRead(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "fs.readFileSync requires path argument");

    const path = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "path must be a string");
    defer freeStringArg(ctx, path);

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    const file = std.fs.cwd().openFile(path, .{}) catch {
        return qjs.JS_ThrowInternalError(ctx, "ENOENT: no such file or directory");
    };
    defer file.close();

    const content = file.readToEndAlloc(allocator, 100 * 1024 * 1024) catch {
        return qjs.JS_ThrowInternalError(ctx, "failed to read file");
    };
    defer allocator.free(content);

    return qjs.JS_NewStringLen(ctx, content.ptr, content.len);
}

/// Write data to file
fn nativeFsWrite(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "fs.writeFileSync requires path and data arguments");

    const path = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "path must be a string");
    defer freeStringArg(ctx, path);

    const data = getStringArg(ctx, argv[1]) orelse
        return qjs.JS_ThrowTypeError(ctx, "data must be a string");
    defer freeStringArg(ctx, data);

    // Try to create parent directories first
    if (std.mem.lastIndexOf(u8, path, "/")) |last_slash| {
        if (last_slash > 0) {
            const dir_path = path[0..last_slash];
            std.fs.cwd().makePath(dir_path) catch {};
        }
    }

    // Try to create parent directories for absolute paths
    if (path.len > 0 and path[0] == '/') {
        if (std.mem.lastIndexOf(u8, path, "/")) |last_slash| {
            if (last_slash > 0) {
                const parent = path[0..last_slash];
                std.fs.makeDirAbsolute(parent) catch |e| {
                    // Try recursive
                    if (e == error.FileNotFound) {
                        var pos: usize = 1;
                        while (pos < last_slash) {
                            if (std.mem.indexOfPos(u8, path, pos, "/")) |next| {
                                std.fs.makeDirAbsolute(path[0..next]) catch {};
                                pos = next + 1;
                            } else break;
                        }
                        std.fs.makeDirAbsolute(parent) catch {};
                    }
                };
            }
        }

        // Create file at absolute path
        const abs_file = std.fs.createFileAbsolute(path, .{}) catch {
            return qjs.JS_ThrowInternalError(ctx, "EACCES: permission denied or path not writable");
        };
        defer abs_file.close();
        abs_file.writeAll(data) catch {
            return qjs.JS_ThrowInternalError(ctx, "failed to write file data");
        };
        return qjs.JS_UNDEFINED;
    }

    // Relative path - use cwd
    const file = std.fs.cwd().createFile(path, .{}) catch {
        return qjs.JS_ThrowInternalError(ctx, "ENOENT: cannot create file");
    };
    defer file.close();

    file.writeAll(data) catch {
        return qjs.JS_ThrowInternalError(ctx, "failed to write file data");
    };

    return qjs.JS_UNDEFINED;
}

/// Append data to file
fn nativeFsAppend(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "fs.appendFileSync requires path and data arguments");

    const path = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "path must be a string");
    defer freeStringArg(ctx, path);

    const data = getStringArg(ctx, argv[1]) orelse
        return qjs.JS_ThrowTypeError(ctx, "data must be a string");
    defer freeStringArg(ctx, data);

    // Create parent directories if needed
    if (std.mem.lastIndexOf(u8, path, "/")) |last_slash| {
        if (last_slash > 0) {
            const dir_path = path[0..last_slash];
            std.fs.cwd().makePath(dir_path) catch {};
        }
    }

    // Handle absolute paths
    if (path.len > 0 and path[0] == '/') {
        if (std.mem.lastIndexOf(u8, path, "/")) |last_slash| {
            if (last_slash > 0) {
                const parent = path[0..last_slash];
                std.fs.makeDirAbsolute(parent) catch |e| {
                    if (e == error.FileNotFound) {
                        var pos: usize = 1;
                        while (pos < last_slash) {
                            if (std.mem.indexOfPos(u8, path, pos, "/")) |next| {
                                std.fs.makeDirAbsolute(path[0..next]) catch {};
                                pos = next + 1;
                            } else break;
                        }
                        std.fs.makeDirAbsolute(parent) catch {};
                    }
                };
            }
        }

        // Open file for append at absolute path
        const abs_file = std.fs.openFileAbsolute(path, .{ .mode = .write_only }) catch |err| blk: {
            if (err == error.FileNotFound) {
                break :blk std.fs.createFileAbsolute(path, .{}) catch {
                    return qjs.JS_ThrowInternalError(ctx, "EACCES: permission denied or path not writable");
                };
            }
            return qjs.JS_ThrowInternalError(ctx, "EACCES: permission denied or path not writable");
        };
        defer abs_file.close();
        abs_file.seekFromEnd(0) catch {};
        abs_file.writeAll(data) catch {
            return qjs.JS_ThrowInternalError(ctx, "failed to append file data");
        };
        return qjs.JS_UNDEFINED;
    }

    // Relative path - use cwd
    const file = std.fs.cwd().openFile(path, .{ .mode = .write_only }) catch |err| blk: {
        if (err == error.FileNotFound) {
            break :blk std.fs.cwd().createFile(path, .{}) catch {
                return qjs.JS_ThrowInternalError(ctx, "ENOENT: cannot create file");
            };
        }
        return qjs.JS_ThrowInternalError(ctx, "ENOENT: cannot open file");
    };
    defer file.close();

    file.seekFromEnd(0) catch {};
    file.writeAll(data) catch {
        return qjs.JS_ThrowInternalError(ctx, "failed to append file data");
    };

    return qjs.JS_UNDEFINED;
}

/// Check if file exists
fn nativeFsExists(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return jsBool(false);

    const path = getStringArg(ctx, argv[0]) orelse return jsBool(false);
    defer freeStringArg(ctx, path);

    std.fs.cwd().access(path, .{}) catch return jsBool(false);
    return jsBool(true);
}

/// Get file stats
fn nativeFsStat(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "fs.statSync requires path argument");

    const path = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "path must be a string");
    defer freeStringArg(ctx, path);

    const stat = std.fs.cwd().statFile(path) catch {
        return qjs.JS_ThrowInternalError(ctx, "ENOENT: no such file or directory");
    };

    const obj = qjs.JS_NewObject(ctx);
    _ = qjs.JS_SetPropertyStr(ctx, obj, "size", qjs.JS_NewInt64(ctx, @intCast(stat.size)));

    const is_dir = stat.kind == .directory;
    const mode: i32 = if (is_dir) 0o40755 else 0o100644;
    _ = qjs.JS_SetPropertyStr(ctx, obj, "mode", qjs.JS_NewInt32(ctx, mode));
    _ = qjs.JS_SetPropertyStr(ctx, obj, "_isDir", jsBool(is_dir));
    _ = qjs.JS_SetPropertyStr(ctx, obj, "_isFile", jsBool(!is_dir));

    // Add isFile/isDirectory methods via eval
    const methods_code =
        \\(function(obj) {
        \\    obj.isFile = function() { return this._isFile; };
        \\    obj.isDirectory = function() { return this._isDir; };
        \\    return obj;
        \\})
    ;
    const methods_fn = qjs.JS_Eval(ctx, methods_code.ptr, methods_code.len, "<stat>", qjs.JS_EVAL_TYPE_GLOBAL);
    if (!qjs.JS_IsException(methods_fn)) {
        var args = [_]qjs.JSValue{obj};
        const result = qjs.JS_Call(ctx, methods_fn, qjs.JS_UNDEFINED, 1, &args);
        qjs.JS_FreeValue(ctx, methods_fn);
        if (!qjs.JS_IsException(result)) {
            return result;
        }
        qjs.JS_FreeValue(ctx, result);
    } else {
        qjs.JS_FreeValue(ctx, methods_fn);
    }

    return obj;
}

/// Read directory entries
fn nativeFsReaddir(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "fs.readdirSync requires path argument");

    const path = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "path must be a string");
    defer freeStringArg(ctx, path);

    var dir = std.fs.cwd().openDir(path, .{ .iterate = true }) catch {
        return qjs.JS_ThrowInternalError(ctx, "ENOENT: no such file or directory");
    };
    defer dir.close();

    const arr = qjs.JS_NewArray(ctx);
    var idx: u32 = 0;

    var iter = dir.iterate();
    while (iter.next() catch null) |entry| {
        const name_val = qjs.JS_NewStringLen(ctx, entry.name.ptr, entry.name.len);
        _ = qjs.JS_SetPropertyUint32(ctx, arr, idx, name_val);
        idx += 1;
    }

    return arr;
}

/// Create directory
fn nativeFsMkdir(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "fs.mkdirSync requires path argument");

    const path = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "path must be a string");
    defer freeStringArg(ctx, path);

    const recursive = if (argc >= 2) qjs.JS_ToBool(ctx, argv[1]) != 0 else false;

    if (recursive) {
        std.fs.cwd().makePath(path) catch {
            return qjs.JS_ThrowInternalError(ctx, "failed to create directory");
        };
    } else {
        std.fs.cwd().makeDir(path) catch {
            return qjs.JS_ThrowInternalError(ctx, "failed to create directory");
        };
    }

    return qjs.JS_UNDEFINED;
}

/// Delete file
fn nativeFsUnlink(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "fs.unlinkSync requires path argument");

    const path = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "path must be a string");
    defer freeStringArg(ctx, path);

    std.fs.cwd().deleteFile(path) catch {
        return qjs.JS_ThrowInternalError(ctx, "ENOENT: no such file or directory");
    };

    return qjs.JS_UNDEFINED;
}

/// Delete directory
fn nativeFsRmdir(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "fs.rmdirSync requires path argument");

    const path = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "path must be a string");
    defer freeStringArg(ctx, path);

    const recursive = if (argc >= 2) qjs.JS_ToBool(ctx, argv[1]) != 0 else false;

    if (recursive) {
        std.fs.cwd().deleteTree(path) catch {
            return qjs.JS_ThrowInternalError(ctx, "failed to delete directory");
        };
    } else {
        std.fs.cwd().deleteDir(path) catch {
            return qjs.JS_ThrowInternalError(ctx, "ENOTEMPTY: directory not empty");
        };
    }

    return qjs.JS_UNDEFINED;
}

/// Rename file/directory
fn nativeFsRename(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "fs.renameSync requires oldPath and newPath arguments");

    const old_path = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "oldPath must be a string");
    defer freeStringArg(ctx, old_path);

    const new_path = getStringArg(ctx, argv[1]) orelse
        return qjs.JS_ThrowTypeError(ctx, "newPath must be a string");
    defer freeStringArg(ctx, new_path);

    std.fs.cwd().rename(old_path, new_path) catch {
        return qjs.JS_ThrowInternalError(ctx, "failed to rename");
    };

    return qjs.JS_UNDEFINED;
}

/// Copy file
fn nativeFsCopy(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "fs.copyFileSync requires src and dest arguments");

    const src = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "src must be a string");
    defer freeStringArg(ctx, src);

    const dest = getStringArg(ctx, argv[1]) orelse
        return qjs.JS_ThrowTypeError(ctx, "dest must be a string");
    defer freeStringArg(ctx, dest);

    std.fs.cwd().copyFile(src, std.fs.cwd(), dest, .{}) catch {
        return qjs.JS_ThrowInternalError(ctx, "failed to copy file");
    };

    return qjs.JS_UNDEFINED;
}

/// Get current working directory
fn nativeCwd(ctx: ?*qjs.JSContext, _: qjs.JSValue, _: c_int, _: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    // Get PWD from environment via WASI
    const allocator = global_allocator orelse {
        return qjs.JS_NewString(ctx, "/");
    };

    // Get environ from WASI
    var environ_count: usize = 0;
    var environ_buf_size: usize = 0;
    _ = std.os.wasi.environ_sizes_get(&environ_count, &environ_buf_size);

    if (environ_count == 0) {
        return qjs.JS_NewString(ctx, "/");
    }

    const environ_ptrs = allocator.alloc([*:0]u8, environ_count) catch {
        return qjs.JS_NewString(ctx, "/");
    };
    defer allocator.free(environ_ptrs);

    const environ_buf = allocator.alloc(u8, environ_buf_size) catch {
        return qjs.JS_NewString(ctx, "/");
    };
    defer allocator.free(environ_buf);

    _ = std.os.wasi.environ_get(environ_ptrs.ptr, environ_buf.ptr);

    for (environ_ptrs) |env_ptr| {
        const env = std.mem.span(env_ptr);
        if (std.mem.startsWith(u8, env, "PWD=")) {
            const pwd = env[4..];
            return qjs.JS_NewStringLen(ctx, pwd.ptr, pwd.len);
        }
    }

    return qjs.JS_NewString(ctx, "/");
}

/// Get home directory
fn nativeHomedir(ctx: ?*qjs.JSContext, _: qjs.JSValue, _: c_int, _: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    const allocator = global_allocator orelse {
        return qjs.JS_NewString(ctx, "/home/user");
    };

    // Get environ from WASI
    var environ_count: usize = 0;
    var environ_buf_size: usize = 0;
    _ = std.os.wasi.environ_sizes_get(&environ_count, &environ_buf_size);

    if (environ_count == 0) {
        return qjs.JS_NewString(ctx, "/home/user");
    }

    const environ_ptrs = allocator.alloc([*:0]u8, environ_count) catch {
        return qjs.JS_NewString(ctx, "/home/user");
    };
    defer allocator.free(environ_ptrs);

    const environ_buf = allocator.alloc(u8, environ_buf_size) catch {
        return qjs.JS_NewString(ctx, "/home/user");
    };
    defer allocator.free(environ_buf);

    _ = std.os.wasi.environ_get(environ_ptrs.ptr, environ_buf.ptr);

    for (environ_ptrs) |env_ptr| {
        const env = std.mem.span(env_ptr);
        if (std.mem.startsWith(u8, env, "HOME=")) {
            const home = env[5..];
            return qjs.JS_NewStringLen(ctx, home.ptr, home.len);
        }
    }

    return qjs.JS_NewString(ctx, "/home/user");
}

// ============================================================================
// Crypto Native Functions
// ============================================================================

const crypto = std.crypto;

/// Native hash function: __edgebox_hash(algorithm, data) -> hex string
/// Supports: sha256, sha384, sha512, sha1, md5
fn nativeHash(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "hash requires algorithm and data arguments");

    const algorithm = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "algorithm must be a string");
    defer freeStringArg(ctx, algorithm);

    const data = getStringArg(ctx, argv[1]) orelse
        return qjs.JS_ThrowTypeError(ctx, "data must be a string");
    defer freeStringArg(ctx, data);

    // Hash based on algorithm
    if (std.mem.eql(u8, algorithm, "sha256")) {
        var hash: [32]u8 = undefined;
        crypto.hash.sha2.Sha256.hash(data, &hash, .{});
        return hexEncode(ctx, &hash);
    } else if (std.mem.eql(u8, algorithm, "sha384")) {
        var hash: [48]u8 = undefined;
        crypto.hash.sha2.Sha384.hash(data, &hash, .{});
        return hexEncode(ctx, &hash);
    } else if (std.mem.eql(u8, algorithm, "sha512")) {
        var hash: [64]u8 = undefined;
        crypto.hash.sha2.Sha512.hash(data, &hash, .{});
        return hexEncode(ctx, &hash);
    } else if (std.mem.eql(u8, algorithm, "sha1")) {
        var hash: [20]u8 = undefined;
        crypto.hash.Sha1.hash(data, &hash, .{});
        return hexEncode(ctx, &hash);
    } else if (std.mem.eql(u8, algorithm, "md5")) {
        var hash: [16]u8 = undefined;
        crypto.hash.Md5.hash(data, &hash, .{});
        return hexEncode(ctx, &hash);
    } else {
        return qjs.JS_ThrowTypeError(ctx, "unsupported algorithm: use sha256, sha384, sha512, sha1, or md5");
    }
}

/// Native HMAC function: __edgebox_hmac(algorithm, key, data) -> hex string
fn nativeHmac(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 3) return qjs.JS_ThrowTypeError(ctx, "hmac requires algorithm, key, and data arguments");

    const algorithm = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "algorithm must be a string");
    defer freeStringArg(ctx, algorithm);

    const key = getStringArg(ctx, argv[1]) orelse
        return qjs.JS_ThrowTypeError(ctx, "key must be a string");
    defer freeStringArg(ctx, key);

    const data = getStringArg(ctx, argv[2]) orelse
        return qjs.JS_ThrowTypeError(ctx, "data must be a string");
    defer freeStringArg(ctx, data);

    // HMAC based on algorithm
    if (std.mem.eql(u8, algorithm, "sha256")) {
        var out: [32]u8 = undefined;
        const key_ptr: *const [32]u8 = if (key.len >= 32) @ptrCast(key.ptr) else blk: {
            var padded: [32]u8 = undefined;
            @memset(&padded, 0);
            @memcpy(padded[0..key.len], key);
            break :blk &padded;
        };
        crypto.auth.hmac.sha2.HmacSha256.create(&out, data, key_ptr);
        return hexEncode(ctx, &out);
    } else if (std.mem.eql(u8, algorithm, "sha384")) {
        var out: [48]u8 = undefined;
        const key_ptr: *const [48]u8 = if (key.len >= 48) @ptrCast(key.ptr) else blk: {
            var padded: [48]u8 = undefined;
            @memset(&padded, 0);
            @memcpy(padded[0..key.len], key);
            break :blk &padded;
        };
        crypto.auth.hmac.sha2.HmacSha384.create(&out, data, key_ptr);
        return hexEncode(ctx, &out);
    } else if (std.mem.eql(u8, algorithm, "sha512")) {
        var out: [64]u8 = undefined;
        const key_ptr: *const [64]u8 = if (key.len >= 64) @ptrCast(key.ptr) else blk: {
            var padded: [64]u8 = undefined;
            @memset(&padded, 0);
            @memcpy(padded[0..key.len], key);
            break :blk &padded;
        };
        crypto.auth.hmac.sha2.HmacSha512.create(&out, data, key_ptr);
        return hexEncode(ctx, &out);
    } else {
        return qjs.JS_ThrowTypeError(ctx, "unsupported HMAC algorithm: use sha256, sha384, or sha512");
    }
}

/// Helper to convert bytes to hex string
fn hexEncode(ctx: ?*qjs.JSContext, bytes: []const u8) qjs.JSValue {
    const hex_chars = "0123456789abcdef";
    var hex_buf: [128]u8 = undefined; // Max 64 bytes * 2 = 128 hex chars
    const hex_len = bytes.len * 2;

    if (hex_len > hex_buf.len) {
        return qjs.JS_ThrowInternalError(ctx, "hash too long");
    }

    for (bytes, 0..) |byte, i| {
        hex_buf[i * 2] = hex_chars[byte >> 4];
        hex_buf[i * 2 + 1] = hex_chars[byte & 0x0f];
    }

    return qjs.JS_NewStringLen(ctx, &hex_buf, hex_len);
}
