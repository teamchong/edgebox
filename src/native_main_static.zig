/// Native Static Entry Point
/// Executes pre-compiled bytecode with freeze optimizations
/// For pure native binaries (no WAMR)
///
/// Build pipeline:
///   1. edgebox-compile compiles JS â†’ bundle_compiled.c
///   2. edgebox-compile generates frozen_functions.c
///   3. zig build native-static compiles everything to native binary
///
const std = @import("std");
const builtin = @import("builtin");

// QuickJS C API
const qjs = @cImport({
    @cDefine("CONFIG_VERSION", "\"2024-02-14\"");
    @cDefine("CONFIG_BIGNUM", "1");
    @cInclude("quickjs.h");
    @cInclude("quickjs-libc.h");
});

// Native polyfills (for console, process, etc.)
const path_polyfill = @import("polyfills/path.zig");
const process_polyfill = @import("polyfills/process.zig");
const console_polyfill = @import("polyfills/console.zig");
const buffer_polyfill = @import("polyfills/buffer.zig");
const util_polyfill = @import("polyfills/util.zig");
const encoding_polyfill = @import("polyfills/encoding.zig");

// Native bindings for fs, crypto, etc.
const native_bindings = @import("native_bindings.zig");

// Import qjsc_entry from bundle_compiled.c (generated by qjsc, patched by compiler)
extern fn qjsc_entry(argc: c_int, argv: [*c][*c]u8) c_int;

// Global allocator for native operations
var gpa = std.heap.GeneralPurposeAllocator(.{}){};

pub fn main() !void {
    const allocator = gpa.allocator();

    // Initialize native bindings
    native_bindings.init(allocator);

    // Get command line args
    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    // Convert to C args format
    var c_args = try allocator.alloc([*c]u8, args.len);
    defer allocator.free(c_args);

    for (args, 0..) |arg, i| {
        const c_arg = try allocator.allocSentinel(u8, arg.len, 0);
        @memcpy(c_arg, arg);
        c_args[i] = c_arg.ptr;
    }
    defer {
        for (c_args) |c_arg| {
            const len = std.mem.len(c_arg);
            allocator.free(c_arg[0 .. len + 1]);
        }
    }

    // Call qjsc_entry which:
    // 1. Creates QuickJS runtime/context
    // 2. Calls frozen_init_c() to register frozen functions
    // 3. Executes the bytecode
    const result = qjsc_entry(@intCast(args.len), c_args.ptr);

    if (result != 0) {
        std.debug.print("Execution failed with code: {}\n", .{result});
        std.process.exit(@intCast(result));
    }
}
