--- a/quickjs.c
+++ b/quickjs.c
@@ -20547,7 +20547,7 @@ static int js_parse_template_part(JSParseState *s, const uint8_t *p)
             s->eol = &p[-1];
             s->mark = p;
         } else if (c >= 0x80) {
-            c = utf8_decode(p - 1, &p_next);
+            c = utf8_decode_len(p - 1, s->buf_end - (p - 1), &p_next);
             if (p_next == p) {
                 js_parse_error(s, "invalid UTF-8 sequence");
                 goto fail;
@@ -20656,7 +20656,7 @@ static int js_parse_string(JSParseState *s, int sep,
                     }
                     goto fail;
                 } else if (c >= 0x80) {
-                    c = utf8_decode(p, &p_next);
+                    c = utf8_decode_len(p, s->buf_end - p, &p_next);
                     if (p_next == p + 1) {
                         goto invalid_utf8;
                     }
@@ -20682,7 +20682,7 @@ static int js_parse_string(JSParseState *s, int sep,
                 break;
             }
         } else if (c >= 0x80) {
-            c = utf8_decode(p - 1, &p_next);
+            c = utf8_decode_len(p - 1, s->buf_end - (p - 1), &p_next);
             if (p_next == p)
                 goto invalid_utf8;
             p = p_next;
@@ -20758,7 +20758,7 @@ static int js_parse_regexp(JSParseState *s)
             else if (c == '\0' && p >= s->buf_end)
                 goto eof_error;
             else if (c >= 0x80) {
-                c = utf8_decode(p - 1, &p_next);
+                c = utf8_decode_len(p - 1, s->buf_end - (p - 1), &p_next);
                 if (p_next == p) {
                     goto invalid_utf8;
                 }
@@ -20767,7 +20767,7 @@ static int js_parse_regexp(JSParseState *s)
                     goto eol_error;
             }
         } else if (c >= 0x80) {
-            c = utf8_decode(p - 1, &p_next);
+            c = utf8_decode_len(p - 1, s->buf_end - (p - 1), &p_next);
             if (p_next == p) {
             invalid_utf8:
                 js_parse_error(s, "invalid UTF-8 sequence");
@@ -20787,7 +20787,7 @@ static int js_parse_regexp(JSParseState *s)
 
     /* flags */
     for(;;) {
-        c = utf8_decode(p, &p_next);
+        c = utf8_decode_len(p, s->buf_end - p, &p_next);
         /* no need to test for invalid UTF-8, 0xFFFD is not ident_next */
         if (!lre_js_is_ident_next(c))
             break;
@@ -20915,7 +20915,7 @@ static int js_parse_ident(JSParseState *s, const uint8_t **pp,
             c = lre_parse_escape(&p_next, true);
             *pident_has_escape = true;
         } else if (c >= 0x80) {
-            c = utf8_decode(p, &p_next);
+            c = utf8_decode_len(p, s->buf_end - p, &p_next);
             /* no need to test for invalid UTF-8, 0xFFFD is not ident_next */
         }
         if (!lre_js_is_ident_next(c))
@@ -21018,7 +21018,7 @@ static __exception int next_token(JSParseState *s)
                     s->got_lf = true; /* considered as LF for ASI */
                     p++;
                 } else if (*p >= 0x80) {
-                    c = utf8_decode(p, &p);
+                    c = utf8_decode_len(p, s->buf_end - p, &p);
                     /* ignore invalid UTF-8 in comments */
                     if (c == CP_LS || c == CP_PS) {
                         s->got_lf = true; /* considered as LF for ASI */
@@ -21039,7 +21039,7 @@ static __exception int next_token(JSParseState *s)
                 if (*p == '\r' || *p == '\n')
                     break;
                 if (*p >= 0x80) {
-                    c = utf8_decode(p, &p);
+                    c = utf8_decode_len(p, s->buf_end - p, &p);
                     /* ignore invalid UTF-8 in comments */
                     /* LS or PS are considered as line terminator */
                     if (c == CP_LS || c == CP_PS) {
@@ -21112,7 +21112,7 @@ static __exception int next_token(JSParseState *s)
             if (c == '\\' && *p_next == 'u') {
                 c = lre_parse_escape(&p_next, true);
             } else if (c >= 0x80) {
-                c = utf8_decode(p, &p_next);
+                c = utf8_decode_len(p, s->buf_end - p, &p_next);
                 if (p_next == p + 1)
                     goto invalid_utf8;
             }
@@ -21165,7 +21165,7 @@ static __exception int next_token(JSParseState *s)
                 goto fail;
             /* reject `10instanceof Number` */
             if (JS_VALUE_IS_NAN(ret) ||
-                lre_js_is_ident_next(utf8_decode(p, &p1))) {
+                lre_js_is_ident_next(utf8_decode_len(p, s->buf_end - p, &p1))) {
                 JS_FreeValue(s->ctx, ret);
                 js_parse_error(s, "invalid number literal");
                 goto fail;
@@ -21358,7 +21358,7 @@ static __exception int next_token(JSParseState *s)
         break;
     default:
         if (c >= 0x80) {  /* non-ASCII code-point */
-            c = utf8_decode(p, &p_next);
+            c = utf8_decode_len(p, s->buf_end - p, &p_next);
             if (p_next == p + 1)
                 goto invalid_utf8;
             p = p_next;
@@ -21470,7 +21470,7 @@ static __exception int next_token(JSParseState *s)
             }
         } else
         if (c >= 0x80) {
-            c = utf8_decode(p - 1, &p_next);
+            c = utf8_decode_len(p - 1, s->buf_end - (p - 1), &p_next);
             if (p_next == p) {
                 json_parse_error(s, p - 1, "Bad UTF-8 sequence");
                 goto fail;
@@ -21674,7 +21674,7 @@ static __exception int json_next_token(JSParseState *s)
         break;
     default:
         if (c >= 0x80) {
-            c = utf8_decode(p, &p_next);
+            c = utf8_decode_len(p, s->buf_end - p, &p_next);
             if (p_next == p + 1) {
                 js_parse_error(s, "Unexpected token '\\x%02x' in JSON", *p);
             } else {
@@ -21802,7 +21802,7 @@ static void skip_shebang(const uint8_t **pp, const uint8_t *buf_end)
             if (*p == '\n' || *p == '\r') {
                 break;
             } else if (*p >= 0x80) {
-                c = utf8_decode(p, &p);
+                c = utf8_decode_len(p, buf_end - p, &p);
                 /* purposely ignore UTF-8 encoding errors in this comment line */
                 if (c == CP_LS || c == CP_PS)
                     break;
