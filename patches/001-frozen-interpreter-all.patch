diff --git a/quickjs-libc.c b/quickjs-libc.c
index ae01300..587c949 100644
--- a/quickjs-libc.c
+++ b/quickjs-libc.c
@@ -58,7 +58,9 @@
 #else
 #include <sys/ioctl.h>
 #include <poll.h>
-#if !defined(__wasi__)
+#if defined(__wasi__)
+#include <wasi/api.h>
+#else
 #include <dlfcn.h>
 #include <termios.h>
 #include <sys/resource.h>
@@ -825,7 +827,12 @@ static JSValue js_std_exit(JSContext *ctx, JSValueConst this_val,
     int status;
     if (JS_ToInt32(ctx, &status, argv[0]))
         status = -1;
+#if defined(__wasi__)
+    /* Use WASI proc_exit which can be trapped by the WASM runtime */
+    __wasi_proc_exit(status);
+#else
     exit(status);
+#endif
     return JS_UNDEFINED;
 }
 
@@ -4507,11 +4514,14 @@ static void js_std_promise_rejection_check(JSContext *ctx)
     if (unlikely(!list_empty(&ts->rejected_promise_list))) {
         list_for_each(el, &ts->rejected_promise_list) {
             JSRejectedPromiseEntry *rp = list_entry(el, JSRejectedPromiseEntry, link);
+#ifndef __wasi__
+            /* Only print rejection warnings on non-WASI platforms */
             fprintf(stderr, "Possibly unhandled promise rejection: ");
             js_std_dump_error1(ctx, rp->reason);
             fflush(stderr);
+#endif
         }
-        exit(1);
+        /* Don't exit - allow the event loop to continue or exit naturally */
     }
 }
 
diff --git a/quickjs.c b/quickjs.c
index 62f4381..fac7094 100644
--- a/quickjs.c
+++ b/quickjs.c
@@ -1291,7 +1291,20 @@ static void js_free_module_def(JSContext *ctx, JSModuleDef *m);
 static void js_mark_module_def(JSRuntime *rt, JSModuleDef *m,
                                JS_MarkFunc *mark_func);
 static JSValue js_import_meta(JSContext *ctx);
-static JSValue js_dynamic_import(JSContext *ctx, JSValueConst specifier);
+JSValue js_dynamic_import(JSContext *ctx, JSValueConst specifier);
+
+/* External frozen function dispatch - implemented in Zig native_dispatch.zig */
+extern int frozen_dispatch_lookup(JSContext *ctx, const char *func_name,
+                                  JSValue this_val, int argc, JSValue *argv,
+                                  JSVarRef **var_refs, JSValue *cpool,
+                                  JSValue *result_out);
+
+/* Bytecode-based frozen function dispatch - for closure/fclosure support */
+extern int frozen_dispatch_lookup_bytecode(JSContext *ctx, void *bytecode_ptr,
+                                           JSValue this_val, int argc, JSValue *argv,
+                                           JSVarRef **var_refs, JSValue *cpool,
+                                           JSValue *result_out);
+
 static void free_var_ref(JSRuntime *rt, JSVarRef *var_ref);
 static JSValue js_new_promise_capability(JSContext *ctx,
                                          JSValue *resolving_funcs,
@@ -5316,6 +5329,13 @@ static JSFunctionBytecode *JS_GetFunctionBytecode(JSValueConst val)
     return p->u.func.function_bytecode;
 }
 
+/* External wrapper for frozen function bytecode registration */
+/* Returns bytecode pointer as void* for use in native dispatch */
+void *js_get_function_bytecode_ptr(JSValueConst val)
+{
+    return (void *)JS_GetFunctionBytecode(val);
+}
+
 static void js_method_set_home_object(JSContext *ctx, JSValue func_obj,
                                       JSValue home_obj)
 {
@@ -10148,7 +10168,7 @@ static bool js_object_has_name(JSContext *ctx, JSValue obj)
     return (p->len != 0);
 }
 
-static int JS_DefineObjectName(JSContext *ctx, JSValue obj,
+int JS_DefineObjectName(JSContext *ctx, JSValue obj,
                                JSAtom name, int flags)
 {
     if (name != JS_ATOM_NULL
@@ -10160,7 +10180,7 @@ static int JS_DefineObjectName(JSContext *ctx, JSValue obj,
     return 0;
 }
 
-static int JS_DefineObjectNameComputed(JSContext *ctx, JSValue obj,
+int JS_DefineObjectNameComputed(JSContext *ctx, JSValue obj,
                                        JSValue str, int flags)
 {
     if (JS_IsObject(obj) &&
@@ -15134,6 +15154,12 @@ static JSValue js_build_arguments(JSContext *ctx, int argc, JSValueConst *argv)
     return val;
 }
 
+/* Public wrapper for frozen code to create proper arguments object */
+JSValue JS_NewArguments(JSContext *ctx, int argc, JSValueConst *argv)
+{
+    return js_build_arguments(ctx, argc, argv);
+}
+
 #define GLOBAL_VAR_OFFSET 0x40000000
 #define ARGUMENT_VAR_OFFSET 0x20000000
 
@@ -15598,6 +15624,382 @@ static __exception int js_for_of_next(JSContext *ctx, JSValue *sp, int offset)
     return 0;
 }
 
+/* ========================================================================
+ * Wrapper functions for frozen interpreter
+ * ======================================================================== */
+
+/* Iterator helpers */
+int js_frozen_for_in_start(JSContext *ctx, JSValue *sp)
+{
+    return js_for_in_start(ctx, sp);
+}
+
+int js_frozen_for_in_next(JSContext *ctx, JSValue *sp)
+{
+    return js_for_in_next(ctx, sp);
+}
+
+int js_frozen_for_of_start(JSContext *ctx, JSValue *sp, int is_async)
+{
+    return js_for_of_start(ctx, sp, is_async != 0);
+}
+
+int js_frozen_for_of_next(JSContext *ctx, JSValue *sp, int offset)
+{
+    return js_for_of_next(ctx, sp, offset);
+}
+
+/* Closure variable access wrappers */
+JSValue js_frozen_get_var_ref(JSContext *ctx, JSVarRef **var_refs, int idx)
+{
+    (void)ctx;
+    if (!var_refs || !var_refs[idx]) return JS_UNDEFINED;
+    return js_dup(*var_refs[idx]->pvalue);
+}
+
+void js_frozen_set_var_ref(JSContext *ctx, JSVarRef **var_refs, int idx, JSValue val)
+{
+    if (var_refs && var_refs[idx]) {
+        set_value(ctx, var_refs[idx]->pvalue, val);
+    }
+}
+
+/* Iterator support for frozen functions */
+JSValue js_frozen_get_iterator(JSContext *ctx, JSValue obj, int is_async)
+{
+    return JS_GetIterator(ctx, obj, is_async != 0);
+}
+
+JSValue js_frozen_iterator_next(JSContext *ctx, JSValue iter, int *done)
+{
+    JSValue method = JS_GetProperty(ctx, iter, JS_ATOM_next);
+    if (JS_IsException(method)) {
+        *done = 1;
+        return JS_EXCEPTION;
+    }
+    JSValue result = JS_Call(ctx, method, iter, 0, NULL);
+    JS_FreeValue(ctx, method);
+    if (JS_IsException(result)) {
+        *done = 1;
+        return JS_EXCEPTION;
+    }
+    // Get done and value from result
+    JSValue done_val = JS_GetProperty(ctx, result, JS_ATOM_done);
+    *done = JS_ToBool(ctx, done_val);
+    JS_FreeValue(ctx, done_val);
+    JSValue value = JS_GetProperty(ctx, result, JS_ATOM_value);
+    JS_FreeValue(ctx, result);
+    return value;
+}
+
+int js_frozen_iterator_close(JSContext *ctx, JSValue iter, int completion_type)
+{
+    (void)completion_type;
+    JSValue ret_method = JS_GetProperty(ctx, iter, JS_ATOM_return);
+    if (!JS_IsUndefined(ret_method) && !JS_IsNull(ret_method)) {
+        JSValue ret = JS_Call(ctx, ret_method, iter, 0, NULL);
+        JS_FreeValue(ctx, ret_method);
+        if (JS_IsException(ret)) {
+            return -1;
+        }
+        JS_FreeValue(ctx, ret);
+    } else {
+        JS_FreeValue(ctx, ret_method);
+    }
+    return 0;
+}
+
+JSValue js_frozen_iterator_get_value_done(JSContext *ctx, JSValue result, int *done)
+{
+    JSValue done_val = JS_GetProperty(ctx, result, JS_ATOM_done);
+    *done = JS_ToBool(ctx, done_val);
+    JS_FreeValue(ctx, done_val);
+    JSValue value = JS_GetProperty(ctx, result, JS_ATOM_value);
+    return value;
+}
+
+int js_frozen_set_field(JSContext *ctx, JSValue obj, const char *prop, JSValue val)
+{
+    return JS_SetPropertyStr(ctx, obj, prop, val);
+}
+
+JSValue js_frozen_to_object(JSContext *ctx, JSValue val)
+{
+    return JS_ToObject(ctx, val);
+}
+
+JSValue js_frozen_get_length(JSContext *ctx, JSValue obj)
+{
+    int64_t len;
+    if (JS_GetLength(ctx, obj, &len) < 0)
+        return JS_EXCEPTION;
+    return JS_NewInt64(ctx, len);
+}
+
+JSValue js_frozen_to_prop_key(JSContext *ctx, JSValue val)
+{
+    JSAtom atom = JS_ValueToAtom(ctx, val);
+    if (atom == JS_ATOM_NULL)
+        return JS_EXCEPTION;
+    JSValue ret = JS_AtomToValue(ctx, atom);
+    JS_FreeAtom(ctx, atom);
+    return ret;
+}
+
+/* Create a closure from frozen code
+ * Called from frozen functions to implement OP_fclosure/OP_fclosure8
+ *
+ * Parameters:
+ * - ctx: JavaScript context
+ * - bfunc: The bytecode function from cpool (JSValue containing JSFunctionBytecode)
+ * - cur_var_refs: Parent's var_refs (for closures inherited from parent scope)
+ * - locals: Array of local variables from frozen function
+ * - num_locals: Number of locals in the frozen function's locals array
+ * - args: Array of argument values from frozen function
+ * - num_args: Number of arguments
+ *
+ * Note: Unlike normal js_closure, this creates "detached" var_refs immediately
+ * because the frozen function's locals/args arrays are stack-allocated and will
+ * be invalid after the frozen function returns.
+ */
+JSValue js_frozen_create_closure(JSContext *ctx, JSValue bfunc,
+                                 JSVarRef **cur_var_refs,
+                                 JSValue *locals, int num_locals,
+                                 JSValue *args, int num_args)
+{
+    JSFunctionBytecode *b;
+    JSValue func_obj;
+    JSAtom name_atom;
+    JSObject *p;
+    JSVarRef **var_refs;
+    int i;
+
+    b = JS_VALUE_GET_PTR(bfunc);
+    /* Use JS_CLASS_BYTECODE_FUNCTION for normal functions
+     * (frozen code doesn't support generators/async yet) */
+    func_obj = JS_NewObjectClass(ctx, JS_CLASS_BYTECODE_FUNCTION);
+    if (JS_IsException(func_obj)) {
+        JS_FreeValue(ctx, bfunc);
+        return JS_EXCEPTION;
+    }
+
+    p = JS_VALUE_GET_OBJ(func_obj);
+    p->u.func.function_bytecode = b;
+    p->u.func.home_object = NULL;
+    p->u.func.var_refs = NULL;
+
+    if (b->closure_var_count) {
+        var_refs = js_mallocz(ctx, sizeof(var_refs[0]) * b->closure_var_count);
+        if (!var_refs)
+            goto fail;
+        p->u.func.var_refs = var_refs;
+
+        for(i = 0; i < b->closure_var_count; i++) {
+            JSClosureVar *cv = &b->closure_var[i];
+            JSVarRef *var_ref;
+
+            if (cv->is_local) {
+                /* Local capture from frozen function - create detached var_ref */
+                var_ref = js_malloc(ctx, sizeof(JSVarRef));
+                if (!var_ref)
+                    goto fail;
+                var_ref->header.ref_count = 1;
+                var_ref->is_detached = true;  /* Already detached */
+                /* Initialize list head - not part of any list but prevents garbage */
+                init_list_head(&var_ref->header.link);
+
+                /* Get value from locals or args array */
+                JSValue val;
+                if (cv->is_arg) {
+                    if (cv->var_idx < num_args)
+                        val = args[cv->var_idx];
+                    else
+                        val = JS_UNDEFINED;
+                } else {
+                    if (cv->var_idx < num_locals)
+                        val = locals[cv->var_idx];
+                    else
+                        val = JS_UNDEFINED;
+                }
+                /* Copy value into var_ref's own storage (detached mode) */
+                var_ref->value = js_dup(val);
+                var_ref->pvalue = &var_ref->value;
+            } else {
+                /* Parent closure reference */
+                if (cur_var_refs && cur_var_refs[cv->var_idx]) {
+                    var_ref = cur_var_refs[cv->var_idx];
+                    var_ref->header.ref_count++;
+                } else {
+                    /* No parent var_ref available - create undefined */
+                    var_ref = js_malloc(ctx, sizeof(JSVarRef));
+                    if (!var_ref)
+                        goto fail;
+                    var_ref->header.ref_count = 1;
+                    var_ref->is_detached = true;
+                    init_list_head(&var_ref->header.link);
+                    var_ref->value = JS_UNDEFINED;
+                    var_ref->pvalue = &var_ref->value;
+                }
+            }
+            var_refs[i] = var_ref;
+        }
+    }
+
+    name_atom = b->func_name;
+    if (name_atom == JS_ATOM_NULL)
+        name_atom = JS_ATOM_empty_string;
+    js_function_set_properties(ctx, func_obj, name_atom, b->defined_arg_count);
+
+    if (b->has_prototype) {
+        JS_SetConstructorBit(ctx, func_obj, true);
+        JS_DefineAutoInitProperty(ctx, func_obj, JS_ATOM_prototype,
+                                  JS_AUTOINIT_ID_PROTOTYPE, NULL,
+                                  JS_PROP_WRITABLE);
+    }
+    return func_obj;
+fail:
+    JS_FreeValue(ctx, func_obj);
+    return JS_EXCEPTION;
+}
+
+int js_frozen_copy_data_properties(JSContext *ctx, JSValue dst, JSValue src, int exclude_flags)
+{
+    (void)exclude_flags; // TODO: implement exclusion
+    if (JS_IsNull(src) || JS_IsUndefined(src))
+        return 0;
+
+    JSPropertyEnum *props;
+    uint32_t len;
+    if (JS_GetOwnPropertyNames(ctx, &props, &len, src, JS_GPN_STRING_MASK | JS_GPN_ENUM_ONLY) < 0)
+        return -1;
+
+    for (uint32_t i = 0; i < len; i++) {
+        JSValue val = JS_GetProperty(ctx, src, props[i].atom);
+        if (JS_IsException(val)) {
+            JS_FreePropertyEnum(ctx, props, len);
+            return -1;
+        }
+        if (JS_SetProperty(ctx, dst, props[i].atom, val) < 0) {
+            JS_FreePropertyEnum(ctx, props, len);
+            return -1;
+        }
+    }
+    JS_FreePropertyEnum(ctx, props, len);
+    return 0;
+}
+
+/* Home object registry for frozen C functions */
+#define FROZEN_HOME_OBJECT_REGISTRY_SIZE 256
+static struct {
+    void *func_ptr;
+    JSValue home_object;
+} frozen_home_object_registry[FROZEN_HOME_OBJECT_REGISTRY_SIZE];
+static int frozen_home_object_count = 0;
+
+void JS_SetFrozenHomeObject(JSContext *ctx, void *func_ptr, JSValue home_object)
+{
+    (void)ctx;
+    for (int i = 0; i < frozen_home_object_count; i++) {
+        if (frozen_home_object_registry[i].func_ptr == func_ptr) {
+            frozen_home_object_registry[i].home_object = home_object;
+            return;
+        }
+    }
+    if (frozen_home_object_count < FROZEN_HOME_OBJECT_REGISTRY_SIZE) {
+        frozen_home_object_registry[frozen_home_object_count].func_ptr = func_ptr;
+        frozen_home_object_registry[frozen_home_object_count].home_object = home_object;
+        frozen_home_object_count++;
+    }
+}
+
+JSValue JS_GetFrozenHomeObject(JSContext *ctx, void *func_ptr)
+{
+    (void)ctx;
+    for (int i = 0; i < frozen_home_object_count; i++) {
+        if (frozen_home_object_registry[i].func_ptr == func_ptr) {
+            return frozen_home_object_registry[i].home_object;
+        }
+    }
+    return JS_UNDEFINED;
+}
+
+/* import.meta wrapper */
+JSValue JS_GetImportMetaCurrent(JSContext *ctx)
+{
+    return js_import_meta(ctx);
+}
+
+/* Mapped arguments (simplified version for frozen code) */
+JSValue JS_NewMappedArgumentsSimple(JSContext *ctx, int argc, JSValueConst *argv,
+                                    JSValue callee)
+{
+    JSValue args = js_build_arguments(ctx, argc, argv);
+    if (!JS_IsException(args)) {
+        JS_DefinePropertyValue(ctx, args, JS_ATOM_callee, js_dup(callee),
+                               JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE);
+    }
+    return args;
+}
+
+/* Private field wrappers */
+JSValue JS_NewPrivateSymbol(JSContext *ctx, JSAtom atom)
+{
+    return JS_NewSymbolFromAtom(ctx, atom, JS_ATOM_TYPE_PRIVATE);
+}
+
+int JS_FrozenCheckBrand(JSContext *ctx, JSValue obj, JSValue func)
+{
+    return JS_CheckBrand(ctx, obj, func);
+}
+
+int JS_FrozenAddBrand(JSContext *ctx, JSValue obj, JSValue func)
+{
+    return JS_AddBrand(ctx, obj, func);
+}
+
+int js_frozen_private_in(JSContext *ctx, JSValue *sp)
+{
+    return js_operator_private_in(ctx, sp);
+}
+
+/* Private field access wrappers for frozen interpreter */
+JSValue JS_FrozenGetPrivateField(JSContext *ctx, JSValueConst obj, JSValueConst name)
+{
+    return JS_GetPrivateField(ctx, obj, name);
+}
+
+int JS_FrozenSetPrivateField(JSContext *ctx, JSValueConst obj, JSValueConst name, JSValue val)
+{
+    return JS_SetPrivateField(ctx, obj, name, val);
+}
+
+int JS_FrozenDefinePrivateField(JSContext *ctx, JSValueConst obj, JSValue name, JSValue val)
+{
+    return JS_DefinePrivateField(ctx, obj, name, val);
+}
+
+/* Get constant pool from a bytecode function - for frozen interpreter */
+JSValue* JS_GetFunctionConstantPool(JSContext *ctx, JSValueConst func_obj, int *pcount)
+{
+    JSObject *p;
+    JSFunctionBytecode *b;
+
+    if (JS_VALUE_GET_TAG(func_obj) != JS_TAG_OBJECT)
+        return NULL;
+
+    p = JS_VALUE_GET_OBJ(func_obj);
+    if (!js_class_has_bytecode(p->class_id))
+        return NULL;
+
+    b = p->u.func.function_bytecode;
+    if (!b || !b->cpool)
+        return NULL;
+
+    if (pcount)
+        *pcount = b->cpool_count;
+    return b->cpool;
+}
+
 static JSValue JS_IteratorGetCompleteValue(JSContext *ctx, JSValue obj,
                                            int *pdone)
 {
@@ -15955,9 +16357,9 @@ static const uint16_t func_kind_to_class_id[] = {
     [JS_FUNC_ASYNC_GENERATOR] = JS_CLASS_ASYNC_GENERATOR_FUNCTION,
 };
 
-static JSValue js_closure(JSContext *ctx, JSValue bfunc,
-                          JSVarRef **cur_var_refs,
-                          JSStackFrame *sf)
+JSValue js_closure(JSContext *ctx, JSValue bfunc,
+                   JSVarRef **cur_var_refs,
+                   JSStackFrame *sf)
 {
     JSFunctionBytecode *b;
     JSValue func_obj;
@@ -16422,6 +16824,42 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
     }
     b = p->u.func.function_bytecode;
 
+    /* Check for frozen function dispatch by bytecode pointer (closure-aware) */
+    /* This is the primary dispatch path - uses bytecode address as key */
+    /* var_refs is extracted from the function object for proper closure access */
+    /* cpool is passed for fclosure support (creating nested closures) */
+    {
+        JSValue frozen_result;
+        if (frozen_dispatch_lookup_bytecode(caller_ctx, (void *)b,
+                                            this_obj, argc, (JSValue *)argv,
+                                            p->u.func.var_refs, b->cpool,
+                                            &frozen_result)) {
+            return frozen_result;
+        }
+    }
+
+    /* Fallback: Check for frozen function dispatch by name@line_num */
+    /* This is kept for compatibility with functions registered by name */
+    if (b->func_name != JS_ATOM_NULL && b->line_num > 0) {
+        char func_name_buf[64];
+        char dispatch_key_buf[128];
+        const char *func_name = JS_AtomGetStr(caller_ctx, func_name_buf,
+                                               sizeof(func_name_buf), b->func_name);
+        if (func_name && func_name[0]) {
+            /* Format: "name@line_num" - unique per function definition */
+            snprintf(dispatch_key_buf, sizeof(dispatch_key_buf), "%s@%d",
+                     func_name, b->line_num);
+            JSValue frozen_result;
+            /* Pass var_refs and cpool from function object for closure/fclosure support */
+            if (frozen_dispatch_lookup(caller_ctx, dispatch_key_buf,
+                                       this_obj, argc, (JSValue *)argv,
+                                       p->u.func.var_refs, b->cpool,
+                                       &frozen_result)) {
+                return frozen_result;
+            }
+        }
+    }
+
     if (unlikely(argc < b->arg_count || (flags & JS_CALL_FLAG_COPY_ARGV))) {
         arg_allocated_size = b->arg_count;
     } else {
@@ -29006,7 +29444,7 @@ JSValue JS_LoadModule(JSContext *ctx, const char *basename,
     return promise;
 }
 
-static JSValue js_dynamic_import_job(JSContext *ctx,
+JSValue js_dynamic_import_job(JSContext *ctx,
                                      int argc, JSValueConst *argv)
 {
     JSValueConst *resolving_funcs = argv;
@@ -29041,7 +29479,7 @@ static JSValue js_dynamic_import_job(JSContext *ctx,
     return JS_UNDEFINED;
 }
 
-static JSValue js_dynamic_import(JSContext *ctx, JSValueConst specifier)
+JSValue js_dynamic_import(JSContext *ctx, JSValueConst specifier)
 {
     JSAtom basename;
     JSValue promise, resolving_funcs[2], basename_val;
diff --git a/quickjs.h b/quickjs.h
index 3165256..7eec8af 100644
--- a/quickjs.h
+++ b/quickjs.h
@@ -851,6 +851,7 @@ JS_EXTERN bool JS_IsWeakMap(JSValueConst val);
 JS_EXTERN bool JS_IsDataView(JSValueConst val);
 
 JS_EXTERN JSValue JS_NewArray(JSContext *ctx);
+JS_EXTERN JSValue JS_NewArguments(JSContext *ctx, int argc, JSValueConst *argv);
 // takes ownership of the values
 JS_EXTERN JSValue JS_NewArrayFrom(JSContext *ctx, int count,
                                   const JSValue *values);
@@ -1124,6 +1125,9 @@ JS_EXTERN JSAtom JS_GetScriptOrModuleName(JSContext *ctx, int n_stack_levels);
 /* only exported for os.Worker() */
 JS_EXTERN JSValue JS_LoadModule(JSContext *ctx, const char *basename,
                                 const char *filename);
+/* exported for frozen interpreter dynamic import support */
+JS_EXTERN JSValue js_dynamic_import(JSContext *ctx, JSValueConst specifier);
+JS_EXTERN JSValue js_dynamic_import_job(JSContext *ctx, int argc, JSValueConst *argv);
 
 /* C function definition */
 typedef enum JSCFunctionEnum {  /* XXX: should rename for namespace isolation */
@@ -1291,6 +1295,65 @@ JS_EXTERN const char* JS_GetVersion(void);
 /* Integration point for quickjs-libc.c, not for public use. */
 JS_EXTERN uintptr_t js_std_cmd(int cmd, ...);
 
+/* Frozen interpreter support - iterator helpers */
+JS_EXTERN int js_frozen_for_in_start(JSContext *ctx, JSValue *sp);
+JS_EXTERN int js_frozen_for_in_next(JSContext *ctx, JSValue *sp);
+JS_EXTERN int js_frozen_for_of_start(JSContext *ctx, JSValue *sp, int is_async);
+JS_EXTERN int js_frozen_for_of_next(JSContext *ctx, JSValue *sp, int offset);
+
+/* Frozen interpreter support - closure variable access */
+typedef struct JSVarRef JSVarRef;
+JS_EXTERN JSValue js_frozen_get_var_ref(JSContext *ctx, JSVarRef **var_refs, int idx);
+JS_EXTERN void js_frozen_set_var_ref(JSContext *ctx, JSVarRef **var_refs, int idx, JSValue val);
+
+/* Frozen interpreter support - iterator methods */
+JS_EXTERN JSValue js_frozen_get_iterator(JSContext *ctx, JSValue obj, int is_async);
+JS_EXTERN JSValue js_frozen_iterator_next(JSContext *ctx, JSValue iter, int *done);
+JS_EXTERN int js_frozen_iterator_close(JSContext *ctx, JSValue iter, int completion_type);
+JS_EXTERN JSValue js_frozen_iterator_get_value_done(JSContext *ctx, JSValue result, int *done);
+
+/* Frozen interpreter support - object operations */
+JS_EXTERN int js_frozen_set_field(JSContext *ctx, JSValue obj, const char *prop, JSValue val);
+JS_EXTERN JSValue js_frozen_to_object(JSContext *ctx, JSValue val);
+JS_EXTERN JSValue js_frozen_get_length(JSContext *ctx, JSValue obj);
+JS_EXTERN JSValue js_frozen_to_prop_key(JSContext *ctx, JSValue val);
+JS_EXTERN int js_frozen_copy_data_properties(JSContext *ctx, JSValue dst, JSValue src, int exclude_flags);
+
+/* Frozen interpreter support - special object types */
+JS_EXTERN void JS_SetFrozenHomeObject(JSContext *ctx, void *func_ptr, JSValue home_object);
+JS_EXTERN JSValue JS_GetFrozenHomeObject(JSContext *ctx, void *func_ptr);
+JS_EXTERN JSValue JS_GetImportMetaCurrent(JSContext *ctx);
+JS_EXTERN JSValue JS_NewMappedArgumentsSimple(JSContext *ctx, int argc, JSValueConst *argv,
+                                              JSValue callee);
+
+/* Frozen interpreter support - private fields */
+JS_EXTERN JSValue JS_NewPrivateSymbol(JSContext *ctx, JSAtom atom);
+JS_EXTERN int JS_FrozenCheckBrand(JSContext *ctx, JSValue obj, JSValue func);
+JS_EXTERN int JS_FrozenAddBrand(JSContext *ctx, JSValue obj, JSValue func);
+JS_EXTERN int js_frozen_private_in(JSContext *ctx, JSValue *sp);
+JS_EXTERN JSValue JS_FrozenGetPrivateField(JSContext *ctx, JSValueConst obj, JSValueConst name);
+JS_EXTERN int JS_FrozenSetPrivateField(JSContext *ctx, JSValueConst obj, JSValueConst name, JSValue val);
+JS_EXTERN int JS_FrozenDefinePrivateField(JSContext *ctx, JSValueConst obj, JSValue name, JSValue val);
+
+/* Frozen interpreter support - constant pool access */
+JS_EXTERN JSValue* JS_GetFunctionConstantPool(JSContext *ctx, JSValueConst func_obj, int *pcount);
+
+/* Frozen interpreter support - bytecode pointer for dispatch registration */
+JS_EXTERN void *js_get_function_bytecode_ptr(JSValueConst val);
+
+/* Frozen interpreter support - closure creation */
+typedef struct JSStackFrame JSStackFrame;
+JS_EXTERN JSValue js_closure(JSContext *ctx, JSValue bfunc, JSVarRef **cur_var_refs, JSStackFrame *sf);
+/* Create closure from frozen code (no stack frame, uses locals/args arrays directly) */
+JS_EXTERN JSValue js_frozen_create_closure(JSContext *ctx, JSValue bfunc,
+                                           JSVarRef **cur_var_refs,
+                                           JSValue *locals, int num_locals,
+                                           JSValue *args, int num_args);
+
+/* Frozen interpreter support - function name setting */
+JS_EXTERN int JS_DefineObjectName(JSContext *ctx, JSValue obj, JSAtom name, int flags);
+JS_EXTERN int JS_DefineObjectNameComputed(JSContext *ctx, JSValue obj, JSValue name, int flags);
+
 #undef JS_EXTERN
 #undef js_force_inline
 
diff --git a/test262 b/test262
index d0994d6..249ef0e 160000
--- a/test262
+++ b/test262
@@ -1 +1 @@
-Subproject commit d0994d64b07cb6c164dd9f345c94ed797a53d69f
+Subproject commit 249ef0e4b5ee86c0440e4ce383f12d5811eb5eaa
