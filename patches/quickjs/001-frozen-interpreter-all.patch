diff --git a/quickjs-libc.c b/quickjs-libc.c
index ae01300..587c949 100644
--- a/quickjs-libc.c
+++ b/quickjs-libc.c
@@ -58,7 +58,9 @@
 #else
 #include <sys/ioctl.h>
 #include <poll.h>
-#if !defined(__wasi__)
+#if defined(__wasi__)
+#include <wasi/api.h>
+#else
 #include <dlfcn.h>
 #include <termios.h>
 #include <sys/resource.h>
@@ -825,7 +827,12 @@ static JSValue js_std_exit(JSContext *ctx, JSValueConst this_val,
     int status;
     if (JS_ToInt32(ctx, &status, argv[0]))
         status = -1;
+#if defined(__wasi__)
+    /* Use WASI proc_exit which can be trapped by the WASM runtime */
+    __wasi_proc_exit(status);
+#else
     exit(status);
+#endif
     return JS_UNDEFINED;
 }
 
@@ -4507,11 +4514,14 @@ static void js_std_promise_rejection_check(JSContext *ctx)
     if (unlikely(!list_empty(&ts->rejected_promise_list))) {
         list_for_each(el, &ts->rejected_promise_list) {
             JSRejectedPromiseEntry *rp = list_entry(el, JSRejectedPromiseEntry, link);
+#ifndef __wasi__
+            /* Only print rejection warnings on non-WASI platforms */
             fprintf(stderr, "Possibly unhandled promise rejection: ");
             js_std_dump_error1(ctx, rp->reason);
             fflush(stderr);
+#endif
         }
-        exit(1);
+        /* Don't exit - allow the event loop to continue or exit naturally */
     }
 }
 
diff --git a/quickjs.c b/quickjs.c
index 62f4381..3a64c7a 100644
--- a/quickjs.c
+++ b/quickjs.c
@@ -29,6 +29,10 @@
 #include <stdarg.h>
 #include <inttypes.h>
 #include <string.h>
+#ifdef FROZEN_DEBUG_REFCOUNT
+#include <execinfo.h>
+#include <signal.h>
+#endif
 #include <assert.h>
 #if !defined(_MSC_VER)
 #include <sys/time.h>
@@ -273,6 +277,7 @@ struct JSRuntime {
     struct list_head gc_zero_ref_count_list;
     struct list_head tmp_obj_list; /* used during GC */
     JSGCPhaseEnum gc_phase : 8;
+    uint8_t defer_free; /* 1 = skip free_zero_refcount, defer all frees */
     size_t malloc_gc_threshold;
 #ifdef ENABLE_DUMPS // JS_DUMP_LEAKS
     struct list_head string_list; /* list of JSString.link */
@@ -702,7 +707,8 @@ typedef struct JSFunctionBytecode {
     uint8_t super_allowed : 1;
     uint8_t arguments_allowed : 1;
     uint8_t backtrace_barrier : 1; /* stop backtrace on this function */
-    /* XXX: 5 bits available */
+    uint8_t has_use_strict : 1; /* EdgeBox: track explicit "use strict" for proper 'this' handling */
+    /* XXX: 4 bits available */
     uint8_t *byte_code_buf; /* (self pointer) */
     int byte_code_len;
     JSAtom func_name;
@@ -723,6 +729,7 @@ typedef struct JSFunctionBytecode {
     int pc2line_len;
     uint8_t *pc2line_buf;
     char *source;
+    void *frozen_impl; /* cached frozen function pointer: NULL=not looked up, 1=miss cached, other=frozen fn */
 } JSFunctionBytecode;
 
 typedef struct JSBoundFunction {
@@ -1291,7 +1298,28 @@ static void js_free_module_def(JSContext *ctx, JSModuleDef *m);
 static void js_mark_module_def(JSRuntime *rt, JSModuleDef *m,
                                JS_MarkFunc *mark_func);
 static JSValue js_import_meta(JSContext *ctx);
-static JSValue js_dynamic_import(JSContext *ctx, JSValueConst specifier);
+JSValue js_dynamic_import(JSContext *ctx, JSValueConst specifier);
+
+/* External frozen function dispatch - implemented in Zig native_dispatch.zig */
+extern int frozen_dispatch_lookup(JSContext *ctx, const char *func_name,
+                                  JSValue this_val, int argc, JSValue *argv,
+                                  JSVarRef **var_refs, int closure_var_count,
+                                  JSValue *cpool, void *bytecode_ptr,
+                                  JSValue *result_out);
+
+/* Bytecode-based frozen function dispatch - for closure/fclosure support */
+
+extern int frozen_dispatch_lookup_bytecode(JSContext *ctx, void *bytecode_ptr,
+                                           JSValue this_val, int argc, JSValue *argv,
+                                           JSVarRef **var_refs, int closure_var_count,
+                                           JSValue *cpool, JSValue *result_out);
+
+/* Get frozen function pointer for caching in JSFunctionBytecode.frozen_impl */
+extern void *frozen_dispatch_get_impl(void *bytecode_ptr);
+
+/* Debug: frozen dispatch depth counter */
+static int _frozen_depth = 0;
+
 static void free_var_ref(JSRuntime *rt, JSVarRef *var_ref);
 static JSValue js_new_promise_capability(JSContext *ctx,
                                          JSValue *resolving_funcs,
@@ -1987,6 +2015,15 @@ void JS_SetGCThreshold(JSRuntime *rt, size_t gc_threshold)
     rt->malloc_gc_threshold = gc_threshold;
 }
 
+/* Enable/disable deferred free mode.
+   When enabled, free_zero_refcount is skipped — objects accumulate on
+   gc_zero_ref_count_list and are only freed during JS_RunGC or exit.
+   Use for short-lived programs where memory is reclaimed at exit. */
+void JS_SetDeferFree(JSRuntime *rt, int enable)
+{
+    rt->defer_free = enable ? 1 : 0;
+}
+
 #define malloc(s) malloc_is_forbidden(s)
 #define free(p) free_is_forbidden(p)
 #define realloc(p,s) realloc_is_forbidden(p,s)
@@ -5316,6 +5353,19 @@ static JSFunctionBytecode *JS_GetFunctionBytecode(JSValueConst val)
     return p->u.func.function_bytecode;
 }
 
+/* External wrapper for frozen function bytecode registration */
+/* Returns bytecode pointer as void* for use in native dispatch */
+/* Handles both JS_TAG_FUNCTION_BYTECODE (from cpool) and JS_TAG_OBJECT (wrapped function) */
+void *js_get_function_bytecode_ptr(JSValueConst val)
+{
+    /* First check if it's a raw bytecode tag (from cpool) */
+    if (JS_VALUE_GET_TAG(val) == JS_TAG_FUNCTION_BYTECODE) {
+        return JS_VALUE_GET_PTR(val);
+    }
+    /* Otherwise try as a function object */
+    return (void *)JS_GetFunctionBytecode(val);
+}
+
 static void js_method_set_home_object(JSContext *ctx, JSValue func_obj,
                                       JSValue home_obj)
 {
@@ -5341,6 +5391,14 @@ static void js_method_set_home_object(JSContext *ctx, JSValue func_obj,
     }
 }
 
+/* External wrapper for setting method home object (for ES6 super calls) */
+/* This is needed because js_method_set_home_object is static */
+void JS_SetHomeObject(JSContext *ctx, JSValue func_obj, JSValue home_obj)
+{
+    js_method_set_home_object(ctx, func_obj, home_obj);
+}
+
+
 static JSValue js_get_function_name(JSContext *ctx, JSAtom name)
 {
     JSValue name_str;
@@ -5723,8 +5781,16 @@ static force_inline JSShapeProperty *find_own_property(JSProperty **ppr,
 static void free_var_ref(JSRuntime *rt, JSVarRef *var_ref)
 {
     if (var_ref) {
-        assert(var_ref->header.ref_count > 0);
+        /* FIX: Handle double-free gracefully - frozen closures may trigger this */
+        if (var_ref->header.ref_count == 0) {
+            return;
+        }
         if (--var_ref->header.ref_count == 0) {
+            /* FIX: Only remove from GC/stack list if actually in one */
+            if (!var_ref->header.link.prev) {
+                js_free_rt(rt, var_ref);
+                return;
+            }
             if (var_ref->is_detached) {
                 JS_FreeValueRT(rt, var_ref->value);
                 remove_gc_object(&var_ref->header);
@@ -5992,7 +6058,7 @@ static void js_free_value_rt(JSRuntime *rt, JSValue v)
             if (rt->gc_phase != JS_GC_PHASE_REMOVE_CYCLES) {
                 list_del(&p->link);
                 list_add(&p->link, &rt->gc_zero_ref_count_list);
-                if (rt->gc_phase == JS_GC_PHASE_NONE) {
+                if (rt->gc_phase == JS_GC_PHASE_NONE && !rt->defer_free) {
                     free_zero_refcount(rt);
                 }
             }
@@ -6023,6 +6089,19 @@ void JS_FreeValueRT(JSRuntime *rt, JSValue v)
 {
     if (JS_VALUE_HAS_REF_COUNT(v)) {
         JSRefCountHeader *p = (JSRefCountHeader *)JS_VALUE_GET_PTR(v);
+#ifdef FROZEN_DEBUG_REFCOUNT
+        if (p->ref_count <= 0 || (unsigned)p->ref_count > 0x40000000) {
+            fprintf(stderr, "FROZEN_DEBUG: bad ref_count! ptr=%p ref_count=%d (0x%x) tag=%d\n",
+                    p, p->ref_count, (unsigned)p->ref_count, JS_VALUE_GET_TAG(v));
+            {
+                void *bt[20];
+                int n = backtrace(bt, 20);
+                backtrace_symbols_fd(bt, n, 2); /* fd 2 = stderr */
+            }
+            fflush(stderr);
+            signal(SIGABRT, SIG_DFL); abort();
+        }
+#endif
         if (--p->ref_count <= 0) {
             js_free_value_rt(rt, v);
         }
@@ -6280,6 +6359,21 @@ static void gc_free_cycles(JSRuntime *rt)
 #endif
             free_gc_object(rt, p);
             break;
+        case JS_GC_OBJ_TYPE_VAR_REF:
+            /* Frozen interpreter can create var_refs in cycles.
+             * Free the captured value NOW (before other objects that might
+             * reference it are freed), then defer the var_ref struct freeing
+             * until after all finalizers have run. Setting ref_count=0
+             * tells free_var_ref() to skip this var_ref. */
+            {
+                JSVarRef *var_ref = (JSVarRef *)p;
+                JS_FreeValueRT(rt, var_ref->value);  /* Free value while still valid */
+                var_ref->value = JS_UNDEFINED;  /* Clear to avoid double-free */
+                var_ref->header.ref_count = 0;  /* Mark as being freed by GC */
+                list_del(&p->link);
+                list_add_tail(&p->link, &rt->gc_zero_ref_count_list);
+            }
+            break;
         default:
             list_del(&p->link);
             list_add_tail(&p->link, &rt->gc_zero_ref_count_list);
@@ -6290,6 +6384,12 @@ static void gc_free_cycles(JSRuntime *rt)
 
     list_for_each_safe(el, el1, &rt->gc_zero_ref_count_list) {
         p = list_entry(el, JSGCObjectHeader, link);
+        /* Handle deferred VAR_REFs from frozen interpreter cycles.
+         * The value was already freed in the switch case above. */
+        if (p->gc_obj_type == JS_GC_OBJ_TYPE_VAR_REF) {
+            js_free_rt(rt, p);
+            continue;
+        }
         assert(p->gc_obj_type == JS_GC_OBJ_TYPE_JS_OBJECT ||
                p->gc_obj_type == JS_GC_OBJ_TYPE_FUNCTION_BYTECODE);
         js_free_rt(rt, p);
@@ -10148,7 +10248,7 @@ static bool js_object_has_name(JSContext *ctx, JSValue obj)
     return (p->len != 0);
 }
 
-static int JS_DefineObjectName(JSContext *ctx, JSValue obj,
+int JS_DefineObjectName(JSContext *ctx, JSValue obj,
                                JSAtom name, int flags)
 {
     if (name != JS_ATOM_NULL
@@ -10160,7 +10260,7 @@ static int JS_DefineObjectName(JSContext *ctx, JSValue obj,
     return 0;
 }
 
-static int JS_DefineObjectNameComputed(JSContext *ctx, JSValue obj,
+int JS_DefineObjectNameComputed(JSContext *ctx, JSValue obj,
                                        JSValue str, int flags)
 {
     if (JS_IsObject(obj) &&
@@ -15134,6 +15234,12 @@ static JSValue js_build_arguments(JSContext *ctx, int argc, JSValueConst *argv)
     return val;
 }
 
+/* Public wrapper for frozen code to create proper arguments object */
+JSValue JS_NewArguments(JSContext *ctx, int argc, JSValueConst *argv)
+{
+    return js_build_arguments(ctx, argc, argv);
+}
+
 #define GLOBAL_VAR_OFFSET 0x40000000
 #define ARGUMENT_VAR_OFFSET 0x20000000
 
@@ -15598,6 +15704,1063 @@ static __exception int js_for_of_next(JSContext *ctx, JSValue *sp, int offset)
     return 0;
 }
 
+/* ========================================================================
+ * Wrapper functions for frozen interpreter
+ * ======================================================================== */
+
+/* Helper to get class ID for function kind (for async/generator closure support) */
+static inline uint16_t frozen_func_kind_to_class_id(uint8_t func_kind)
+{
+    switch (func_kind) {
+    case JS_FUNC_GENERATOR: return JS_CLASS_GENERATOR_FUNCTION;
+    case JS_FUNC_ASYNC: return JS_CLASS_ASYNC_FUNCTION;
+    case JS_FUNC_ASYNC_GENERATOR: return JS_CLASS_ASYNC_GENERATOR_FUNCTION;
+    default: return JS_CLASS_BYTECODE_FUNCTION;
+    }
+}
+
+/* Iterator helpers */
+int js_frozen_for_in_start(JSContext *ctx, JSValue *sp)
+{
+    return js_for_in_start(ctx, sp);
+}
+
+int js_frozen_for_in_next(JSContext *ctx, JSValue *sp)
+{
+    return js_for_in_next(ctx, sp);
+}
+
+int js_frozen_for_of_start(JSContext *ctx, JSValue *sp, int is_async)
+{
+    return js_for_of_start(ctx, sp, is_async != 0);
+}
+
+int js_frozen_for_of_next(JSContext *ctx, JSValue *sp, int offset)
+{
+    return js_for_of_next(ctx, sp, offset);
+}
+
+/* Closure variable access wrappers */
+JSValue js_frozen_get_var_ref(JSContext *ctx, JSVarRef **var_refs, int idx)
+{
+    (void)ctx;
+    if (!var_refs || !var_refs[idx])
+        return JS_UNDEFINED;
+    return js_dup(*var_refs[idx]->pvalue);
+}
+
+
+void js_frozen_set_var_ref(JSContext *ctx, JSVarRef **var_refs, int idx, JSValue val)
+{
+    if (var_refs && var_refs[idx]) {
+        set_value(ctx, var_refs[idx]->pvalue, val);
+    }
+}
+
+/* Safe closure variable access with bounds checking */
+JSValue js_frozen_get_var_ref_safe(JSContext *ctx, JSVarRef **var_refs, int idx, int var_refs_count)
+{
+    (void)ctx;
+    if (!var_refs || idx < 0 || idx >= var_refs_count || !var_refs[idx])
+        return JS_UNDEFINED;
+    JSVarRef *var_ref = var_refs[idx];
+    JSValue val = *var_ref->pvalue;
+    return js_dup(val);
+}
+
+void js_frozen_set_var_ref_safe(JSContext *ctx, JSVarRef **var_refs, int idx, int var_refs_count, JSValue val)
+{
+    if (var_refs && idx >= 0 && idx < var_refs_count && var_refs[idx]) {
+        set_value(ctx, var_refs[idx]->pvalue, val);
+    }
+}
+
+/* Constant pool access for nested function registration */
+int js_frozen_get_cpool_info(void *bytecode_ptr, int *cpool_count_out, void **cpool_out)
+{
+    if (!bytecode_ptr || !cpool_count_out || !cpool_out)
+        return 0;
+    JSFunctionBytecode *b = (JSFunctionBytecode *)bytecode_ptr;
+    *cpool_count_out = b->cpool_count;
+    *cpool_out = b->cpool;
+    return 1;
+}
+
+void *js_frozen_get_cpool_func_bytecode(void *cpool, int idx)
+{
+    if (!cpool || idx < 0)
+        return NULL;
+    JSValue *cpool_arr = (JSValue *)cpool;
+    JSValue val = cpool_arr[idx];
+    if (JS_VALUE_GET_TAG(val) == JS_TAG_FUNCTION_BYTECODE) {
+        return JS_VALUE_GET_PTR(val);
+    }
+    return NULL;
+}
+
+int js_frozen_get_bytecode_name_line(JSContext *ctx, void *bytecode_ptr, char *name_buf, int name_buf_size, int *line_out)
+{
+    if (!bytecode_ptr || !name_buf || name_buf_size <= 0 || !line_out)
+        return 0;
+    JSFunctionBytecode *b = (JSFunctionBytecode *)bytecode_ptr;
+    *line_out = b->line_num;
+    const char *name = JS_AtomToCString(ctx, b->func_name);
+    if (name) {
+        snprintf(name_buf, name_buf_size, "%s", name);
+        JS_FreeCString(ctx, name);
+        return 1;
+    }
+    name_buf[0] = '\0';
+    return 0;
+}
+
+/* Thin fast path for frozen function calls - bypasses JS_CallInternal overhead.
+ * Checks cached frozen_impl on JSFunctionBytecode; if cached and valid,
+ * calls the frozen function directly with var_refs/cpool from the JSObject.
+ * Returns 1 if frozen call succeeded (result in *result_out), 0 otherwise. */
+static uint64_t try_call_hits = 0;
+static uint64_t try_call_miss_not_obj = 0;
+static uint64_t try_call_miss_not_bc = 0;
+static uint64_t try_call_miss_no_impl = 0;
+static uint64_t try_call_miss_sentinel = 0;
+
+int js_frozen_try_call(JSContext *ctx, JSValueConst func_obj, JSValueConst this_obj,
+                       int argc, JSValueConst *argv, JSValue *result_out)
+{
+    if (JS_VALUE_GET_TAG(func_obj) != JS_TAG_OBJECT) {
+        try_call_miss_not_obj++;
+        return 0;
+    }
+    JSObject *p = JS_VALUE_GET_OBJ(func_obj);
+    if (unlikely(p->class_id != JS_CLASS_BYTECODE_FUNCTION)) {
+        try_call_miss_not_bc++;
+        return 0;
+    }
+    JSFunctionBytecode *b = p->u.func.function_bytecode;
+    void *impl = b->frozen_impl;
+    if (!impl) {
+        try_call_miss_no_impl++;
+        return 0;
+    }
+    if (impl == (void *)1) {
+        try_call_miss_sentinel++;
+        return 0;
+    }
+
+    try_call_hits++;
+    typedef JSValue (*FrozenFn)(JSContext *, JSValue, int, JSValue *,
+                                JSVarRef **, int, JSValue *);
+    *result_out = ((FrozenFn)impl)(ctx, this_obj, argc, (JSValue *)argv,
+                                   p->u.func.var_refs, b->closure_var_count, b->cpool);
+    return 1;
+}
+
+void js_frozen_try_call_stats(void)
+{
+    fprintf(stderr, "[try_call] hits=%llu miss_not_obj=%llu miss_not_bc=%llu miss_no_impl=%llu miss_sentinel=%llu\n",
+            try_call_hits, try_call_miss_not_obj, try_call_miss_not_bc,
+            try_call_miss_no_impl, try_call_miss_sentinel);
+}
+
+/* Dump struct offsets for Zig-side direct access (zero FFI fast path) */
+void js_frozen_dump_offsets(void)
+{
+    JSObject obj;
+    JSFunctionBytecode bc;
+    fprintf(stderr, "[offsets] JSObject.class_id=%zu\n", (size_t)((char *)&obj.class_id - (char *)&obj));
+    fprintf(stderr, "[offsets] JSObject.shape=%zu\n", (size_t)((char *)&obj.shape - (char *)&obj));
+    fprintf(stderr, "[offsets] JSObject.u.func.function_bytecode=%zu\n",
+            (size_t)((char *)&obj.u.func.function_bytecode - (char *)&obj));
+    fprintf(stderr, "[offsets] JSObject.u.func.var_refs=%zu\n",
+            (size_t)((char *)&obj.u.func.var_refs - (char *)&obj));
+    fprintf(stderr, "[offsets] JSFunctionBytecode.frozen_impl=%zu\n",
+            (size_t)((char *)&bc.frozen_impl - (char *)&bc));
+    fprintf(stderr, "[offsets] JSFunctionBytecode.closure_var_count=%zu\n",
+            (size_t)((char *)&bc.closure_var_count - (char *)&bc));
+    fprintf(stderr, "[offsets] JSFunctionBytecode.cpool=%zu\n",
+            (size_t)((char *)&bc.cpool - (char *)&bc));
+    fprintf(stderr, "[offsets] JS_CLASS_BYTECODE_FUNCTION=%d\n", JS_CLASS_BYTECODE_FUNCTION);
+    fprintf(stderr, "[offsets] sizeof(JSObject)=%zu sizeof(JSFunctionBytecode)=%zu\n",
+            sizeof(JSObject), sizeof(JSFunctionBytecode));
+}
+
+/* Iterator support for frozen functions */
+JSValue js_frozen_get_iterator(JSContext *ctx, JSValue obj, int is_async)
+{
+    return JS_GetIterator(ctx, obj, is_async != 0);
+}
+
+JSValue js_frozen_iterator_next(JSContext *ctx, JSValue iter, int *done)
+{
+    JSValue method = JS_GetProperty(ctx, iter, JS_ATOM_next);
+    if (JS_IsException(method)) {
+        *done = 1;
+        return JS_EXCEPTION;
+    }
+    JSValue result = JS_Call(ctx, method, iter, 0, NULL);
+    JS_FreeValue(ctx, method);
+    if (JS_IsException(result)) {
+        *done = 1;
+        return JS_EXCEPTION;
+    }
+    // Get done and value from result
+    JSValue done_val = JS_GetProperty(ctx, result, JS_ATOM_done);
+    *done = JS_ToBool(ctx, done_val);
+    JS_FreeValue(ctx, done_val);
+    JSValue value = JS_GetProperty(ctx, result, JS_ATOM_value);
+    JS_FreeValue(ctx, result);
+    return value;
+}
+
+int js_frozen_iterator_close(JSContext *ctx, JSValue iter, int completion_type)
+{
+    (void)completion_type;
+    JSValue ret_method = JS_GetProperty(ctx, iter, JS_ATOM_return);
+    if (!JS_IsUndefined(ret_method) && !JS_IsNull(ret_method)) {
+        JSValue ret = JS_Call(ctx, ret_method, iter, 0, NULL);
+        JS_FreeValue(ctx, ret_method);
+        if (JS_IsException(ret)) {
+            return -1;
+        }
+        JS_FreeValue(ctx, ret);
+    } else {
+        JS_FreeValue(ctx, ret_method);
+    }
+    return 0;
+}
+
+JSValue js_frozen_iterator_get_value_done(JSContext *ctx, JSValue result, int *done)
+{
+    JSValue done_val = JS_GetProperty(ctx, result, JS_ATOM_done);
+    *done = JS_ToBool(ctx, done_val);
+    JS_FreeValue(ctx, done_val);
+    JSValue value = JS_GetProperty(ctx, result, JS_ATOM_value);
+    return value;
+}
+
+int js_frozen_set_field(JSContext *ctx, JSValue obj, const char *prop, JSValue val)
+{
+    return JS_SetPropertyStr(ctx, obj, prop, val);
+}
+
+JSValue js_frozen_to_object(JSContext *ctx, JSValue val)
+{
+    return JS_ToObject(ctx, val);
+}
+
+JSValue js_frozen_get_length(JSContext *ctx, JSValue obj)
+{
+    int64_t len;
+    if (JS_GetLength(ctx, obj, &len) < 0)
+        return JS_EXCEPTION;
+    return JS_NewInt64(ctx, len);
+}
+
+JSValue js_frozen_to_prop_key(JSContext *ctx, JSValue val)
+{
+    JSAtom atom = JS_ValueToAtom(ctx, val);
+    if (atom == JS_ATOM_NULL)
+        return JS_EXCEPTION;
+    JSValue ret = JS_AtomToValue(ctx, atom);
+    JS_FreeAtom(ctx, atom);
+    return ret;
+}
+
+int js_frozen_set_proto(JSContext *ctx, JSValue obj, JSValue proto)
+{
+    return JS_SetPrototype(ctx, obj, proto);
+}
+
+/* Execute a single opcode via the interpreter
+ * Used for block-level fallback when frozen code encounters an unsupported opcode
+ * Returns JS_UNDEFINED on success, JS_EXCEPTION on error
+ */
+JSValue js_frozen_exec_opcode(JSContext *ctx, int opcode, uint32_t operand,
+                               JSValue *stack, int *sp, JSValue *locals, int local_count)
+{
+    (void)operand;
+    (void)locals;
+    (void)local_count;
+
+    /* Handle common opcodes that might be unsupported in frozen code */
+    switch (opcode) {
+    case OP_set_proto:
+        {
+            JSValue proto = stack[*sp - 1];
+            JSValue obj = stack[*sp - 2];
+            if (JS_SetPrototype(ctx, obj, proto) < 0) {
+                return JS_EXCEPTION;
+            }
+            JS_FreeValue(ctx, proto);
+            (*sp)--;
+        }
+        break;
+    case OP_pow:
+        {
+            double a, b, r;
+            JSValue va = stack[*sp - 2];
+            JSValue vb = stack[*sp - 1];
+            if (JS_ToFloat64(ctx, &a, va) || JS_ToFloat64(ctx, &b, vb))
+                return JS_EXCEPTION;
+            r = pow(a, b);
+            JS_FreeValue(ctx, va);
+            JS_FreeValue(ctx, vb);
+            stack[*sp - 2] = JS_NewFloat64(ctx, r);
+            (*sp)--;
+        }
+        break;
+    default:
+        /* Unknown opcode - return exception with helpful message */
+        return JS_ThrowTypeError(ctx, "Unsupported opcode %d in frozen function fallback", opcode);
+    }
+    return JS_UNDEFINED;
+}
+
+/* Create a closure from frozen code
+ * Called from frozen functions to implement OP_fclosure/OP_fclosure8
+ *
+ * Parameters:
+ * - ctx: JavaScript context
+ * - bfunc: The bytecode function from cpool (JSValue containing JSFunctionBytecode)
+ * - cur_var_refs: Parent's var_refs (for closures inherited from parent scope)
+ * - locals: Array of local variables from frozen function
+ * - num_locals: Number of locals in the frozen function's locals array
+ * - args: Array of argument values from frozen function
+ * - num_args: Number of arguments
+ *
+ * Note: Unlike normal js_closure, this creates "detached" var_refs immediately
+ * because the frozen function's locals/args arrays are stack-allocated and will
+ * be invalid after the frozen function returns.
+ */
+JSValue js_frozen_create_closure(JSContext *ctx, JSValue bfunc,
+                                 JSVarRef **cur_var_refs,
+                                 JSValue *locals, int num_locals,
+                                 JSValue *args, int num_args)
+{
+    JSFunctionBytecode *b;
+    JSValue func_obj;
+    JSAtom name_atom;
+    JSObject *p;
+    JSVarRef **var_refs;
+    int i;
+
+    b = JS_VALUE_GET_PTR(bfunc);
+    /* Use correct class based on func_kind for async/generator support */
+    func_obj = JS_NewObjectClass(ctx, frozen_func_kind_to_class_id(b->func_kind));
+    if (JS_IsException(func_obj)) {
+        JS_FreeValue(ctx, bfunc);
+        return JS_EXCEPTION;
+    }
+
+    p = JS_VALUE_GET_OBJ(func_obj);
+    p->u.func.function_bytecode = b;
+    b->header.ref_count++;  /* Increment bytecode refcount for this closure */
+    p->u.func.home_object = NULL;
+    p->u.func.var_refs = NULL;
+
+    if (b->closure_var_count) {
+        var_refs = js_mallocz(ctx, sizeof(var_refs[0]) * b->closure_var_count);
+        if (!var_refs)
+            goto fail;
+        p->u.func.var_refs = var_refs;
+
+        for(i = 0; i < b->closure_var_count; i++) {
+            JSClosureVar *cv = &b->closure_var[i];
+            JSVarRef *var_ref;
+
+            if (cv->is_local) {
+                /* Local capture from frozen function - create detached var_ref */
+                var_ref = js_malloc(ctx, sizeof(JSVarRef));
+                if (!var_ref)
+                    goto fail;
+                var_ref->header.ref_count = 1;
+                var_ref->is_detached = true;  /* Already detached */
+
+                /* Get value from locals or args array */
+                JSValue val;
+                if (cv->is_arg) {
+                    if (cv->var_idx < num_args)
+                        val = args[cv->var_idx];
+                    else
+                        val = JS_UNDEFINED;
+                } else {
+                    if (cv->var_idx < num_locals)
+                        val = locals[cv->var_idx];
+                    else
+                        val = JS_UNDEFINED;
+                }
+                /* Copy value into var_ref's own storage (detached mode) */
+                var_ref->value = js_dup(val);
+                var_ref->pvalue = &var_ref->value;
+                /* Add to GC list - required for detached var_refs */
+                add_gc_object(ctx->rt, &var_ref->header, JS_GC_OBJ_TYPE_VAR_REF);
+            } else {
+                /* Parent closure reference */
+                if (cur_var_refs && cur_var_refs[cv->var_idx]) {
+                    var_ref = cur_var_refs[cv->var_idx];
+                    var_ref->header.ref_count++;
+                } else {
+                    /* No parent var_ref available - create undefined */
+                    var_ref = js_malloc(ctx, sizeof(JSVarRef));
+                    if (!var_ref)
+                        goto fail;
+                    var_ref->header.ref_count = 1;
+                    var_ref->is_detached = true;
+                    var_ref->value = JS_UNDEFINED;
+                    var_ref->pvalue = &var_ref->value;
+                    /* Add to GC list - required for detached var_refs */
+                    add_gc_object(ctx->rt, &var_ref->header, JS_GC_OBJ_TYPE_VAR_REF);
+                }
+            }
+            var_refs[i] = var_ref;
+        }
+    }
+
+    name_atom = b->func_name;
+    if (name_atom == JS_ATOM_NULL)
+        name_atom = JS_ATOM_empty_string;
+    js_function_set_properties(ctx, func_obj, name_atom, b->defined_arg_count);
+
+    if (b->has_prototype) {
+        JS_SetConstructorBit(ctx, func_obj, true);
+        JS_DefineAutoInitProperty(ctx, func_obj, JS_ATOM_prototype,
+                                  JS_AUTOINIT_ID_PROTOTYPE, NULL,
+                                  JS_PROP_WRITABLE);
+    }
+    return func_obj;
+fail:
+    JS_FreeValue(ctx, func_obj);
+    return JS_EXCEPTION;
+}
+
+/* ============================================================================
+ * Frozen Closure V2: Shared var_refs for function hoisting support
+ *
+ * Problem: When creating closures in frozen functions, if function A captures
+ * function B which is defined later, A's closure sees B as UNDEFINED because
+ * B hasn't been assigned yet.
+ *
+ * Solution: Use shared var_refs like normal QuickJS closures. All closures
+ * that capture the same local variable share one var_ref which points to
+ * the live local slot. When B is later assigned, A's closure sees the update.
+ * Before the frozen function returns, all var_refs are "detached" (values
+ * copied) since the locals array will be destroyed.
+ * ============================================================================ */
+
+/* Entry for tracking var_refs that point to frozen function's locals */
+typedef struct JSFrozenVarRefEntry {
+    struct list_head link;
+    JSVarRef *var_ref;
+    JSValue *local_ptr;
+} JSFrozenVarRefEntry;
+
+/* Initialize frozen var_ref tracking list */
+void js_frozen_var_ref_list_init(struct list_head *list)
+{
+    init_list_head(list);
+}
+
+/* Debug: verify list is still valid (can be called from Zig) */
+void js_frozen_var_ref_list_verify(struct list_head *list, const char *label)
+{
+    (void)list;
+    (void)label;
+}
+
+/* Get or create shared var_ref for a frozen function's local variable */
+static JSVarRef *get_frozen_local_var_ref(JSContext *ctx, struct list_head *var_ref_list,
+                                          JSValue *locals, int var_idx)
+{
+    struct list_head *el;
+    JSValue *local_ptr = &locals[var_idx];
+
+    /* Defensive: validate list head */
+    if (!var_ref_list || !var_ref_list->next || !var_ref_list->prev) {
+        goto create_new;
+    }
+
+    /* Reuse existing var_ref if already tracking this slot */
+    list_for_each(el, var_ref_list) {
+        JSFrozenVarRefEntry *entry = list_entry(el, JSFrozenVarRefEntry, link);
+        /* Defensive: check for corrupted entry (NaN-boxed value instead of pointer) */
+        if ((uintptr_t)entry->local_ptr > 0x7ff0000000000000ULL) {
+            goto create_new;
+        }
+        if (entry->local_ptr == local_ptr) {
+            entry->var_ref->header.ref_count++;
+            return entry->var_ref;
+        }
+    }
+
+create_new:
+    /* Create new var_ref pointing to live local slot */
+    /* Use js_mallocz to zero-initialize all fields including gc_obj_type/mark */
+    ;  /* Empty statement after label */
+    JSVarRef *var_ref = js_mallocz(ctx, sizeof(JSVarRef));
+    if (!var_ref)
+        return NULL;
+
+    /* Start with ref_count = 2: one for the entry (list ownership) and one for
+     * the first closure that will use this var_ref. This prevents premature
+     * freeing if the closure is released before js_frozen_var_ref_list_detach
+     * is called. */
+    var_ref->header.ref_count = 2;
+    var_ref->is_detached = false;  /* Points to live local */
+    var_ref->pvalue = local_ptr;
+    var_ref->value = JS_UNDEFINED;
+    /* Initialize link to empty list for safe list_del if freed early */
+    init_list_head(&var_ref->header.link);
+    /* NOTE: Do NOT add to GC list here - GC asserts var_refs are detached.
+     * Non-detached var_refs are tracked by frozen var_ref list and
+     * added to GC when detached in js_frozen_var_ref_list_detach. */
+
+    /* Track for later detachment */
+    JSFrozenVarRefEntry *entry = js_malloc(ctx, sizeof(JSFrozenVarRefEntry));
+    if (!entry) {
+        js_free(ctx, var_ref);
+        return NULL;
+    }
+    entry->var_ref = var_ref;
+    entry->local_ptr = local_ptr;
+    list_add_tail(&entry->link, var_ref_list);
+
+    return var_ref;
+}
+
+/* Detach all var_refs before frozen function returns */
+void js_frozen_var_ref_list_detach(JSContext *ctx, struct list_head *list)
+{
+    struct list_head *el, *el1;
+
+    if (!list || !list->next || !list->prev)
+        return;
+
+    /* Detect corrupted list head - if next is a JSValue tag (e.g. 0xFFFFFFFFFFFFFFFF = JS_TAG_OBJECT),
+     * the list was overwritten by locals. Skip detach to avoid crash. */
+    if ((uintptr_t)list->next > 0xFFFF000000000000ULL || (uintptr_t)list->prev > 0xFFFF000000000000ULL) {
+        return;
+    }
+
+    list_for_each_safe(el, el1, list) {
+        JSFrozenVarRefEntry *entry = list_entry(el, JSFrozenVarRefEntry, link);
+        JSVarRef *var_ref = entry->var_ref;
+
+        /* Release the entry's ownership reference. The var_ref was created with
+         * ref_count = 2 (one for entry, one for first closure). If all closures
+         * have been freed, ref_count could now be 1, so decrementing makes it 0. */
+        int new_ref_count = --var_ref->header.ref_count;
+
+        if (new_ref_count == 0) {
+            /* No closures reference this var_ref anymore. Skip detach entirely -
+             * don't read *pvalue (which may be stale) since nobody needs the value.
+             * Just free the var_ref struct directly. */
+            js_free(ctx, var_ref);
+        } else if (!var_ref->is_detached) {
+            /* Detach: copy value from live local slot to internal storage.
+             * Other closures still reference this var_ref, so we must preserve
+             * the value and add to GC list for proper cleanup. */
+            var_ref->value = js_dup(*var_ref->pvalue);
+            var_ref->pvalue = &var_ref->value;
+            var_ref->is_detached = true;
+            add_gc_object(ctx->rt, &var_ref->header, JS_GC_OBJ_TYPE_VAR_REF);
+        }
+
+        list_del(el);
+        js_free(ctx, entry);
+    }
+}
+
+/* Create closure with shared var_refs for function hoisting */
+JSValue js_frozen_create_closure_v2(JSContext *ctx, JSValue bfunc,
+                                    JSVarRef **cur_var_refs,
+                                    struct list_head *local_var_ref_list,
+                                    JSValue *locals, int num_locals,
+                                    JSValue *args, int num_args)
+{
+    JSFunctionBytecode *b;
+    JSValue func_obj;
+    JSAtom name_atom;
+    JSObject *p;
+    JSVarRef **var_refs;
+    int i;
+
+    if (JS_VALUE_GET_TAG(bfunc) != JS_TAG_FUNCTION_BYTECODE) {
+        return JS_ThrowTypeError(ctx, "not a function bytecode");
+    }
+    b = JS_VALUE_GET_PTR(bfunc);
+    /* Use correct class based on func_kind for async/generator support */
+    func_obj = JS_NewObjectClass(ctx, frozen_func_kind_to_class_id(b->func_kind));
+    if (JS_IsException(func_obj)) {
+        JS_FreeValue(ctx, bfunc);
+        return JS_EXCEPTION;
+    }
+
+    p = JS_VALUE_GET_OBJ(func_obj);
+    p->u.func.function_bytecode = b;
+    b->header.ref_count++;  /* Increment bytecode refcount for this closure */
+    p->u.func.home_object = NULL;
+    p->u.func.var_refs = NULL;
+
+    if (b->closure_var_count) {
+        var_refs = js_mallocz(ctx, sizeof(var_refs[0]) * b->closure_var_count);
+        if (!var_refs)
+            goto fail_v2;
+        p->u.func.var_refs = var_refs;
+
+        for (i = 0; i < b->closure_var_count; i++) {
+            JSClosureVar *cv = &b->closure_var[i];
+            JSVarRef *var_ref;
+
+            if (cv->is_local) {
+                if (cv->is_arg) {
+                    /* Argument capture - immediate detach (args don't change) */
+                    var_ref = js_malloc(ctx, sizeof(JSVarRef));
+                    if (!var_ref)
+                        goto fail_v2;
+                    var_ref->header.ref_count = 1;
+                    var_ref->is_detached = true;
+                    JSValue val = (cv->var_idx < num_args) ? args[cv->var_idx] : JS_UNDEFINED;
+                    var_ref->value = js_dup(val);
+                    var_ref->pvalue = &var_ref->value;
+                    add_gc_object(ctx->rt, &var_ref->header, JS_GC_OBJ_TYPE_VAR_REF);
+                } else if (cv->var_idx < num_locals) {
+                    /* Local capture - use shared var_ref for deferred detachment.
+                     * This allows closures to see final values of locals (e.g., classes
+                     * defined after hoisted function declarations).
+                     * The var_ref points to locals[i] and is detached at function return
+                     * via js_frozen_var_ref_list_detach(), which copies the final value. */
+                    var_ref = get_frozen_local_var_ref(ctx, local_var_ref_list, locals, cv->var_idx);
+                } else {
+                    /* var_idx >= num_locals: out of bounds for locals array.
+                     * Fall back to detached var_ref with undefined value. */
+                    {
+                        char parent_name[64], child_cv_name[64];
+                        JS_AtomGetStr(ctx, parent_name, sizeof(parent_name), b->func_name);
+                        JS_AtomGetStr(ctx, child_cv_name, sizeof(child_cv_name), cv->var_name);
+                        fprintf(stderr, "[CLOSURE] OOB local capture: child='%s' cv[%d]='%s' var_idx=%d >= num_locals=%d (is_arg=%d)\n",
+                                parent_name, i, child_cv_name, cv->var_idx, num_locals, cv->is_arg);
+                    }
+                    var_ref = js_malloc(ctx, sizeof(JSVarRef));
+                    if (!var_ref)
+                        goto fail_v2;
+                    var_ref->header.ref_count = 1;
+                    var_ref->is_detached = true;
+                    var_ref->value = JS_UNDEFINED;
+                    var_ref->pvalue = &var_ref->value;
+                    add_gc_object(ctx->rt, &var_ref->header, JS_GC_OBJ_TYPE_VAR_REF);
+                }
+                if (!var_ref)
+                    goto fail_v2;
+            } else {
+                /* Parent closure reference */
+                if (cur_var_refs && cur_var_refs[cv->var_idx]) {
+                    var_ref = cur_var_refs[cv->var_idx];
+                    var_ref->header.ref_count++;
+                } else {
+                    /* Missing parent var_ref - create detached with UNDEFINED */
+                    {
+                        char parent_name[64], child_cv_name[64];
+                        JS_AtomGetStr(ctx, parent_name, sizeof(parent_name), b->func_name);
+                        JS_AtomGetStr(ctx, child_cv_name, sizeof(child_cv_name), cv->var_name);
+                        fprintf(stderr, "[CLOSURE] Missing parent var_ref: child='%s' cv[%d]='%s' var_idx=%d cur_var_refs=%p\n",
+                                parent_name, i, child_cv_name, cv->var_idx, (void*)cur_var_refs);
+                    }
+                    var_ref = js_malloc(ctx, sizeof(JSVarRef));
+                    if (!var_ref)
+                        goto fail_v2;
+                    var_ref->header.ref_count = 1;
+                    var_ref->is_detached = true;
+                    var_ref->value = JS_UNDEFINED;
+                    var_ref->pvalue = &var_ref->value;
+                    add_gc_object(ctx->rt, &var_ref->header, JS_GC_OBJ_TYPE_VAR_REF);
+                }
+            }
+            var_refs[i] = var_ref;
+        }
+    }
+
+    name_atom = b->func_name;
+    if (name_atom == JS_ATOM_NULL)
+        name_atom = JS_ATOM_empty_string;
+    js_function_set_properties(ctx, func_obj, name_atom, b->defined_arg_count);
+
+    if (b->has_prototype) {
+        JS_SetConstructorBit(ctx, func_obj, true);
+        JS_DefineAutoInitProperty(ctx, func_obj, JS_ATOM_prototype,
+                                  JS_AUTOINIT_ID_PROTOTYPE, NULL,
+                                  JS_PROP_WRITABLE);
+    }
+    return func_obj;
+fail_v2:
+    JS_FreeValue(ctx, func_obj);
+    return JS_EXCEPTION;
+}
+
+/* Create class constructor and prototype from frozen code (for define_class opcode) */
+#ifndef JS_DEFINE_CLASS_HAS_HERITAGE
+#define JS_DEFINE_CLASS_HAS_HERITAGE (1 << 0)
+#endif
+int js_frozen_define_class(JSContext *ctx, JSValue bfunc, JSValue parent_class,
+                           int class_flags, JSAtom class_name,
+                           JSVarRef **cur_var_refs,
+                           struct list_head *local_var_ref_list,
+                           JSValue *locals, int num_locals,
+                           JSValue *args, int num_args,
+                           JSValue *out_ctor, JSValue *out_proto)
+{
+    JSFunctionBytecode *b;
+    JSValue proto = JS_UNDEFINED;
+    JSValue ctor = JS_UNDEFINED;
+    JSValue parent_proto = JS_UNDEFINED;
+    JSObject *p;
+    JSVarRef **var_refs;
+    int i;
+
+    /* Get bytecode pointer */
+    b = JS_VALUE_GET_PTR(bfunc);
+
+    /* Set up parent prototype based on class flags */
+    if (class_flags & JS_DEFINE_CLASS_HAS_HERITAGE) {
+        if (JS_IsNull(parent_class)) {
+            parent_proto = JS_NULL;
+            parent_class = js_dup(ctx->function_proto);
+        } else {
+            if (!JS_IsConstructor(ctx, parent_class)) {
+                JS_ThrowTypeError(ctx, "parent class must be constructor");
+                goto fail;
+            }
+            parent_proto = JS_GetProperty(ctx, parent_class, JS_ATOM_prototype);
+            if (JS_IsException(parent_proto))
+                goto fail;
+            if (!JS_IsNull(parent_proto) && !JS_IsObject(parent_proto)) {
+                JS_ThrowTypeError(ctx, "parent prototype must be an object or null");
+                goto fail;
+            }
+        }
+    } else {
+        /* parent_class is JS_UNDEFINED in this case */
+        parent_proto = js_dup(ctx->class_proto[JS_CLASS_OBJECT]);
+        parent_class = js_dup(ctx->function_proto);
+    }
+
+    /* Create prototype object */
+    proto = JS_NewObjectProto(ctx, parent_proto);
+    if (JS_IsException(proto))
+        goto fail;
+
+    /* Create constructor function object with parent class as prototype */
+    ctor = JS_NewObjectProtoClass(ctx, parent_class, JS_CLASS_BYTECODE_FUNCTION);
+    if (JS_IsException(ctor))
+        goto fail;
+
+    /* Set up the function bytecode */
+    p = JS_VALUE_GET_OBJ(ctor);
+    p->u.func.function_bytecode = b;
+    b->header.ref_count++;  /* Increment bytecode refcount for this closure */
+    p->u.func.home_object = NULL;
+    p->u.func.var_refs = NULL;
+
+    /* Set up closure variables if needed */
+    if (b->closure_var_count) {
+        var_refs = js_mallocz(ctx, sizeof(var_refs[0]) * b->closure_var_count);
+        if (!var_refs)
+            goto fail;
+        p->u.func.var_refs = var_refs;
+
+        for (i = 0; i < b->closure_var_count; i++) {
+            JSClosureVar *cv = &b->closure_var[i];
+            JSVarRef *var_ref;
+
+            if (cv->is_local) {
+                if (cv->is_arg) {
+                    /* Argument capture - immediate detach */
+                    var_ref = js_malloc(ctx, sizeof(JSVarRef));
+                    if (!var_ref)
+                        goto fail;
+                    var_ref->header.ref_count = 1;
+                    var_ref->is_detached = true;
+                    JSValue val = (cv->var_idx < num_args) ? args[cv->var_idx] : JS_UNDEFINED;
+                    var_ref->value = js_dup(val);
+                    var_ref->pvalue = &var_ref->value;
+                    add_gc_object(ctx->rt, &var_ref->header, JS_GC_OBJ_TYPE_VAR_REF);
+                } else if (cv->var_idx < num_locals) {
+                    /* Local capture - use shared var_ref for deferred detachment */
+                    var_ref = get_frozen_local_var_ref(ctx, local_var_ref_list, locals, cv->var_idx);
+                    if (!var_ref)
+                        goto fail;
+                } else {
+                    /* var_idx >= num_locals: out of bounds - use detached undefined */
+                    var_ref = js_malloc(ctx, sizeof(JSVarRef));
+                    if (!var_ref)
+                        goto fail;
+                    var_ref->header.ref_count = 1;
+                    var_ref->is_detached = true;
+                    var_ref->value = JS_UNDEFINED;
+                    var_ref->pvalue = &var_ref->value;
+                    add_gc_object(ctx->rt, &var_ref->header, JS_GC_OBJ_TYPE_VAR_REF);
+                }
+            } else {
+                /* Parent closure reference */
+                if (cur_var_refs && cur_var_refs[cv->var_idx]) {
+                    var_ref = cur_var_refs[cv->var_idx];
+                    var_ref->header.ref_count++;
+                } else {
+                    var_ref = js_malloc(ctx, sizeof(JSVarRef));
+                    if (!var_ref)
+                        goto fail;
+                    var_ref->header.ref_count = 1;
+                    var_ref->is_detached = true;
+                    var_ref->value = JS_UNDEFINED;
+                    var_ref->pvalue = &var_ref->value;
+                    add_gc_object(ctx->rt, &var_ref->header, JS_GC_OBJ_TYPE_VAR_REF);
+                }
+            }
+            var_refs[i] = var_ref;
+        }
+    }
+
+    /* Set home object for super calls */
+    js_method_set_home_object(ctx, ctor, proto);
+
+    /* Mark as constructor */
+    JS_SetConstructorBit(ctx, ctor, true);
+
+    /* Set length property */
+    JS_DefinePropertyValue(ctx, ctor, JS_ATOM_length,
+                           js_int32(b->defined_arg_count),
+                           JS_PROP_CONFIGURABLE);
+
+    /* Set name property */
+    if (JS_DefineObjectName(ctx, ctor, class_name, JS_PROP_CONFIGURABLE) < 0)
+        goto fail;
+
+    /* Set constructor property on prototype */
+    if (JS_DefinePropertyValue(ctx, proto, JS_ATOM_constructor,
+                               js_dup(ctor),
+                               JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE | JS_PROP_THROW) < 0)
+        goto fail;
+
+    /* Set prototype property on constructor */
+    if (JS_DefinePropertyValue(ctx, ctor, JS_ATOM_prototype,
+                               js_dup(proto), JS_PROP_THROW) < 0)
+        goto fail;
+
+    JS_FreeValue(ctx, parent_proto);
+    if (class_flags & JS_DEFINE_CLASS_HAS_HERITAGE) {
+        /* parent_class was duped if null, need to free */
+    }
+
+    *out_ctor = ctor;
+    *out_proto = proto;
+    return 0;
+
+fail:
+    JS_FreeValue(ctx, parent_proto);
+    JS_FreeValue(ctx, proto);
+    JS_FreeValue(ctx, ctor);
+    *out_ctor = JS_UNDEFINED;
+    *out_proto = JS_UNDEFINED;
+    return -1;
+}
+
+int js_frozen_copy_data_properties(JSContext *ctx, JSValue dst, JSValue src, JSValue excluded)
+{
+    if (JS_IsNull(src) || JS_IsUndefined(src))
+        return 0;
+
+    JSObject *pexcl = NULL;
+    if (JS_VALUE_GET_TAG(excluded) == JS_TAG_OBJECT)
+        pexcl = JS_VALUE_GET_OBJ(excluded);
+
+    JSPropertyEnum *props;
+    uint32_t len;
+    if (JS_GetOwnPropertyNames(ctx, &props, &len, src, JS_GPN_STRING_MASK | JS_GPN_ENUM_ONLY) < 0)
+        return -1;
+
+    for (uint32_t i = 0; i < len; i++) {
+        /* Check if property should be excluded */
+        if (pexcl) {
+            int ret = JS_GetOwnPropertyInternal(ctx, NULL, pexcl, props[i].atom);
+            if (ret) {
+                if (ret < 0) {
+                    JS_FreePropertyEnum(ctx, props, len);
+                    return -1;
+                }
+                continue;  /* Property is in exclude list, skip it */
+            }
+        }
+        JSValue val = JS_GetProperty(ctx, src, props[i].atom);
+        if (JS_IsException(val)) {
+            JS_FreePropertyEnum(ctx, props, len);
+            return -1;
+        }
+        if (JS_SetProperty(ctx, dst, props[i].atom, val) < 0) {
+            JS_FreePropertyEnum(ctx, props, len);
+            return -1;
+        }
+    }
+    JS_FreePropertyEnum(ctx, props, len);
+    return 0;
+}
+
+/* Home object registry for frozen C functions */
+#define FROZEN_HOME_OBJECT_REGISTRY_SIZE 256
+static struct {
+    void *func_ptr;
+    JSValue home_object;
+} frozen_home_object_registry[FROZEN_HOME_OBJECT_REGISTRY_SIZE];
+static int frozen_home_object_count = 0;
+
+void JS_SetFrozenHomeObject(JSContext *ctx, void *func_ptr, JSValue home_object)
+{
+    (void)ctx;
+    for (int i = 0; i < frozen_home_object_count; i++) {
+        if (frozen_home_object_registry[i].func_ptr == func_ptr) {
+            frozen_home_object_registry[i].home_object = home_object;
+            return;
+        }
+    }
+    if (frozen_home_object_count < FROZEN_HOME_OBJECT_REGISTRY_SIZE) {
+        frozen_home_object_registry[frozen_home_object_count].func_ptr = func_ptr;
+        frozen_home_object_registry[frozen_home_object_count].home_object = home_object;
+        frozen_home_object_count++;
+    }
+}
+
+JSValue JS_GetFrozenHomeObject(JSContext *ctx, void *func_ptr)
+{
+    (void)ctx;
+    for (int i = 0; i < frozen_home_object_count; i++) {
+        if (frozen_home_object_registry[i].func_ptr == func_ptr) {
+            return frozen_home_object_registry[i].home_object;
+        }
+    }
+    return JS_UNDEFINED;
+}
+
+/* import.meta wrapper */
+JSValue JS_GetImportMetaCurrent(JSContext *ctx)
+{
+    return js_import_meta(ctx);
+}
+
+/* Mapped arguments (simplified version for frozen code) */
+JSValue JS_NewMappedArgumentsSimple(JSContext *ctx, int argc, JSValueConst *argv,
+                                    JSValue callee)
+{
+    JSValue args = js_build_arguments(ctx, argc, argv);
+    if (!JS_IsException(args)) {
+        JS_DefinePropertyValue(ctx, args, JS_ATOM_callee, js_dup(callee),
+                               JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE);
+    }
+    return args;
+}
+
+/* ========================================================================
+ * Frozen Inline Cache (IC) for property access
+ *
+ * Each IC slot caches (shape, offset, atom) for a specific property access
+ * site. On cache hit (object has same shape as cached), we read the property
+ * directly from obj->prop[offset] in O(1) without any hash lookup.
+ * On miss, we resolve the atom (once), do a hash lookup, and update the cache.
+ * ======================================================================== */
+
+JSValue js_frozen_ic_load(JSContext *ctx, JSValueConst obj,
+                          void **ic_shape, uint32_t *ic_offset,
+                          uint32_t *ic_atom, const char *name)
+{
+    if (likely(JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT)) {
+        JSObject *p = JS_VALUE_GET_OBJ(obj);
+
+        /* Fast path: shape matches cache → direct property read */
+        if (likely(p->shape == (JSShape *)*ic_shape)) {
+            return js_dup(p->prop[*ic_offset].u.value);
+        }
+    }
+
+    /* Resolve atom once per call site (saves JS_NewAtom + JS_FreeAtom on every call) */
+    JSAtom atom = (JSAtom)*ic_atom;
+    if (unlikely(atom == 0)) {
+        atom = JS_NewAtom(ctx, name);
+        *ic_atom = (uint32_t)atom;
+
+        /* First access: try to populate IC cache for future fast-path hits */
+        if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {
+            JSObject *p = JS_VALUE_GET_OBJ(obj);
+            JSShapeProperty *prs;
+            JSProperty *pr;
+            prs = find_own_property(&pr, p, atom);
+            if (prs && likely((prs->flags & JS_PROP_TMASK) == JS_PROP_NORMAL)) {
+                *ic_shape = p->shape;
+                *ic_offset = (uint32_t)(prs - get_shape_prop(p->shape));
+                return js_dup(pr->u.value);
+            }
+        }
+    }
+
+    /* Use cached atom for standard lookup (avoids JS_NewAtom/JS_FreeAtom per call) */
+    return JS_GetProperty(ctx, obj, atom);
+}
+
+/* Private field wrappers */
+JSValue JS_NewPrivateSymbol(JSContext *ctx, JSAtom atom)
+{
+    return JS_NewSymbolFromAtom(ctx, atom, JS_ATOM_TYPE_PRIVATE);
+}
+
+int JS_FrozenCheckBrand(JSContext *ctx, JSValue obj, JSValue func)
+{
+    return JS_CheckBrand(ctx, obj, func);
+}
+
+int JS_FrozenAddBrand(JSContext *ctx, JSValue obj, JSValue func)
+{
+    return JS_AddBrand(ctx, obj, func);
+}
+
+int js_frozen_private_in(JSContext *ctx, JSValue *sp)
+{
+    return js_operator_private_in(ctx, sp);
+}
+
+/* Private field access wrappers for frozen interpreter */
+JSValue JS_FrozenGetPrivateField(JSContext *ctx, JSValueConst obj, JSValueConst name)
+{
+    return JS_GetPrivateField(ctx, obj, name);
+}
+
+int JS_FrozenSetPrivateField(JSContext *ctx, JSValueConst obj, JSValueConst name, JSValue val)
+{
+    return JS_SetPrivateField(ctx, obj, name, val);
+}
+
+int JS_FrozenDefinePrivateField(JSContext *ctx, JSValueConst obj, JSValue name, JSValue val)
+{
+    return JS_DefinePrivateField(ctx, obj, name, val);
+}
+
+/* Get constant pool from a bytecode function - for frozen interpreter */
+JSValue* JS_GetFunctionConstantPool(JSContext *ctx, JSValueConst func_obj, int *pcount)
+{
+    JSObject *p;
+    JSFunctionBytecode *b;
+
+    if (JS_VALUE_GET_TAG(func_obj) != JS_TAG_OBJECT)
+        return NULL;
+
+    p = JS_VALUE_GET_OBJ(func_obj);
+    if (!js_class_has_bytecode(p->class_id))
+        return NULL;
+
+    b = p->u.func.function_bytecode;
+    if (!b || !b->cpool)
+        return NULL;
+
+    if (pcount)
+        *pcount = b->cpool_count;
+    return b->cpool;
+}
+
 static JSValue JS_IteratorGetCompleteValue(JSContext *ctx, JSValue obj,
                                            int *pdone)
 {
@@ -15853,7 +17016,7 @@ static __exception int JS_CopyDataProperties(JSContext *ctx,
 }
 
 /* only valid inside C functions */
-static JSValueConst JS_GetActiveFunction(JSContext *ctx)
+JSValueConst JS_GetActiveFunction(JSContext *ctx)
 {
     return ctx->rt->current_stack_frame->cur_func;
 }
@@ -15955,15 +17118,16 @@ static const uint16_t func_kind_to_class_id[] = {
     [JS_FUNC_ASYNC_GENERATOR] = JS_CLASS_ASYNC_GENERATOR_FUNCTION,
 };
 
-static JSValue js_closure(JSContext *ctx, JSValue bfunc,
-                          JSVarRef **cur_var_refs,
-                          JSStackFrame *sf)
+JSValue js_closure(JSContext *ctx, JSValue bfunc,
+                   JSVarRef **cur_var_refs,
+                   JSStackFrame *sf)
 {
     JSFunctionBytecode *b;
     JSValue func_obj;
     JSAtom name_atom;
 
     b = JS_VALUE_GET_PTR(bfunc);
+
     func_obj = JS_NewObjectClass(ctx, func_kind_to_class_id[b->func_kind]);
     if (JS_IsException(func_obj)) {
         JS_FreeValue(ctx, bfunc);
@@ -16383,6 +17547,7 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
 
     if (js_poll_interrupts(caller_ctx))
         return JS_EXCEPTION;
+
     if (unlikely(JS_VALUE_GET_TAG(func_obj) != JS_TAG_OBJECT)) {
         if (flags & JS_CALL_FLAG_GENERATOR) {
             JSAsyncFunctionState *s = JS_VALUE_GET_PTR(func_obj);
@@ -16422,6 +17587,66 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
     }
     b = p->u.func.function_bytecode;
 
+    /* Frozen function dispatch with inline caching in JSFunctionBytecode.frozen_impl */
+    /* NULL = not looked up yet, (void*)1 = miss cached, other = frozen function pointer */
+    #define FROZEN_IMPL_NONE ((void *)1)
+    {
+        void *impl = b->frozen_impl;
+        if (likely(impl != NULL)) {
+            /* Fast path: already cached (hit or miss) */
+            if (impl != FROZEN_IMPL_NONE) {
+                /* Cached hit - call frozen function directly */
+                typedef JSValue (*FrozenFn)(JSContext *, JSValue, int, JSValue *,
+                                           JSVarRef **, int, JSValue *);
+                FrozenFn fn = (FrozenFn)impl;
+                return fn(caller_ctx, this_obj, argc, (JSValue *)argv,
+                         p->u.func.var_refs, b->closure_var_count, b->cpool);
+            }
+            /* Cached miss - skip to bytecode execution */
+        } else {
+            /* First call: do full lookup and cache result */
+            JSValue frozen_result;
+            JSVarRef **dispatch_var_refs = p->u.func.var_refs;
+
+            /* Try bytecode pointer lookup first */
+            if (frozen_dispatch_lookup_bytecode(caller_ctx, (void *)b,
+                                                this_obj, argc, (JSValue *)argv,
+                                                dispatch_var_refs, b->closure_var_count,
+                                                b->cpool, &frozen_result)) {
+                /* Cache the frozen function pointer for future calls */
+                void *fn_ptr = frozen_dispatch_get_impl((void *)b);
+                if (fn_ptr) b->frozen_impl = fn_ptr;
+                return frozen_result;
+            }
+
+            /* Fallback: name@line_num lookup */
+            if (b->func_name != JS_ATOM_NULL && b->line_num > 0) {
+                char func_name_buf[64];
+                char dispatch_key_buf[128];
+                const char *func_name_str = JS_AtomGetStr(caller_ctx, func_name_buf,
+                                                          sizeof(func_name_buf), b->func_name);
+                if (func_name_str && func_name_str[0]) {
+                    snprintf(dispatch_key_buf, sizeof(dispatch_key_buf), "%s@%d",
+                             func_name_str, b->line_num);
+                    if (frozen_dispatch_lookup(caller_ctx, dispatch_key_buf,
+                                               this_obj, argc, (JSValue *)argv,
+                                               dispatch_var_refs, b->closure_var_count,
+                                               b->cpool, (void *)b, &frozen_result)) {
+                        /* Cache the frozen function pointer for future calls */
+                        void *fn_ptr = frozen_dispatch_get_impl((void *)b);
+                        if (fn_ptr) b->frozen_impl = fn_ptr;
+                        return frozen_result;
+                    }
+                }
+            }
+
+            /* Neither lookup found a frozen function - cache the miss */
+            b->frozen_impl = FROZEN_IMPL_NONE;
+        }
+    }
+    #undef FROZEN_IMPL_NONE
+
+
     if (unlikely(argc < b->arg_count || (flags & JS_CALL_FLAG_COPY_ARGV))) {
         arg_allocated_size = b->arg_count;
     } else {
@@ -16781,7 +18006,8 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
 
         CASE(OP_fclosure):
             {
-                JSValue bfunc = js_dup(b->cpool[get_u32(pc)]);
+                uint32_t _fcl_idx = get_u32(pc);
+                JSValue bfunc = js_dup(b->cpool[_fcl_idx]);
                 pc += 4;
                 *sp++ = js_closure(ctx, bfunc, var_refs, sf);
                 if (unlikely(JS_IsException(sp[-1])))
@@ -17265,7 +18491,9 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
         CASE(OP_set_arg1): set_value(ctx, &arg_buf[1], js_dup(sp[-1])); BREAK;
         CASE(OP_set_arg2): set_value(ctx, &arg_buf[2], js_dup(sp[-1])); BREAK;
         CASE(OP_set_arg3): set_value(ctx, &arg_buf[3], js_dup(sp[-1])); BREAK;
-        CASE(OP_get_var_ref0): *sp++ = js_dup(*var_refs[0]->pvalue); BREAK;
+        CASE(OP_get_var_ref0):
+            *sp++ = js_dup(*var_refs[0]->pvalue);
+            BREAK;
         CASE(OP_get_var_ref1): *sp++ = js_dup(*var_refs[1]->pvalue); BREAK;
         CASE(OP_get_var_ref2): *sp++ = js_dup(*var_refs[2]->pvalue); BREAK;
         CASE(OP_get_var_ref3): *sp++ = js_dup(*var_refs[3]->pvalue); BREAK;
@@ -17281,11 +18509,9 @@ static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
         CASE(OP_get_var_ref):
             {
                 int idx;
-                JSValue val;
                 idx = get_u16(pc);
                 pc += 2;
-                val = *var_refs[idx]->pvalue;
-                sp[0] = js_dup(val);
+                sp[0] = js_dup(*var_refs[idx]->pvalue);
                 sp++;
             }
             BREAK;
@@ -29006,7 +30232,7 @@ JSValue JS_LoadModule(JSContext *ctx, const char *basename,
     return promise;
 }
 
-static JSValue js_dynamic_import_job(JSContext *ctx,
+JSValue js_dynamic_import_job(JSContext *ctx,
                                      int argc, JSValueConst *argv)
 {
     JSValueConst *resolving_funcs = argv;
@@ -29041,7 +30267,7 @@ static JSValue js_dynamic_import_job(JSContext *ctx,
     return JS_UNDEFINED;
 }
 
-static JSValue js_dynamic_import(JSContext *ctx, JSValueConst specifier)
+JSValue js_dynamic_import(JSContext *ctx, JSValueConst specifier)
 {
     JSAtom basename;
     JSValue promise, resolving_funcs[2], basename_val;
@@ -33979,6 +35205,7 @@ static JSValue js_create_function(JSContext *ctx, JSFunctionDef *fd)
     b->has_prototype = fd->has_prototype;
     b->has_simple_parameter_list = fd->has_simple_parameter_list;
     b->is_strict_mode = fd->is_strict_mode;
+    b->has_use_strict = fd->has_use_strict;  /* EdgeBox: track explicit "use strict" */
     b->is_derived_class_constructor = fd->is_derived_class_constructor;
     b->func_kind = fd->func_kind;
     b->need_home_object = (fd->home_object_var_idx >= 0 ||
@@ -35616,6 +36843,7 @@ static int JS_WriteFunctionTag(BCWriterState *s, JSValueConst obj)
     assert(idx <= 16);
     bc_put_u16(s, flags);
     bc_put_u8(s, b->is_strict_mode);
+    bc_put_u8(s, b->has_use_strict);  /* EdgeBox: track explicit "use strict" for proper 'this' handling */
     bc_put_atom(s, b->func_name);
 
     bc_put_leb128(s, b->arg_count);
@@ -36552,6 +37780,9 @@ static JSValue JS_ReadFunctionTag(BCReaderState *s)
     if (bc_get_u8(s, &v8))
         goto fail;
     bc.is_strict_mode = (v8 > 0);
+    if (bc_get_u8(s, &v8))
+        goto fail;
+    bc.has_use_strict = (v8 > 0);  /* EdgeBox: track explicit "use strict" */
     if (bc_get_atom(s, &bc.func_name))
         goto fail;
     if (bc_get_leb128_u16(s, &bc.arg_count))
diff --git a/quickjs.h b/quickjs.h
index 3165256..4892a17 100644
--- a/quickjs.h
+++ b/quickjs.h
@@ -443,6 +443,7 @@ JS_EXTERN void JS_SetDumpFlags(JSRuntime *rt, uint64_t flags);
 JS_EXTERN uint64_t JS_GetDumpFlags(JSRuntime *rt);
 JS_EXTERN size_t JS_GetGCThreshold(JSRuntime *rt);
 JS_EXTERN void JS_SetGCThreshold(JSRuntime *rt, size_t gc_threshold);
+JS_EXTERN void JS_SetDeferFree(JSRuntime *rt, int enable);
 /* use 0 to disable maximum stack size check */
 JS_EXTERN void JS_SetMaxStackSize(JSRuntime *rt, size_t stack_size);
 /* should be called when changing thread to update the stack top value
@@ -851,6 +852,7 @@ JS_EXTERN bool JS_IsWeakMap(JSValueConst val);
 JS_EXTERN bool JS_IsDataView(JSValueConst val);
 
 JS_EXTERN JSValue JS_NewArray(JSContext *ctx);
+JS_EXTERN JSValue JS_NewArguments(JSContext *ctx, int argc, JSValueConst *argv);
 // takes ownership of the values
 JS_EXTERN JSValue JS_NewArrayFrom(JSContext *ctx, int count,
                                   const JSValue *values);
@@ -1124,6 +1126,9 @@ JS_EXTERN JSAtom JS_GetScriptOrModuleName(JSContext *ctx, int n_stack_levels);
 /* only exported for os.Worker() */
 JS_EXTERN JSValue JS_LoadModule(JSContext *ctx, const char *basename,
                                 const char *filename);
+/* exported for frozen interpreter dynamic import support */
+JS_EXTERN JSValue js_dynamic_import(JSContext *ctx, JSValueConst specifier);
+JS_EXTERN JSValue js_dynamic_import_job(JSContext *ctx, int argc, JSValueConst *argv);
 
 /* C function definition */
 typedef enum JSCFunctionEnum {  /* XXX: should rename for namespace isolation */
@@ -1291,6 +1296,105 @@ JS_EXTERN const char* JS_GetVersion(void);
 /* Integration point for quickjs-libc.c, not for public use. */
 JS_EXTERN uintptr_t js_std_cmd(int cmd, ...);
 
+/* Frozen interpreter support - iterator helpers */
+JS_EXTERN int js_frozen_for_in_start(JSContext *ctx, JSValue *sp);
+JS_EXTERN int js_frozen_for_in_next(JSContext *ctx, JSValue *sp);
+JS_EXTERN int js_frozen_for_of_start(JSContext *ctx, JSValue *sp, int is_async);
+JS_EXTERN int js_frozen_for_of_next(JSContext *ctx, JSValue *sp, int offset);
+
+/* Frozen interpreter support - closure variable access */
+typedef struct JSVarRef JSVarRef;
+JS_EXTERN JSValue js_frozen_get_var_ref(JSContext *ctx, JSVarRef **var_refs, int idx);
+JS_EXTERN void js_frozen_set_var_ref(JSContext *ctx, JSVarRef **var_refs, int idx, JSValue val);
+JS_EXTERN JSValue js_frozen_get_var_ref_safe(JSContext *ctx, JSVarRef **var_refs, int idx, int var_refs_count);
+JS_EXTERN void js_frozen_set_var_ref_safe(JSContext *ctx, JSVarRef **var_refs, int idx, int var_refs_count, JSValue val);
+
+/* Frozen interpreter support - constant pool access for nested function registration */
+JS_EXTERN int js_frozen_get_cpool_info(void *bytecode_ptr, int *cpool_count_out, void **cpool_out);
+JS_EXTERN void *js_frozen_get_cpool_func_bytecode(void *cpool, int idx);
+JS_EXTERN int js_frozen_get_bytecode_name_line(JSContext *ctx, void *bytecode_ptr, char *name_buf, int name_buf_size, int *line_out);
+
+/* Frozen interpreter support - fast call bypass for frozen functions */
+JS_EXTERN int js_frozen_try_call(JSContext *ctx, JSValueConst func_obj, JSValueConst this_obj,
+                                 int argc, JSValueConst *argv, JSValue *result_out);
+JS_EXTERN void js_frozen_try_call_stats(void);
+JS_EXTERN void js_frozen_dump_offsets(void);
+
+/* Frozen interpreter support - iterator methods */
+JS_EXTERN JSValue js_frozen_get_iterator(JSContext *ctx, JSValue obj, int is_async);
+JS_EXTERN JSValue js_frozen_iterator_next(JSContext *ctx, JSValue iter, int *done);
+JS_EXTERN int js_frozen_iterator_close(JSContext *ctx, JSValue iter, int completion_type);
+JS_EXTERN JSValue js_frozen_iterator_get_value_done(JSContext *ctx, JSValue result, int *done);
+
+/* Frozen interpreter support - object operations */
+JS_EXTERN int js_frozen_set_field(JSContext *ctx, JSValue obj, const char *prop, JSValue val);
+JS_EXTERN JSValue js_frozen_to_object(JSContext *ctx, JSValue val);
+JS_EXTERN JSValue js_frozen_get_length(JSContext *ctx, JSValue obj);
+JS_EXTERN JSValue js_frozen_to_prop_key(JSContext *ctx, JSValue val);
+JS_EXTERN int js_frozen_set_proto(JSContext *ctx, JSValue obj, JSValue proto);
+JS_EXTERN JSValue js_frozen_exec_opcode(JSContext *ctx, int opcode, uint32_t operand,
+                                         JSValue *stack, int *sp, JSValue *locals, int local_count);
+JS_EXTERN int js_frozen_copy_data_properties(JSContext *ctx, JSValue dst, JSValue src, JSValue excluded);
+
+/* Frozen interpreter support - special object types */
+JS_EXTERN void JS_SetFrozenHomeObject(JSContext *ctx, void *func_ptr, JSValue home_object);
+JS_EXTERN JSValue JS_GetFrozenHomeObject(JSContext *ctx, void *func_ptr);
+JS_EXTERN JSValue JS_GetImportMetaCurrent(JSContext *ctx);
+JS_EXTERN JSValue JS_NewMappedArgumentsSimple(JSContext *ctx, int argc, JSValueConst *argv,
+                                              JSValue callee);
+
+/* Frozen interpreter support - private fields */
+JS_EXTERN JSValue JS_NewPrivateSymbol(JSContext *ctx, JSAtom atom);
+JS_EXTERN int JS_FrozenCheckBrand(JSContext *ctx, JSValue obj, JSValue func);
+JS_EXTERN int JS_FrozenAddBrand(JSContext *ctx, JSValue obj, JSValue func);
+JS_EXTERN int js_frozen_private_in(JSContext *ctx, JSValue *sp);
+JS_EXTERN JSValue JS_FrozenGetPrivateField(JSContext *ctx, JSValueConst obj, JSValueConst name);
+JS_EXTERN int JS_FrozenSetPrivateField(JSContext *ctx, JSValueConst obj, JSValueConst name, JSValue val);
+JS_EXTERN int JS_FrozenDefinePrivateField(JSContext *ctx, JSValueConst obj, JSValue name, JSValue val);
+
+/* Frozen interpreter support - constant pool access */
+JS_EXTERN JSValue* JS_GetFunctionConstantPool(JSContext *ctx, JSValueConst func_obj, int *pcount);
+
+/* Frozen interpreter support - bytecode pointer for dispatch registration */
+JS_EXTERN void *js_get_function_bytecode_ptr(JSValueConst val);
+
+/* Frozen interpreter support - closure creation */
+typedef struct JSStackFrame JSStackFrame;
+JS_EXTERN JSValue js_closure(JSContext *ctx, JSValue bfunc, JSVarRef **cur_var_refs, JSStackFrame *sf);
+/* Create closure from frozen code (no stack frame, uses locals/args arrays directly) */
+JS_EXTERN JSValue js_frozen_create_closure(JSContext *ctx, JSValue bfunc,
+                                           JSVarRef **cur_var_refs,
+                                           JSValue *locals, int num_locals,
+                                           JSValue *args, int num_args);
+/* V2 closure creation with shared var_refs for function hoisting */
+JS_EXTERN void js_frozen_var_ref_list_init(struct list_head *list);
+JS_EXTERN void js_frozen_var_ref_list_detach(JSContext *ctx, struct list_head *list);
+JS_EXTERN JSValue js_frozen_create_closure_v2(JSContext *ctx, JSValue bfunc,
+                                              JSVarRef **cur_var_refs,
+                                              struct list_head *local_var_ref_list,
+                                              JSValue *locals, int num_locals,
+                                              JSValue *args, int num_args);
+/* Create class constructor and prototype from frozen code (for define_class opcode) */
+JS_EXTERN int js_frozen_define_class(JSContext *ctx, JSValue bfunc, JSValue parent_class,
+                                     int class_flags, JSAtom class_name,
+                                     JSVarRef **cur_var_refs,
+                                     struct list_head *local_var_ref_list,
+                                     JSValue *locals, int num_locals,
+                                     JSValue *args, int num_args,
+                                     JSValue *out_ctor, JSValue *out_proto);
+
+/* Frozen interpreter support - function name setting */
+JS_EXTERN int JS_DefineObjectName(JSContext *ctx, JSValue obj, JSAtom name, int flags);
+JS_EXTERN int JS_DefineObjectNameComputed(JSContext *ctx, JSValue obj, JSValue name, int flags);
+
+/* Frozen interpreter support - method home object for super calls */
+JS_EXTERN void JS_SetHomeObject(JSContext *ctx, JSValue func_obj, JSValue home_obj);
+
+/* Frozen interpreter support - inline cache for property access */
+JS_EXTERN JSValue js_frozen_ic_load(JSContext *ctx, JSValueConst obj,
+                                    void **ic_shape, uint32_t *ic_offset,
+                                    uint32_t *ic_atom, const char *name);
+
 #undef JS_EXTERN
 #undef js_force_inline
