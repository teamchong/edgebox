//! SSA-based Code Generator
//!
//! Uses symbolic stack analysis to generate optimal C code.
//! Key optimizations:
//! - Arguments extracted as int32 at function entry
//! - Arithmetic done with native int32
//! - Self-recursive calls are direct (no runtime marker check)
//! - No JSValue stack simulation

const std = @import("std");
const opcodes = @import("opcodes.zig");
const parser = @import("bytecode_parser.zig");
const cfg_mod = @import("cfg_builder.zig");
const sym = @import("symbolic_stack.zig");

const Opcode = opcodes.Opcode;
const Instruction = parser.Instruction;
const CFG = cfg_mod.CFG;
const BasicBlock = cfg_mod.BasicBlock;
const Allocator = std.mem.Allocator;
const SymbolicStack = sym.SymbolicStack;
const SymValue = sym.SymValue;

pub const CodeGenOptions = struct {
    func_name: []const u8 = "frozen_func",
    debug_comments: bool = false,
    arg_count: u16 = 0,
    var_count: u16 = 0,
};

pub const SSACodeGen = struct {
    allocator: Allocator,
    cfg: *const CFG,
    options: CodeGenOptions,
    output: std.ArrayListUnmanaged(u8),

    // Value naming
    temp_counter: u32 = 0,
    result_counter: u32 = 0,

    pub fn init(allocator: Allocator, cfg: *const CFG, options: CodeGenOptions) SSACodeGen {
        return .{
            .allocator = allocator,
            .cfg = cfg,
            .options = options,
            .output = .{},
        };
    }

    pub fn deinit(self: *SSACodeGen) void {
        self.output.deinit(self.allocator);
    }

    fn write(self: *SSACodeGen, str: []const u8) !void {
        try self.output.appendSlice(self.allocator, str);
    }

    fn print(self: *SSACodeGen, comptime fmt: []const u8, args: anytype) !void {
        var buf: [16384]u8 = undefined;
        const slice = std.fmt.bufPrint(&buf, fmt, args) catch return error.FormatError;
        try self.output.appendSlice(self.allocator, slice);
    }

    pub fn generate(self: *SSACodeGen) ![]const u8 {
        // Emit file header
        try self.emitHeader();

        // Emit optimized function
        try self.emitFunction();

        // Emit init function
        try self.emitInit();

        return self.output.items;
    }

    fn emitHeader(self: *SSACodeGen) !void {
        try self.print(
            \\/*
            \\ * Frozen function: {s}
            \\ * Generated by edgebox-freeze (SSA codegen)
            \\ *
            \\ * Optimizations:
            \\ * - Native int32 arithmetic (no JSValue boxing in hot path)
            \\ * - Direct recursive calls (no runtime dispatch)
            \\ * - No stack simulation
            \\ */
            \\
            \\#include "quickjs.h"
            \\#include <stdint.h>
            \\
            \\#ifndef likely
            \\#define likely(x) __builtin_expect(!!(x), 1)
            \\#endif
            \\#ifndef unlikely
            \\#define unlikely(x) __builtin_expect(!!(x), 0)
            \\#endif
            \\
            \\static JSValue {s}(JSContext *ctx, JSValueConst this_val,
            \\                   int argc, JSValueConst *argv);
            \\
            \\
        , .{ self.options.func_name, self.options.func_name });
    }

    fn emitFunction(self: *SSACodeGen) !void {
        const fname = self.options.func_name;
        const arg_count = self.options.arg_count;

        // Function signature
        try self.print(
            \\static JSValue {s}(JSContext *ctx, JSValueConst this_val,
            \\                   int argc, JSValueConst *argv)
            \\{{
            \\
        , .{fname});

        // Declare argument variables (extracted as int32)
        if (arg_count > 0) {
            try self.write("    /* Arguments as native int32 */\n");
            var i: u16 = 0;
            while (i < arg_count) : (i += 1) {
                try self.print("    int32_t n{d};\n", .{i});
            }
            try self.write("\n");

            // Extract arguments with fast path
            i = 0;
            while (i < arg_count) : (i += 1) {
                try self.print(
                    \\    if (likely(argc > {d} && JS_VALUE_GET_TAG(argv[{d}]) == JS_TAG_INT)) {{
                    \\        n{d} = JS_VALUE_GET_INT(argv[{d}]);
                    \\    }} else {{
                    \\        if (argc <= {d}) return JS_UNDEFINED;
                    \\        if (JS_ToInt32(ctx, &n{d}, argv[{d}])) return JS_EXCEPTION;
                    \\    }}
                    \\
                , .{ i, i, i, i, i, i, i });
            }
            try self.write("\n");
        }

        // Process each basic block
        for (self.cfg.blocks.items, 0..) |*block, idx| {
            try self.emitBlock(block, idx);
        }

        try self.write("}\n\n");
    }

    fn emitBlock(self: *SSACodeGen, block: *const BasicBlock, block_idx: usize) !void {
        // First, analyze the block symbolically to understand data flow
        var stack = try SymbolicStack.init(self.allocator, self.options.var_count);
        defer stack.deinit();

        // Add empty statement after label (required for C99 when declaration follows)
        try self.print("block_{d}:;\n", .{block_idx});

        // Process instructions
        var i: usize = 0;
        while (i < block.instructions.len) : (i += 1) {
            const instr = block.instructions[i];

            // Before processing, check for patterns we can optimize
            if (self.tryEmitPattern(block.instructions[i..], &stack, &i)) |emitted| {
                if (emitted) continue;
            } else |_| {}

            // Otherwise emit single instruction
            try self.emitInstruction(instr, &stack, block_idx);
            stack.processInstruction(instr) catch {};
        }
    }

    /// Try to emit an optimized pattern (e.g., self-recursive call)
    /// Returns true if a pattern was matched and emitted
    fn tryEmitPattern(self: *SSACodeGen, remaining: []const Instruction, stack: *SymbolicStack, idx: *usize) !bool {
        if (remaining.len < 2) return false;

        const first = remaining[0];

        // Pattern: get_var_ref0, [arg setup], call -> direct recursion
        if (first.opcode == .get_var_ref0 or first.opcode == .get_var_ref1 or
            first.opcode == .get_var_ref2 or first.opcode == .get_var_ref3)
        {
            // Find the call instruction
            var call_idx: usize = 1;
            var argc: u16 = 0;
            var found_call = false;

            while (call_idx < remaining.len) : (call_idx += 1) {
                const instr = remaining[call_idx];
                switch (instr.opcode) {
                    .call0 => {
                        argc = 0;
                        found_call = true;
                        break;
                    },
                    .call1 => {
                        argc = 1;
                        found_call = true;
                        break;
                    },
                    .call2 => {
                        argc = 2;
                        found_call = true;
                        break;
                    },
                    .call3 => {
                        argc = 3;
                        found_call = true;
                        break;
                    },
                    // These are part of argument setup
                    .get_arg0, .get_arg1, .get_arg2, .get_arg3, .get_arg,
                    .push_0, .push_1, .push_2, .push_3, .push_i8, .push_i16, .push_i32,
                    .sub, .add, .mul,
                    => continue,
                    // Anything else breaks the pattern
                    else => break,
                }
            }

            if (found_call) {
                try self.emitDirectRecursion(remaining[1..call_idx], argc, stack);

                // Skip all instructions we processed
                idx.* += call_idx;
                return true;
            }
        }

        return false;
    }

    /// Emit a direct recursive call
    fn emitDirectRecursion(self: *SSACodeGen, arg_setup: []const Instruction, argc: u16, stack: *SymbolicStack) !void {
        const fname = self.options.func_name;
        const result_id = self.result_counter;
        self.result_counter += 1;

        if (self.options.debug_comments) {
            try self.write("    /* Direct recursive call */\n");
        }

        // Build argument expression from instructions
        var arg_expr_buf: [256]u8 = undefined;
        const arg_expr = try self.buildArgExpr(arg_setup, &arg_expr_buf);

        // Generate direct call - use unique variable names to avoid conflicts
        try self.print(
            \\    JSValue _arg{d} = JS_NewInt32(ctx, {s});
            \\    JSValue _res{d} = {s}(ctx, JS_UNDEFINED, {d}, &_arg{d});
            \\    if (unlikely(JS_IsException(_res{d}))) return JS_EXCEPTION;
            \\    int32_t r{d} = JS_VALUE_GET_INT(_res{d});
            \\
        , .{ result_id, arg_expr, result_id, fname, argc, result_id, result_id, result_id, result_id });

        // Update symbolic stack - push result
        const val_id = try stack.newValue(.int, .{ .call = .{
            .func = 0,
            .args = &.{},
        } });
        try stack.push(val_id);
    }

    /// Build an argument expression string from argument setup instructions
    fn buildArgExpr(self: *SSACodeGen, instructions: []const Instruction, buf: []u8) ![]const u8 {
        _ = self;
        var base: []const u8 = "n0";
        var op: ?[]const u8 = null;
        var constant: i32 = 0;

        for (instructions) |instr| {
            switch (instr.opcode) {
                .get_arg0 => base = "n0",
                .get_arg1 => base = "n1",
                .get_arg2 => base = "n2",
                .get_arg3 => base = "n3",
                .push_0 => constant = 0,
                .push_1 => constant = 1,
                .push_2 => constant = 2,
                .push_3 => constant = 3,
                .push_i8 => constant = instr.operand.i8,
                .sub => op = "-",
                .add => op = "+",
                .mul => op = "*",
                else => {},
            }
        }

        if (op) |o| {
            return std.fmt.bufPrint(buf, "{s} {s} {d}", .{ base, o, constant });
        } else {
            return std.fmt.bufPrint(buf, "{s}", .{base});
        }
    }

    /// Emit a single instruction
    fn emitInstruction(self: *SSACodeGen, instr: Instruction, stack: *SymbolicStack, _: usize) !void {
        const info = instr.getInfo();

        if (self.options.debug_comments) {
            try self.print("    /* {d}: {s} */\n", .{ instr.pc, info.name });
        }

        switch (instr.opcode) {
            // Comparison
            .lt => {
                // Get values being compared
                // For simple case: n0 < constant
                try self.write("    if (");
                // Emit comparison based on symbolic stack state
                try self.emitComparison(stack, "<");
                try self.write(") {\n");
            },

            .lte => {
                try self.write("    if (");
                try self.emitComparison(stack, "<=");
                try self.write(") {\n");
            },

            .gt => {
                try self.write("    if (");
                try self.emitComparison(stack, ">");
                try self.write(") {\n");
            },

            .gte => {
                try self.write("    if (");
                try self.emitComparison(stack, ">=");
                try self.write(") {\n");
            },

            // Conditional branches
            .if_false, .if_false8 => {
                const target = instr.getJumpTarget() orelse 0;
                const target_block = self.cfg.pc_to_block.get(target) orelse 0;
                try self.print("    }} else goto block_{d};\n", .{target_block});
            },

            .if_true, .if_true8 => {
                const target = instr.getJumpTarget() orelse 0;
                const target_block = self.cfg.pc_to_block.get(target) orelse 0;
                try self.print("        goto block_{d};\n    }}\n", .{target_block});
            },

            // Return - base case
            .@"return" => {
                // Check what we're returning
                if (stack.peek()) |top_id| {
                    if (stack.getValue(top_id)) |val| {
                        switch (val.origin) {
                            .arg => |idx| {
                                try self.print("        return JS_NewInt32(ctx, n{d});\n", .{idx});
                            },
                            .binop => {
                                // Result of add - combine the two recursive results
                                try self.print("        return JS_NewInt32(ctx, r{d} + r{d});\n", .{ self.result_counter - 2, self.result_counter - 1 });
                            },
                            else => {
                                try self.write("        return JS_UNDEFINED; /* TODO */\n");
                            },
                        }
                    }
                } else {
                    try self.write("        return JS_UNDEFINED;\n");
                }
            },

            .return_undef => {
                try self.write("    return JS_UNDEFINED;\n");
            },

            // Unconditional jump
            .goto, .goto8, .goto16 => {
                const target = instr.getJumpTarget() orelse 0;
                const target_block = self.cfg.pc_to_block.get(target) orelse 0;
                try self.print("    goto block_{d};\n", .{target_block});
            },

            // Add - combine recursive results
            .add => {
                // The add before return combines r0 + r1
                // We'll handle this in the return emission
            },

            // Skip these - handled elsewhere
            .get_arg0, .get_arg1, .get_arg2, .get_arg3,
            .push_0, .push_1, .push_2, .push_3, .push_i8,
            .sub,
            .get_var_ref0, .get_var_ref1, .get_var_ref2, .get_var_ref3,
            => {},

            else => {
                try self.print("    /* TODO: {s} */\n", .{info.name});
            },
        }
    }

    /// Emit a comparison expression
    fn emitComparison(self: *SSACodeGen, stack: *SymbolicStack, op: []const u8) !void {
        // Get the two values being compared
        // Stack has: [..., left, right] where we compare left op right

        const stack_len = stack.stack.items.len;
        if (stack_len < 2) {
            try self.write("0 /* stack underflow */");
            return;
        }

        const right_id = stack.stack.items[stack_len - 1];
        const left_id = stack.stack.items[stack_len - 2];

        // Emit left operand
        try self.emitValueExpr(stack, left_id);
        try self.print(" {s} ", .{op});
        // Emit right operand
        try self.emitValueExpr(stack, right_id);
    }

    /// Emit a value as a C expression
    fn emitValueExpr(self: *SSACodeGen, stack: *SymbolicStack, val_id: u32) !void {
        if (stack.getValue(val_id)) |val| {
            switch (val.origin) {
                .arg => |idx| try self.print("n{d}", .{idx}),
                .int_const => |v| try self.print("{d}", .{v}),
                .binop => |b| {
                    try self.write("(");
                    try self.emitValueExpr(stack, b.left);
                    const op_str = switch (b.op) {
                        .add => " + ",
                        .sub => " - ",
                        .mul => " * ",
                        .div => " / ",
                        else => " ? ",
                    };
                    try self.write(op_str);
                    try self.emitValueExpr(stack, b.right);
                    try self.write(")");
                },
                .call => try self.print("r{d}", .{val_id}),
                else => try self.write("/* unknown */"),
            }
        } else {
            try self.write("/* missing value */");
        }
    }

    fn emitInit(self: *SSACodeGen) !void {
        const fname = self.options.func_name;
        try self.print(
            \\int {s}_init(JSContext *ctx)
            \\{{
            \\    JSValue global = JS_GetGlobalObject(ctx);
            \\    JSValue func = JS_NewCFunction(ctx, {s}, "{s}", {d});
            \\    JS_SetPropertyStr(ctx, global, "{s}", func);
            \\    JS_FreeValue(ctx, global);
            \\    return 0;
            \\}}
            \\
        , .{ fname, fname, fname, self.options.arg_count, fname });
    }
};
