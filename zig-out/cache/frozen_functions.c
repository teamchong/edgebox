/*
 * Frozen Module - All bytecode unrolled to C
 * Generated by edgebox-freeze
 */

#include "quickjs.h"
#include <stdint.h>
#include <math.h>

#ifndef likely
#define likely(x) __builtin_expect(!!(x), 1)
#endif
#ifndef unlikely
#define unlikely(x) __builtin_expect(!!(x), 0)
#endif

#ifndef FROZEN_MAX_CALL_DEPTH
#define FROZEN_MAX_CALL_DEPTH 10000
#endif
static int frozen_call_depth = 0;

#define FROZEN_CHECK_STACK(ctx) do { \
    if (unlikely(frozen_call_depth >= FROZEN_MAX_CALL_DEPTH)) { \
        return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded"); \
    } \
    frozen_call_depth++; \
} while(0)
#define FROZEN_EXIT_STACK() (frozen_call_depth--)

#define PUSH(v) do { \
    if (unlikely(sp >= max_stack)) { \
        FROZEN_EXIT_STACK(); \
        return JS_ThrowRangeError(ctx, "Operand stack overflow"); \
    } \
    stack[sp++] = (v); \
} while(0)
#define POP() (stack[--sp])
#define TOP() (stack[sp-1])
#define SET_TOP(v) (stack[sp-1] = (v))

/* SMI-optimized dup/free - skip refcount for immediate values (int, bool, etc) */
#define FROZEN_DUP(ctx, v) (JS_VALUE_HAS_REF_COUNT(v) ? JS_DupValue(ctx, v) : (v))
#define FROZEN_FREE(ctx, v) do { if (JS_VALUE_HAS_REF_COUNT(v)) JS_FreeValue(ctx, v); } while(0)

/* SMI (Small Integer) arithmetic helpers - zero allocation fast path */
/* Uses JS_MKVAL for int32 results (no context/allocation needed) */
/* Falls back to float64 only on overflow or non-int input */
static inline JSValue frozen_add(JSContext *ctx, JSValue a, JSValue b) {
    if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
        int64_t r = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
        if (likely((int32_t)r == r)) return JS_MKVAL(JS_TAG_INT, (int32_t)r);
        return JS_NewFloat64(ctx, (double)r);
    }
    double da, db;
    if (JS_ToFloat64(ctx, &da, a)) return JS_EXCEPTION;
    if (JS_ToFloat64(ctx, &db, b)) return JS_EXCEPTION;
    return JS_NewFloat64(ctx, da + db);
}
static inline JSValue frozen_sub(JSContext *ctx, JSValue a, JSValue b) {
    if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
        int64_t r = (int64_t)JS_VALUE_GET_INT(a) - JS_VALUE_GET_INT(b);
        if (likely((int32_t)r == r)) return JS_MKVAL(JS_TAG_INT, (int32_t)r);
        return JS_NewFloat64(ctx, (double)r);
    }
    double da, db;
    if (JS_ToFloat64(ctx, &da, a)) return JS_EXCEPTION;
    if (JS_ToFloat64(ctx, &db, b)) return JS_EXCEPTION;
    return JS_NewFloat64(ctx, da - db);
}
static inline JSValue frozen_mul(JSContext *ctx, JSValue a, JSValue b) {
    if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
        int64_t r = (int64_t)JS_VALUE_GET_INT(a) * JS_VALUE_GET_INT(b);
        if (likely((int32_t)r == r)) return JS_MKVAL(JS_TAG_INT, (int32_t)r);
        return JS_NewFloat64(ctx, (double)r);
    }
    double da, db;
    if (JS_ToFloat64(ctx, &da, a)) return JS_EXCEPTION;
    if (JS_ToFloat64(ctx, &db, b)) return JS_EXCEPTION;
    return JS_NewFloat64(ctx, da * db);
}
static inline JSValue frozen_div(JSContext *ctx, JSValue a, JSValue b) {
    double da, db;
    if (JS_ToFloat64(ctx, &da, a)) return JS_EXCEPTION;
    if (JS_ToFloat64(ctx, &db, b)) return JS_EXCEPTION;
    return JS_NewFloat64(ctx, da / db);
}
static inline JSValue frozen_mod(JSContext *ctx, JSValue a, JSValue b) {
    if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
        int32_t ia = JS_VALUE_GET_INT(a);
        int32_t ib = JS_VALUE_GET_INT(b);
        if (unlikely(ib == 0)) return JS_NewFloat64(ctx, NAN);
        if (unlikely(ib == -1 && ia == INT32_MIN)) return JS_MKVAL(JS_TAG_INT, 0);
        return JS_MKVAL(JS_TAG_INT, ia % ib);
    }
    double da, db;
    if (JS_ToFloat64(ctx, &da, a)) return JS_EXCEPTION;
    if (JS_ToFloat64(ctx, &db, b)) return JS_EXCEPTION;
    return JS_NewFloat64(ctx, fmod(da, db));
}
static inline int frozen_lt(JSContext *ctx, JSValue a, JSValue b) {
    if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
        return JS_VALUE_GET_INT(a) < JS_VALUE_GET_INT(b);
    }
    double da, db;
    if (JS_ToFloat64(ctx, &da, a)) return 0;
    if (JS_ToFloat64(ctx, &db, b)) return 0;
    return da < db;
}
static inline int frozen_lte(JSContext *ctx, JSValue a, JSValue b) {
    if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
        return JS_VALUE_GET_INT(a) <= JS_VALUE_GET_INT(b);
    }
    double da, db;
    if (JS_ToFloat64(ctx, &da, a)) return 0;
    if (JS_ToFloat64(ctx, &db, b)) return 0;
    return da <= db;
}
static inline int frozen_gt(JSContext *ctx, JSValue a, JSValue b) {
    if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
        return JS_VALUE_GET_INT(a) > JS_VALUE_GET_INT(b);
    }
    double da, db;
    if (JS_ToFloat64(ctx, &da, a)) return 0;
    if (JS_ToFloat64(ctx, &db, b)) return 0;
    return da > db;
}
static inline int frozen_gte(JSContext *ctx, JSValue a, JSValue b) {
    if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
        return JS_VALUE_GET_INT(a) >= JS_VALUE_GET_INT(b);
    }
    double da, db;
    if (JS_ToFloat64(ctx, &da, a)) return 0;
    if (JS_ToFloat64(ctx, &db, b)) return 0;
    return da >= db;
}
static inline int frozen_eq(JSContext *ctx, JSValue a, JSValue b) {
    if (JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT) {
        return JS_VALUE_GET_INT(a) == JS_VALUE_GET_INT(b);
    }
    double da, db;
    if (JS_ToFloat64(ctx, &da, a)) return 0;
    if (JS_ToFloat64(ctx, &db, b)) return 0;
    return da == db;
}
static inline int frozen_neq(JSContext *ctx, JSValue a, JSValue b) {
    return !frozen_eq(ctx, a, b);
}

/* Bitwise helpers - always convert to int32 per JS spec */
static inline JSValue frozen_and(JSContext *ctx, JSValue a, JSValue b) {
    int32_t ia, ib;
    JS_ToInt32(ctx, &ia, a); JS_ToInt32(ctx, &ib, b);
    return JS_MKVAL(JS_TAG_INT, ia & ib);
}
static inline JSValue frozen_or(JSContext *ctx, JSValue a, JSValue b) {
    int32_t ia, ib;
    JS_ToInt32(ctx, &ia, a); JS_ToInt32(ctx, &ib, b);
    return JS_MKVAL(JS_TAG_INT, ia | ib);
}
static inline JSValue frozen_xor(JSContext *ctx, JSValue a, JSValue b) {
    int32_t ia, ib;
    JS_ToInt32(ctx, &ia, a); JS_ToInt32(ctx, &ib, b);
    return JS_MKVAL(JS_TAG_INT, ia ^ ib);
}
static inline JSValue frozen_shl(JSContext *ctx, JSValue a, JSValue b) {
    int32_t ia, ib;
    JS_ToInt32(ctx, &ia, a); JS_ToInt32(ctx, &ib, b);
    return JS_MKVAL(JS_TAG_INT, ia << (ib & 0x1f));
}
static inline JSValue frozen_sar(JSContext *ctx, JSValue a, JSValue b) {
    int32_t ia, ib;
    JS_ToInt32(ctx, &ia, a); JS_ToInt32(ctx, &ib, b);
    return JS_MKVAL(JS_TAG_INT, ia >> (ib & 0x1f));
}
static inline JSValue frozen_shr(JSContext *ctx, JSValue a, JSValue b) {
    uint32_t ua; int32_t ib;
    JS_ToUint32(ctx, &ua, a); JS_ToInt32(ctx, &ib, b);
    return JS_NewUint32(ctx, ua >> (ib & 0x1f));
}
static inline JSValue frozen_not(JSContext *ctx, JSValue a) {
    int32_t ia;
    JS_ToInt32(ctx, &ia, a);
    return JS_MKVAL(JS_TAG_INT, ~ia);
}
static inline JSValue frozen_neg(JSContext *ctx, JSValue a) {
    if (JS_VALUE_GET_TAG(a) == JS_TAG_INT) {
        int32_t v = JS_VALUE_GET_INT(a);
        if (v == INT32_MIN) return JS_NewFloat64(ctx, 2147483648.0);
        return JS_MKVAL(JS_TAG_INT, -v);
    }
    double d;
    JS_ToFloat64(ctx, &d, a);
    return JS_NewFloat64(ctx, -d);
}

/* Array access helpers - use public QuickJS API */
static inline JSValue frozen_array_get(JSContext *ctx, JSValue obj, JSValue idx) {
    if (JS_VALUE_GET_TAG(idx) == JS_TAG_INT) {
        int32_t i = JS_VALUE_GET_INT(idx);
        if (i >= 0) return JS_GetPropertyUint32(ctx, obj, (uint32_t)i);  /* Fast path */
        return JS_GetPropertyInt64(ctx, obj, i);
    }
    JSAtom atom = JS_ValueToAtom(ctx, idx);
    if (atom == JS_ATOM_NULL) return JS_EXCEPTION;
    JSValue val = JS_GetProperty(ctx, obj, atom);
    JS_FreeAtom(ctx, atom);
    return val;
}
static inline int frozen_array_set(JSContext *ctx, JSValue obj, JSValue idx, JSValue val) {
    if (JS_VALUE_GET_TAG(idx) == JS_TAG_INT) {
        return JS_SetPropertyInt64(ctx, obj, JS_VALUE_GET_INT(idx), val);
    }
    JSAtom atom = JS_ValueToAtom(ctx, idx);
    if (atom == JS_ATOM_NULL) return -1;
    int r = JS_SetProperty(ctx, obj, atom, val);
    JS_FreeAtom(ctx, atom);
    return r;
}
static inline int64_t frozen_get_length(JSContext *ctx, JSValue obj) {
    int64_t len = 0;
    JS_GetLength(ctx, obj, &len);  /* Direct API - faster than JS_GetPropertyStr */
    return len;
}

/* SIMD-accelerated int32 array operations (4 elements at once) */
#ifdef __wasm__
#include <wasm_simd128.h>

/* SIMD int32 array sum - processes 4 elements per iteration */
static inline int64_t frozen_sum_int32_array_simd(JSContext *ctx, JSValue arr, int64_t len) {
    v128_t sum_vec = wasm_i32x4_splat(0);  /* Initialize 4-lane sum to 0 */
    int64_t i = 0;

    /* SIMD loop: process 4 int32s at once */
    for (; i + 4 <= len; i += 4) {
        int32_t vals[4];
        int all_int32 = 1;

        /* Load and check 4 values */
        for (int j = 0; j < 4; j++) {
            JSValue val = JS_GetPropertyUint32(ctx, arr, (uint32_t)(i + j));
            if (likely(JS_VALUE_GET_TAG(val) == JS_TAG_INT)) {
                vals[j] = JS_VALUE_GET_INT(val);
            } else {
                JS_FreeValue(ctx, val);
                all_int32 = 0;
                break;
            }
        }

        if (all_int32) {
            /* Load 4 int32s into SIMD register */
            v128_t vec = wasm_v128_load(vals);
            /* Vectorized add */
            sum_vec = wasm_i32x4_add(sum_vec, vec);
        } else {
            /* Type guard failed - fall back to scalar */
            return -1;
        }
    }

    /* Horizontal sum: reduce 4 lanes to single value */
    int32_t partial[4];
    wasm_v128_store(partial, sum_vec);
    int64_t sum = (int64_t)partial[0] + partial[1] + partial[2] + partial[3];

    /* Scalar remainder */
    for (; i < len; i++) {
        JSValue val = JS_GetPropertyUint32(ctx, arr, (uint32_t)i);
        if (likely(JS_VALUE_GET_TAG(val) == JS_TAG_INT)) {
            sum += JS_VALUE_GET_INT(val);
        } else {
            JS_FreeValue(ctx, val);
            return -1;  /* Type guard failed */
        }
    }

    return sum;
}
#endif /* __wasm__ */

static inline JSValue frozen_pow(JSContext *ctx, JSValue a, JSValue b) {
    double da, db;
    if (JS_ToFloat64(ctx, &da, a)) return JS_EXCEPTION;
    if (JS_ToFloat64(ctx, &db, b)) return JS_EXCEPTION;
    return JS_NewFloat64(ctx, pow(da, db));
}
static inline JSValue frozen_typeof(JSContext *ctx, JSValue v) {
    const char *s;
    int tag = JS_VALUE_GET_TAG(v);
    switch(tag) {
    case JS_TAG_UNDEFINED: s = "undefined"; break;
    case JS_TAG_NULL: s = "object"; break;
    case JS_TAG_STRING: s = "string"; break;
    case JS_TAG_INT: case JS_TAG_FLOAT64: s = "number"; break;
    case JS_TAG_BOOL: s = "boolean"; break;
    case JS_TAG_BIG_INT: s = "bigint"; break;
    case JS_TAG_SYMBOL: s = "symbol"; break;
    case JS_TAG_OBJECT:
        if (JS_IsFunction(ctx, v)) s = "function";
        else s = "object";
        break;
    default: s = "unknown"; break;
    }
    return JS_NewString(ctx, s);
}
static inline int frozen_in(JSContext *ctx, JSValue key, JSValue obj) {
    JSAtom atom = JS_ValueToAtom(ctx, key);
    if (atom == JS_ATOM_NULL) return -1;
    int r = JS_HasProperty(ctx, obj, atom);
    JS_FreeAtom(ctx, atom);
    return r;
}
static JSValue frozen_func0(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func0_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func0_Frame;

static JSValue frozen_func0(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func0_Frame *frames = js_malloc(ctx, sizeof(frozen_func0_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func0_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 2; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = POP(); PUSH(JS_NewBool(ctx, JS_IsFunction(ctx, v))); FROZEN_FREE(ctx, v); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 8; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 3;
            break;
        case 3:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NewString(ctx, "queue1"));
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 6; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 4;
            break;
        case 4:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "arr");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 6; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 5;
            break;
        case 5:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "arr");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            next_block = 7; break;
            }
            break;
        case 6:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            }
            next_block = 7;
            break;
        case 7:
            switch (frame->instr_offset) {
            case 0:
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            { JSValue arg0 = POP(); JSValue func = POP();
              JSValue ret = JS_Call(ctx, func, JS_UNDEFINED, 1, &arg0);
              FROZEN_FREE(ctx, func); FROZEN_FREE(ctx, arg0);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { FROZEN_FREE(ctx, POP()); }
            break;
            }
            next_block = 8;
            break;
        case 8:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = -1;
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func0_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func0, "frozen_func0", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func0", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_tick(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_tick_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_tick_Frame;

static JSValue frozen_tick(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_tick_Frame *frames = js_malloc(ctx, sizeof(frozen_tick_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_tick_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            { JSValue a = POP(); if (JS_VALUE_GET_TAG(a) == JS_TAG_INT) { PUSH(JS_MKVAL(JS_TAG_INT, JS_VALUE_GET_INT(a) + 1)); } else { PUSH(JS_NewFloat64(ctx, JS_VALUE_GET_FLOAT64(JS_ToNumber(ctx, a)) + 1)); } FROZEN_FREE(ctx, a); }
            { FROZEN_FREE(ctx, POP()); }
            PUSH(JS_MKVAL(JS_TAG_INT, 20));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, frozen_lte(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 2; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NewString(ctx, "_sink"));
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            case 1:
                /* Recursive call 4 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { FROZEN_FREE(ctx, POP()); }
            PUSH(JS_UNDEFINED);
            PUSH(JS_MKVAL(JS_TAG_INT, 500));
            case 3:
                /* Recursive call 9 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 4;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 4:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { FROZEN_FREE(ctx, POP()); }
            frame->result = JS_UNDEFINED; next_block = -1; break;
            }
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NewString(ctx, "writableStrategy"));
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { FROZEN_FREE(ctx, POP()); }
            frame->result = JS_UNDEFINED; next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_tick_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_tick, "__frozen_tick", 0);
    JS_SetPropertyStr(ctx, global, "__frozen_tick", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func5(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func5_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func5_Frame;

static JSValue frozen_func5(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func5_Frame *frames = js_malloc(ctx, sizeof(frozen_func5_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func5_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NewString(ctx, "bubbles"));
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            case 1:
                /* Recursive call 4 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { FROZEN_FREE(ctx, POP()); }
            { JSValue exc = JS_GetException(ctx); PUSH(exc); }
            break;
            }
            next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "cancelable"));
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue ctor = POP();
              JSValue ret = JS_CallConstructor(ctx, ctor, 1, args);
              FROZEN_FREE(ctx, ctor); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = 2;
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            { JSValue exc = JS_GetException(ctx); PUSH(exc); }
            break;
            }
            next_block = 3;
            break;
        case 3:
            switch (frame->instr_offset) {
            }
            next_block = 4;
            break;
        case 4:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NewString(ctx, "composed"));
            PUSH(FROZEN_DUP(ctx, frame->locals[0]));
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "objects");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            case 1:
                /* Recursive call 5 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { FROZEN_FREE(ctx, POP()); }
            { FROZEN_FREE(ctx, POP()); }
            next_block = 6; break;
            }
            break;
        case 5:
            switch (frame->instr_offset) {
            case 0:
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = 6;
            break;
        case 6:
            switch (frame->instr_offset) {
            case 0:
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 9; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 7;
            break;
        case 7:
            switch (frame->instr_offset) {
            }
            next_block = 8;
            break;
        case 8:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { FROZEN_FREE(ctx, POP()); }
            break;
            }
            next_block = 9;
            break;
        case 9:
            switch (frame->instr_offset) {
            case 0:
            frame->result = JS_UNDEFINED; next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func5_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func5, "frozen_func5", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func5", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func7(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func7(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func7_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func7, "frozen_func7", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func7", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func19(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func19(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* push_0 */
    PUSH(JS_MKVAL(JS_TAG_INT, 0));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func19_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func19, "frozen_func19", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func19", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func21(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func21(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* null */
    PUSH(JS_NULL);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func21_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func21, "frozen_func21", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func21", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func22(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func22(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func22_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func22, "frozen_func22", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func22", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func23(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func23(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* get_length */
    { JSValue obj = POP(); int64_t len = frozen_get_length(ctx, obj); FROZEN_FREE(ctx, obj); PUSH(JS_NewInt64(ctx, len)); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func23_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func23, "frozen_func23", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func23", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_MockModule(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_MockModule(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 334, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_MockModule_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_MockModule, "__frozen_MockModule", 1);
    JS_SetPropertyStr(ctx, global, "__frozen_MockModule", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func30(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func30_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func30_Frame;

static JSValue frozen_func30(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func30_Frame *frames = js_malloc(ctx, sizeof(frozen_func30_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func30_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = POP(); PUSH(JS_NewBool(ctx, JS_IsFunction(ctx, v))); FROZEN_FREE(ctx, v); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 2; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NewString(ctx, "v"));
            case 1:
                /* Recursive call 4 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            { JSValue arg0 = POP(); JSValue func = POP();
              JSValue ret = JS_Call(ctx, func, JS_UNDEFINED, 1, &arg0);
              FROZEN_FREE(ctx, func); FROZEN_FREE(ctx, arg0);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { FROZEN_FREE(ctx, POP()); }
            break;
            }
            next_block = 2;
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_TRUE);
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { FROZEN_FREE(ctx, POP()); }
            { FROZEN_FREE(ctx, POP()); }
            PUSH(JS_MKVAL(JS_TAG_INT, 0));
            frame->result = POP(); next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func30_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func30, "frozen_func30", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func30", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func32(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func32(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* push_0 */
    PUSH(JS_MKVAL(JS_TAG_INT, 0));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func32_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func32, "frozen_func32", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func32", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func33(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func33_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func33_Frame;

static JSValue frozen_func33(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func33_Frame *frames = js_malloc(ctx, sizeof(frozen_func33_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func33_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = POP(); PUSH(JS_NewBool(ctx, JS_IsFunction(ctx, v))); FROZEN_FREE(ctx, v); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 2; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NewString(ctx, "map"));
            case 1:
                /* Recursive call 4 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            { JSValue arg0 = POP(); JSValue func = POP();
              JSValue ret = JS_Call(ctx, func, JS_UNDEFINED, 1, &arg0);
              FROZEN_FREE(ctx, func); FROZEN_FREE(ctx, arg0);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { FROZEN_FREE(ctx, POP()); }
            break;
            }
            next_block = 2;
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_MKVAL(JS_TAG_INT, 0));
            frame->result = POP(); next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func33_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func33, "frozen_func33", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func33", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func37(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func37(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* push_true */
    PUSH(JS_TRUE);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func37_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func37, "frozen_func37", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func37", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func49(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func49(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func49_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func49, "frozen_func49", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func49", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func50(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func50(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func50_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func50, "frozen_func50", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func50", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func52(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func52(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func52_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func52, "frozen_func52", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func52", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func53(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func53(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func53_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func53, "frozen_func53", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func53", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func54(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func54(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func54_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func54, "frozen_func54", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func54", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func55(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func55(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func55_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func55, "frozen_func55", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func55", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func65(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func65(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func65_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func65, "frozen_func65", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func65", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func72(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func72_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func72_Frame;

static JSValue frozen_func72(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func72_Frame *frames = js_malloc(ctx, sizeof(frozen_func72_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func72_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "hostname");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            PUSH(JS_NULL);
            PUSH(JS_MKVAL(JS_TAG_INT, 2));
            {
              JSValue args[3];
              args[2] = POP();
              args[1] = POP();
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 3, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              FROZEN_FREE(ctx, args[1]);
              FROZEN_FREE(ctx, args[2]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            case 1:
                /* Recursive call 7 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func72_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func72, "frozen_func72", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func72", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func73(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func73_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func73_Frame;

static JSValue frozen_func73(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func73_Frame *frames = js_malloc(ctx, sizeof(frozen_func73_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func73_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "hostname");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            PUSH(JS_NULL);
            PUSH(JS_MKVAL(JS_TAG_INT, 2));
            {
              JSValue args[3];
              args[2] = POP();
              args[1] = POP();
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 3, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              FROZEN_FREE(ctx, args[1]);
              FROZEN_FREE(ctx, args[2]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            case 1:
                /* Recursive call 7 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func73_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func73, "frozen_func73", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func73", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func75(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func75(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func75_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func75, "frozen_func75", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func75", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func76(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func76(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func76_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func76, "frozen_func76", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func76", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func77(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func77(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func77_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func77, "frozen_func77", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func77", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func78(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func78(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func78_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func78, "frozen_func78", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func78", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func79(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func79(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func79_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func79, "frozen_func79", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func79", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func80(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func80(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func80_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func80, "frozen_func80", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func80", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func81(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func81(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func81_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func81, "frozen_func81", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func81", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func82(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func82(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func82_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func82, "frozen_func82", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func82", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func83(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func83(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func83_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func83, "frozen_func83", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func83", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func85(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func85(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* push_true */
    PUSH(JS_TRUE);
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 434, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func85_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func85, "frozen_func85", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func85", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func86(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func86(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* push_false */
    PUSH(JS_FALSE);
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 434, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func86_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func86, "frozen_func86", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func86", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func87(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func87(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 434); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func87_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func87, "frozen_func87", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func87", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func88(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func88(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func88_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func88, "frozen_func88", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func88", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func89(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func89(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 429); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func89_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func89, "frozen_func89", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func89", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func109(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func109(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    PUSH(JS_UNDEFINED); /* TODO: closure var_ref */
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 462, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
    PUSH(JS_UNDEFINED); /* TODO: closure var_ref */
    /* get_arg1 */
    PUSH(argc > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 463, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func109_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func109, "frozen_func109", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func109", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func112(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func112(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 466); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); goto block_2; } JS_FreeValue(ctx, cond); }
block_1:
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 466); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* push_false */
    PUSH(JS_FALSE);
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 464, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 466); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* null */
    PUSH(JS_NULL);
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 467, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* null */
    PUSH(JS_NULL);
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 466, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
block_2:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func112_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func112, "frozen_func112", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func112", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func113(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func113(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 468); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func113_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func113, "frozen_func113", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func113", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func118(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func118(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    PUSH(JS_UNDEFINED); /* TODO: closure var_ref */
    /* push_true */
    PUSH(JS_TRUE);
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 481, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func118_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func118, "frozen_func118", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func118", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func119(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func119(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    PUSH(JS_UNDEFINED); /* TODO: closure var_ref */
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 482); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 379); if (JS_IsException(val)) return val; PUSH(val); }
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func119_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func119, "frozen_func119", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func119", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func128(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func128(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 130); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    PUSH(JS_UNDEFINED); /* TODO: closure var_ref */
    /* strict_eq */
    { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, frozen_eq(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func128_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func128, "frozen_func128", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func128", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func129(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func129_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func129_Frame;

static JSValue frozen_func129(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func129_Frame *frames = js_malloc(ctx, sizeof(frozen_func129_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func129_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[0] = JS_UNINITIALIZED;
            PUSH(JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "_ended");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "removeListener");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            /* Unsupported opcode 193 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            {
              JSValue args[1];
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 1, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_MKVAL(JS_TAG_INT, 0));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, frozen_gte(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 2; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "_ended");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "emit");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_MKVAL(JS_TAG_INT, 1));
            {
              JSValue args[2];
              args[1] = POP();
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 2, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              FROZEN_FREE(ctx, args[1]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, POP()); }
            PUSH(JS_NewObject(ctx));
            { JSValue val = POP(); JSValue obj = TOP();
              JSAtom prop = JS_NewAtom(ctx, "[ABORT STACK] ");
              JS_DefinePropertyValue(ctx, obj, prop, val, JS_PROP_C_W_E);
              JS_FreeAtom(ctx, prop); }
            PUSH(JS_TRUE);
            { JSValue val = POP(); JSValue obj = TOP();
              JSAtom prop = JS_NewAtom(ctx, "bytes");
              JS_DefinePropertyValue(ctx, obj, prop, val, JS_PROP_C_W_E);
              JS_FreeAtom(ctx, prop); }
            case 1:
                /* Recursive call 13 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { FROZEN_FREE(ctx, POP()); }
            break;
            }
            next_block = 2;
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            frame->result = JS_UNDEFINED; next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func129_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func129, "frozen_func129", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func129", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func140(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func140(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 464); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func140_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func140, "frozen_func140", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func140", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func145(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func145(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 466); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 520); if (JS_IsException(val)) return val; PUSH(val); }
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func145_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func145, "frozen_func145", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func145", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func148(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func148(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func148_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func148, "frozen_func148", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func148", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func151(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func151(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* push_1 */
    PUSH(JS_MKVAL(JS_TAG_INT, 1));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func151_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func151, "frozen_func151", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func151", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func152(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func152(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func152_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func152, "frozen_func152", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func152", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func155(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func155(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func155_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func155, "frozen_func155", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func155", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func159(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func159(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* push_false */
    PUSH(JS_FALSE);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func159_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func159, "frozen_func159", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func159", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func167(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func167(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 348); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func167_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func167, "frozen_func167", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func167", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func169(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func169(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* push_1 */
    PUSH(JS_MKVAL(JS_TAG_INT, 1));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func169_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func169, "frozen_func169", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func169", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func171(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func171(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* push_true */
    PUSH(JS_TRUE);
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 532, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func171_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func171, "frozen_func171", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func171", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func172(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func172(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func172_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func172, "frozen_func172", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func172", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func173(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func173(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func173_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func173, "frozen_func173", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func173", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func177(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func177(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    PUSH(JS_UNDEFINED); /* TODO: closure var_ref */
    /* strict_neq */
    { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, frozen_neq(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func177_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func177, "frozen_func177", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func177", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func179(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func179_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func179_Frame;

static JSValue frozen_func179(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func179_Frame *frames = js_malloc(ctx, sizeof(frozen_func179_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func179_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func179_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func179, "frozen_func179", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func179", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func185(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func185(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func185_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func185, "frozen_func185", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func185", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func186(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func186(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func186_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func186, "frozen_func186", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func186", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func189(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func189(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 553); if (JS_IsException(val)) return val; PUSH(val); }
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func189_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func189, "frozen_func189", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func189", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func191(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func191(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 551); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* dup */
    { JSValue tmp = TOP(); PUSH(FROZEN_DUP(ctx, tmp)); }
    { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); goto block_2; } JS_FreeValue(ctx, cond); }
block_1:
    /* drop */
    FROZEN_FREE(ctx, POP());
    /* object */
    PUSH(JS_NewObject(ctx));
block_2:
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func191_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func191, "frozen_func191", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func191", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func193(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func193_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func193_Frame;

static JSValue frozen_func193(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func193_Frame *frames = js_malloc(ctx, sizeof(frozen_func193_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func193_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func193_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func193, "frozen_func193", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func193", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func195(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func195(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 551); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* dup */
    { JSValue tmp = TOP(); PUSH(FROZEN_DUP(ctx, tmp)); }
    { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); goto block_2; } JS_FreeValue(ctx, cond); }
block_1:
    /* drop */
    FROZEN_FREE(ctx, POP());
    /* object */
    PUSH(JS_NewObject(ctx));
block_2:
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func195_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func195, "frozen_func195", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func195", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func197(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func197(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* get_arg1 */
    PUSH(argc > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
    /* lt */
    { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, frozen_lt(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
    { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); goto block_2; } JS_FreeValue(ctx, cond); }
block_1:
    /* push_minus1 */
    PUSH(JS_MKVAL(JS_TAG_INT, -1));
    /* return */
    FROZEN_EXIT_STACK(); return POP();
block_2:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* get_arg1 */
    PUSH(argc > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
    /* gt */
    { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, frozen_gt(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
    { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); goto block_4; } JS_FreeValue(ctx, cond); }
block_3:
    /* push_1 */
    PUSH(JS_MKVAL(JS_TAG_INT, 1));
    /* return */
    FROZEN_EXIT_STACK(); return POP();
block_4:
    /* push_0 */
    PUSH(JS_MKVAL(JS_TAG_INT, 0));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func197_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func197, "frozen_func197", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func197", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func198(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func198(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* object */
    PUSH(JS_NewObject(ctx));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func198_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func198, "frozen_func198", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func198", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func201(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func201(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* object */
    PUSH(JS_NewObject(ctx));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func201_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func201, "frozen_func201", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func201", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func205(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func205(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* object */
    PUSH(JS_NewObject(ctx));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func205_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func205, "frozen_func205", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func205", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func210(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func210(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* object */
    PUSH(JS_NewObject(ctx));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func210_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func210, "frozen_func210", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func210", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func218(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func218_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[2];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func218_Frame;

static JSValue frozen_func218(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func218_Frame *frames = js_malloc(ctx, sizeof(frozen_func218_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 2; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func218_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            /* Unsupported opcode 127 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            /* Unsupported opcode 130 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { FROZEN_FREE(ctx, POP()); }
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            /* Unsupported opcode 130 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { FROZEN_FREE(ctx, POP()); }
            { FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = POP(); }
            /* Unsupported opcode 133 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "_stderr");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "follow");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(FROZEN_DUP(ctx, frame->locals[0]));
            PUSH(FROZEN_DUP(ctx, frame->locals[1]));
            case 1:
                /* Recursive call 15 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 2; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { JSValue len = POP(); JSValue arr = POP();
              JSValue new_arr = JS_NewArray(ctx);
              if (!JS_IsException(new_arr)) {
                int64_t length = 0;
                JS_ToInt64(ctx, &length, len);
                for (int64_t i = 0; i < length; i++) {
                  JSValue elem = JS_GetPropertyInt64(ctx, arr, i);
                  JS_SetPropertyInt64(ctx, new_arr, i, elem);
                }
              }
              FROZEN_FREE(ctx, arr); FROZEN_FREE(ctx, len);
              if (JS_IsException(new_arr)) { next_block = -1; frame->result = new_arr; break; }
              PUSH(new_arr); }
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue method = POP(); JSValue this_obj = POP();
              JSValue ret = JS_Call(ctx, method, this_obj, 1, args);
              FROZEN_FREE(ctx, method); FROZEN_FREE(ctx, this_obj); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              frame->result = ret; next_block = -1; break; }
            break;
            }
            next_block = -1;
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func218_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func218, "frozen_func218", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func218", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func236(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func236_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[2];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func236_Frame;

static JSValue frozen_func236(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func236_Frame *frames = js_malloc(ctx, sizeof(frozen_func236_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 2; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func236_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            /* Unsupported opcode 127 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            /* Unsupported opcode 130 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { FROZEN_FREE(ctx, POP()); }
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            /* Unsupported opcode 130 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { FROZEN_FREE(ctx, POP()); }
            { FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = POP(); }
            /* Unsupported opcode 133 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            PUSH(FROZEN_DUP(ctx, frame->locals[1]));
            PUSH(FROZEN_DUP(ctx, frame->locals[0]));
            PUSH(JS_UNDEFINED);
            case 1:
                /* Recursive call 13 (3 args) - push frame */
                {
                    JSValue arg2 = POP();
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].args[2] = arg2;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 2; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func236_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func236, "frozen_func236", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func236", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func240(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func240(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 584); if (JS_IsException(val)) return val; PUSH(val); }
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func240_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func240, "frozen_func240", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func240", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func244(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func244(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 595); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 604); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    { JSValue b = POP(), a = POP();
      if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
          int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
          if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
              PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));  /* Fast path: no alloc */
          } else {
              PUSH(JS_NewFloat64(ctx, (double)sum));  /* Overflow to float64 */
          }
      } else {
          JSValue r = frozen_add(ctx, a, b);  /* Slow path */
          FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
          if (JS_IsException(r)) return r;
          PUSH(r);
      }
    }
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 605); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    { JSValue b = POP(), a = POP();
      if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
          int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
          if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
              PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));  /* Fast path: no alloc */
          } else {
              PUSH(JS_NewFloat64(ctx, (double)sum));  /* Overflow to float64 */
          }
      } else {
          JSValue r = frozen_add(ctx, a, b);  /* Slow path */
          FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
          if (JS_IsException(r)) return r;
          PUSH(r);
      }
    }
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 606); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    { JSValue b = POP(), a = POP();
      if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
          int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
          if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
              PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));  /* Fast path: no alloc */
          } else {
              PUSH(JS_NewFloat64(ctx, (double)sum));  /* Overflow to float64 */
          }
      } else {
          JSValue r = frozen_add(ctx, a, b);  /* Slow path */
          FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
          if (JS_IsException(r)) return r;
          PUSH(r);
      }
    }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func244_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func244, "frozen_func244", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func244", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func245(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func245(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 598); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func245_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func245, "frozen_func245", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func245", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func246(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func246(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 598); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func246_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func246, "frozen_func246", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func246", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func261(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func261(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* push_1 */
    PUSH(JS_MKVAL(JS_TAG_INT, 1));
    /* get_array_el */
    { JSValue idx = POP(); JSValue obj = POP(); JSValue val = frozen_array_get(ctx, obj, idx); FROZEN_FREE(ctx, obj); FROZEN_FREE(ctx, idx); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func261_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func261, "frozen_func261", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func261", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func266(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func266(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* push_0 */
    PUSH(JS_MKVAL(JS_TAG_INT, 0));
    /* get_array_el */
    { JSValue idx = POP(); JSValue obj = POP(); JSValue val = frozen_array_get(ctx, obj, idx); FROZEN_FREE(ctx, obj); FROZEN_FREE(ctx, idx); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func266_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func266, "frozen_func266", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func266", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func268(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func268(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* push_1 */
    PUSH(JS_MKVAL(JS_TAG_INT, 1));
    /* get_array_el */
    { JSValue idx = POP(); JSValue obj = POP(); JSValue val = frozen_array_get(ctx, obj, idx); FROZEN_FREE(ctx, obj); FROZEN_FREE(ctx, idx); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func268_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func268, "frozen_func268", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func268", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func274(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func274(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 584); if (JS_IsException(val)) return val; PUSH(val); }
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func274_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func274, "frozen_func274", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func274", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func275(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func275(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    PUSH(JS_UNDEFINED); /* TODO: closure var_ref */
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 67); if (JS_IsException(val)) return val; PUSH(val); }
    /* get_arg1 */
    PUSH(argc > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func275_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func275, "frozen_func275", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func275", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func283(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func283_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[2];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func283_Frame;

static JSValue frozen_func283(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func283_Frame *frames = js_malloc(ctx, sizeof(frozen_func283_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 2; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func283_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            /* Unsupported opcode 127 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            /* Unsupported opcode 130 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { FROZEN_FREE(ctx, POP()); }
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            /* Unsupported opcode 130 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { FROZEN_FREE(ctx, POP()); }
            { FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = POP(); }
            /* Unsupported opcode 133 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            PUSH(FROZEN_DUP(ctx, frame->locals[1]));
            PUSH(FROZEN_DUP(ctx, frame->locals[0]));
            PUSH(JS_UNDEFINED);
            case 1:
                /* Recursive call 13 (3 args) - push frame */
                {
                    JSValue arg2 = POP();
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].args[2] = arg2;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 2; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func283_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func283, "frozen_func283", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func283", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func288(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func288(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 584); if (JS_IsException(val)) return val; PUSH(val); }
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func288_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func288, "frozen_func288", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func288", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func289(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func289(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func289_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func289, "frozen_func289", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func289", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func294(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func294(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 635); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func294_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func294, "frozen_func294", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func294", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func295(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func295(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 645); if (JS_IsException(val)) return val; PUSH(val); }
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func295_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func295, "frozen_func295", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func295", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func296(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func296(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 645); if (JS_IsException(val)) return val; PUSH(val); }
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func296_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func296, "frozen_func296", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func296", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func297(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func297(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 645); if (JS_IsException(val)) return val; PUSH(val); }
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func297_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func297, "frozen_func297", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func297", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func298(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func298(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func298_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func298, "frozen_func298", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func298", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func302(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func302(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func302_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func302, "frozen_func302", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func302", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func311(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func311(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 322); if (JS_IsException(val)) return val; PUSH(val); }
    /* push_0 */
    PUSH(JS_MKVAL(JS_TAG_INT, 0));
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func311_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func311, "frozen_func311", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func311", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func322(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func322(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* get_arg1+get_length (optimized) */
    PUSH(JS_NewInt64(ctx, argc > 1 ? frozen_get_length(ctx, argv[1]) : 0));
    { JSValue b = POP(), a = POP();
      if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
          int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
          if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
              PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));  /* Fast path: no alloc */
          } else {
              PUSH(JS_NewFloat64(ctx, (double)sum));  /* Overflow to float64 */
          }
      } else {
          JSValue r = frozen_add(ctx, a, b);  /* Slow path */
          FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
          if (JS_IsException(r)) return r;
          PUSH(r);
      }
    }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func322_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func322, "frozen_func322", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func322", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func332(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func332(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func332_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func332, "frozen_func332", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func332", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func334(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func334_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func334_Frame;

static JSValue frozen_func334(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func334_Frame *frames = js_malloc(ctx, sizeof(frozen_func334_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func334_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func334_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func334, "frozen_func334", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func334", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func335(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func335_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func335_Frame;

static JSValue frozen_func335(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func335_Frame *frames = js_malloc(ctx, sizeof(frozen_func335_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func335_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func335_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func335, "frozen_func335", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func335", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func336(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func336(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 716, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func336_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func336, "frozen_func336", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func336", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func337(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func337(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    PUSH(JS_UNDEFINED); /* TODO: closure var_ref */
    /* push_true */
    PUSH(JS_TRUE);
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 717, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
    PUSH(JS_UNDEFINED); /* TODO: closure var_ref */
    { JSValue func = POP(); JSValue ret = JS_Call(ctx, func, JS_UNDEFINED, 0, NULL); JS_FreeValue(ctx, func); if (JS_IsException(ret)) return ret; PUSH(ret); }
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func337_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func337, "frozen_func337", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func337", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func341(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func341(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    PUSH(JS_UNDEFINED); /* TODO: closure var_ref */
    /* strict_neq */
    { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, frozen_neq(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func341_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func341, "frozen_func341", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func341", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func343(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func343(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 719); if (JS_IsException(val)) return val; PUSH(val); }
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* get_arg1 */
    PUSH(argc > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func343_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func343, "frozen_func343", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func343", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func346(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func346(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* null */
    PUSH(JS_NULL);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func346_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func346, "frozen_func346", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func346", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func347(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func347(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func347_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func347, "frozen_func347", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func347", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func348(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func348(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func348_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func348, "frozen_func348", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func348", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func349(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func349(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func349_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func349, "frozen_func349", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func349", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func350(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func350(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func350_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func350, "frozen_func350", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func350", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func351(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func351(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func351_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func351, "frozen_func351", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func351", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func359(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func359(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* push_0 */
    PUSH(JS_MKVAL(JS_TAG_INT, 0));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func359_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func359, "frozen_func359", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func359", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func360(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func360(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func360_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func360, "frozen_func360", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func360", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func361(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func361(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func361_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func361, "frozen_func361", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func361", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func362(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func362(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func362_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func362, "frozen_func362", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func362", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func363(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func363(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func363_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func363, "frozen_func363", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func363", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func364(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func364(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* push_false */
    PUSH(JS_FALSE);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func364_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func364, "frozen_func364", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func364", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func365(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func365(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func365_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func365, "frozen_func365", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func365", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func366(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func366(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func366_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func366, "frozen_func366", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func366", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func367(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func367(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func367_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func367, "frozen_func367", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func367", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func369(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func369(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* push_false */
    PUSH(JS_FALSE);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func369_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func369, "frozen_func369", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func369", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func384(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func384_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func384_Frame;

static JSValue frozen_func384(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func384_Frame *frames = js_malloc(ctx, sizeof(frozen_func384_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func384_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_DupValue(ctx, this_val));
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            PUSH(FROZEN_DUP(ctx, frame->locals[0]));
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "O_WRONLY");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            case 1:
                /* Recursive call 5 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func384_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func384, "frozen_func384", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func384", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func385(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func385_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func385_Frame;

static JSValue frozen_func385(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func385_Frame *frames = js_malloc(ctx, sizeof(frozen_func385_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func385_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_DupValue(ctx, this_val));
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            PUSH(FROZEN_DUP(ctx, frame->locals[0]));
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "O_WRONLY");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            PUSH(JS_MKVAL(JS_TAG_INT, 0));
            { JSValue b = POP(), a = POP(); PUSH(JS_MKVAL(JS_TAG_INT, JS_VALUE_GET_INT(a) | JS_VALUE_GET_INT(b))); }
            case 1:
                /* Recursive call 8 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func385_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func385, "frozen_func385", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func385", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func387(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func387_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func387_Frame;

static JSValue frozen_func387(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func387_Frame *frames = js_malloc(ctx, sizeof(frozen_func387_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func387_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_DupValue(ctx, this_val));
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            PUSH(FROZEN_DUP(ctx, frame->locals[0]));
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "O_WRONLY");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            case 1:
                /* Recursive call 5 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func387_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func387, "frozen_func387", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func387", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func392(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func392_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func392_Frame;

static JSValue frozen_func392(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func392_Frame *frames = js_malloc(ctx, sizeof(frozen_func392_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func392_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_DupValue(ctx, this_val));
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            PUSH(FROZEN_DUP(ctx, frame->locals[0]));
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "O_WRONLY");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            PUSH(JS_MKVAL(JS_TAG_INT, 0));
            { JSValue b = POP(), a = POP(); PUSH(JS_MKVAL(JS_TAG_INT, JS_VALUE_GET_INT(a) | JS_VALUE_GET_INT(b))); }
            case 1:
                /* Recursive call 8 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func392_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func392, "frozen_func392", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func392", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func399(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func399_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func399_Frame;

static JSValue frozen_func399(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func399_Frame *frames = js_malloc(ctx, sizeof(frozen_func399_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func399_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_DupValue(ctx, this_val));
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            /* Unsupported opcode 152 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            PUSH(JS_NewString(ctx, "_origExit"));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, !JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 2; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_FALSE);
            frame->result = POP(); next_block = -1; break;
            }
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            PUSH(FROZEN_DUP(ctx, frame->locals[0]));
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "O_WRONLY");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 4 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func399_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func399, "frozen_func399", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func399", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func400(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func400_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func400_Frame;

static JSValue frozen_func400(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func400_Frame *frames = js_malloc(ctx, sizeof(frozen_func400_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func400_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_DupValue(ctx, this_val));
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            /* Unsupported opcode 152 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            PUSH(JS_NewString(ctx, "_origExit"));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, !JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 2; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_FALSE);
            frame->result = POP(); next_block = -1; break;
            }
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            PUSH(FROZEN_DUP(ctx, frame->locals[0]));
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "O_WRONLY");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 4 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func400_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func400, "frozen_func400", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func400", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func401(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func401_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func401_Frame;

static JSValue frozen_func401(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func401_Frame *frames = js_malloc(ctx, sizeof(frozen_func401_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func401_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_DupValue(ctx, this_val));
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            PUSH(FROZEN_DUP(ctx, frame->locals[0]));
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "O_WRONLY");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            case 1:
                /* Recursive call 5 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func401_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func401, "frozen_func401", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func401", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func404(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func404(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func404_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func404, "frozen_func404", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func404", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func405(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func405(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg1 */
    PUSH(argc > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 859); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* get_length */
    { JSValue obj = POP(); int64_t len = frozen_get_length(ctx, obj); FROZEN_FREE(ctx, obj); PUSH(JS_NewInt64(ctx, len)); }
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 859); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* get_length */
    { JSValue obj = POP(); int64_t len = frozen_get_length(ctx, obj); FROZEN_FREE(ctx, obj); PUSH(JS_NewInt64(ctx, len)); }
    { JSValue b = POP(), a = POP();
      if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
          int64_t diff = (int64_t)JS_VALUE_GET_INT(a) - JS_VALUE_GET_INT(b);
          if (likely(diff >= INT32_MIN && diff <= INT32_MAX)) {
              PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)diff));  /* Fast path: no alloc */
          } else {
              PUSH(JS_NewFloat64(ctx, (double)diff));  /* Overflow to float64 */
          }
      } else {
          JSValue r = frozen_sub(ctx, a, b);  /* Slow path */
          FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
          if (JS_IsException(r)) return r;
          PUSH(r);
      }
    }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func405_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func405, "frozen_func405", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func405", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func407(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func407(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func407_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func407, "frozen_func407", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func407", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func408(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func408(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func408_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func408, "frozen_func408", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func408", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func409(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func409(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg1 */
    PUSH(argc > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 859); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* get_length */
    { JSValue obj = POP(); int64_t len = frozen_get_length(ctx, obj); FROZEN_FREE(ctx, obj); PUSH(JS_NewInt64(ctx, len)); }
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 859); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* get_length */
    { JSValue obj = POP(); int64_t len = frozen_get_length(ctx, obj); FROZEN_FREE(ctx, obj); PUSH(JS_NewInt64(ctx, len)); }
    { JSValue b = POP(), a = POP();
      if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
          int64_t diff = (int64_t)JS_VALUE_GET_INT(a) - JS_VALUE_GET_INT(b);
          if (likely(diff >= INT32_MIN && diff <= INT32_MAX)) {
              PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)diff));  /* Fast path: no alloc */
          } else {
              PUSH(JS_NewFloat64(ctx, (double)diff));  /* Overflow to float64 */
          }
      } else {
          JSValue r = frozen_sub(ctx, a, b);  /* Slow path */
          FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
          if (JS_IsException(r)) return r;
          PUSH(r);
      }
    }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func409_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func409, "frozen_func409", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func409", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func411(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func411(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func411_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func411, "frozen_func411", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func411", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func412(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func412(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func412_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func412, "frozen_func412", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func412", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func419(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func419_Frame {
    JSValue args[2];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func419_Frame;

static JSValue frozen_func419(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func419_Frame *frames = js_malloc(ctx, sizeof(frozen_func419_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 2; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func419_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 2;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 2; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = JS_UNDEFINED;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            frame->result = POP(); next_block = -1; break;
            }
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            { JSValue arg0 = POP(); JSValue func = POP();
              JSValue ret = JS_Call(ctx, func, JS_UNDEFINED, 1, &arg0);
              FROZEN_FREE(ctx, func); FROZEN_FREE(ctx, arg0);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            frame->result = POP(); next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func419_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func419, "frozen_func419", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func419", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func423(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func423_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func423_Frame;

static JSValue frozen_func423(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func423_Frame *frames = js_malloc(ctx, sizeof(frozen_func423_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func423_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            PUSH(JS_NULL);
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 3 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func423_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func423, "frozen_func423", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func423", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func424(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func424_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func424_Frame;

static JSValue frozen_func424(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func424_Frame *frames = js_malloc(ctx, sizeof(frozen_func424_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func424_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func424_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func424, "frozen_func424", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func424", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func427(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func427_Frame {
    JSValue args[6];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func427_Frame;

static JSValue frozen_func427(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func427_Frame *frames = js_malloc(ctx, sizeof(frozen_func427_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 6; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func427_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 6;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
                /* Recursive call 0 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 1;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = JS_UNDEFINED;
                    frames[frame_depth].args[2] = JS_UNDEFINED;
                    frames[frame_depth].args[3] = JS_UNDEFINED;
                    frames[frame_depth].args[4] = JS_UNDEFINED;
                    frames[frame_depth].args[5] = JS_UNDEFINED;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 1:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "pos"));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 4; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 2;
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "writeUInt16BE"));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 4; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 3;
            break;
        case 3:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "writeUInt32BE"));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 5; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 4;
            break;
        case 4:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "hostname");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue method = POP(); JSValue this_obj = POP();
              JSValue ret = JS_Call(ctx, method, this_obj, 1, args);
              FROZEN_FREE(ctx, method); FROZEN_FREE(ctx, this_obj); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              frame->result = ret; next_block = -1; break; }
            break;
            }
            next_block = 5;
            break;
        case 5:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            frame->result = POP(); next_block = -1; break;
            }
            break;
        case 6:
            switch (frame->instr_offset) {
            case 0:
            /* Unsupported opcode 198 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            PUSH(JS_UNDEFINED); /* fclosure not supported */
            { JSValue v = POP(); JSValue c = stack[sp-1]; JSValue b = stack[sp-2]; JSValue a = stack[sp-3]; stack[sp-3] = v; stack[sp-2] = a; stack[sp-1] = b; PUSH(c); }
            { JSValue args[344 > 0 ? 344 : 1]; args[343] = POP(); args[342] = POP(); args[341] = POP(); args[340] = POP(); args[339] = POP(); args[338] = POP(); args[337] = POP(); args[336] = POP(); args[335] = POP(); args[334] = POP(); args[333] = POP(); args[332] = POP(); args[331] = POP(); args[330] = POP(); args[329] = POP(); args[328] = POP(); args[327] = POP(); args[326] = POP(); args[325] = POP(); args[324] = POP(); args[323] = POP(); args[322] = POP(); args[321] = POP(); args[320] = POP(); args[319] = POP(); args[318] = POP(); args[317] = POP(); args[316] = POP(); args[315] = POP(); args[314] = POP(); args[313] = POP(); args[312] = POP(); args[311] = POP(); args[310] = POP(); args[309] = POP(); args[308] = POP(); args[307] = POP(); args[306] = POP(); args[305] = POP(); args[304] = POP(); args[303] = POP(); args[302] = POP(); args[301] = POP(); args[300] = POP(); args[299] = POP(); args[298] = POP(); args[297] = POP(); args[296] = POP(); args[295] = POP(); args[294] = POP(); args[293] = POP(); args[292] = POP(); args[291] = POP(); args[290] = POP(); args[289] = POP(); args[288] = POP(); args[287] = POP(); args[286] = POP(); args[285] = POP(); args[284] = POP(); args[283] = POP(); args[282] = POP(); args[281] = POP(); args[280] = POP(); args[279] = POP(); args[278] = POP(); args[277] = POP(); args[276] = POP(); args[275] = POP(); args[274] = POP(); args[273] = POP(); args[272] = POP(); args[271] = POP(); args[270] = POP(); args[269] = POP(); args[268] = POP(); args[267] = POP(); args[266] = POP(); args[265] = POP(); args[264] = POP(); args[263] = POP(); args[262] = POP(); args[261] = POP(); args[260] = POP(); args[259] = POP(); args[258] = POP(); args[257] = POP(); args[256] = POP(); args[255] = POP(); args[254] = POP(); args[253] = POP(); args[252] = POP(); args[251] = POP(); args[250] = POP(); args[249] = POP(); args[248] = POP(); args[247] = POP(); args[246] = POP(); args[245] = POP(); args[244] = POP(); args[243] = POP(); args[242] = POP(); args[241] = POP(); args[240] = POP(); args[239] = POP(); args[238] = POP(); args[237] = POP(); args[236] = POP(); args[235] = POP(); args[234] = POP(); args[233] = POP(); args[232] = POP(); args[231] = POP(); args[230] = POP(); args[229] = POP(); args[228] = POP(); args[227] = POP(); args[226] = POP(); args[225] = POP(); args[224] = POP(); args[223] = POP(); args[222] = POP(); args[221] = POP(); args[220] = POP(); args[219] = POP(); args[218] = POP(); args[217] = POP(); args[216] = POP(); args[215] = POP(); args[214] = POP(); args[213] = POP(); args[212] = POP(); args[211] = POP(); args[210] = POP(); args[209] = POP(); args[208] = POP(); args[207] = POP(); args[206] = POP(); args[205] = POP(); args[204] = POP(); args[203] = POP(); args[202] = POP(); args[201] = POP(); args[200] = POP(); args[199] = POP(); args[198] = POP(); args[197] = POP(); args[196] = POP(); args[195] = POP(); args[194] = POP(); args[193] = POP(); args[192] = POP(); args[191] = POP(); args[190] = POP(); args[189] = POP(); args[188] = POP(); args[187] = POP(); args[186] = POP(); args[185] = POP(); args[184] = POP(); args[183] = POP(); args[182] = POP(); args[181] = POP(); args[180] = POP(); args[179] = POP(); args[178] = POP(); args[177] = POP(); args[176] = POP(); args[175] = POP(); args[174] = POP(); args[173] = POP(); args[172] = POP(); args[171] = POP(); args[170] = POP(); args[169] = POP(); args[168] = POP(); args[167] = POP(); args[166] = POP(); args[165] = POP(); args[164] = POP(); args[163] = POP(); args[162] = POP(); args[161] = POP(); args[160] = POP(); args[159] = POP(); args[158] = POP(); args[157] = POP(); args[156] = POP(); args[155] = POP(); args[154] = POP(); args[153] = POP(); args[152] = POP(); args[151] = POP(); args[150] = POP(); args[149] = POP(); args[148] = POP(); args[147] = POP(); args[146] = POP(); args[145] = POP(); args[144] = POP(); args[143] = POP(); args[142] = POP(); args[141] = POP(); args[140] = POP(); args[139] = POP(); args[138] = POP(); args[137] = POP(); args[136] = POP(); args[135] = POP(); args[134] = POP(); args[133] = POP(); args[132] = POP(); args[131] = POP(); args[130] = POP(); args[129] = POP(); args[128] = POP(); args[127] = POP(); args[126] = POP(); args[125] = POP(); args[124] = POP(); args[123] = POP(); args[122] = POP(); args[121] = POP(); args[120] = POP(); args[119] = POP(); args[118] = POP(); args[117] = POP(); args[116] = POP(); args[115] = POP(); args[114] = POP(); args[113] = POP(); args[112] = POP(); args[111] = POP(); args[110] = POP(); args[109] = POP(); args[108] = POP(); args[107] = POP(); args[106] = POP(); args[105] = POP(); args[104] = POP(); args[103] = POP(); args[102] = POP(); args[101] = POP(); args[100] = POP(); args[99] = POP(); args[98] = POP(); args[97] = POP(); args[96] = POP(); args[95] = POP(); args[94] = POP(); args[93] = POP(); args[92] = POP(); args[91] = POP(); args[90] = POP(); args[89] = POP(); args[88] = POP(); args[87] = POP(); args[86] = POP(); args[85] = POP(); args[84] = POP(); args[83] = POP(); args[82] = POP(); args[81] = POP(); args[80] = POP(); args[79] = POP(); args[78] = POP(); args[77] = POP(); args[76] = POP(); args[75] = POP(); args[74] = POP(); args[73] = POP(); args[72] = POP(); args[71] = POP(); args[70] = POP(); args[69] = POP(); args[68] = POP(); args[67] = POP(); args[66] = POP(); args[65] = POP(); args[64] = POP(); args[63] = POP(); args[62] = POP(); args[61] = POP(); args[60] = POP(); args[59] = POP(); args[58] = POP(); args[57] = POP(); args[56] = POP(); args[55] = POP(); args[54] = POP(); args[53] = POP(); args[52] = POP(); args[51] = POP(); args[50] = POP(); args[49] = POP(); args[48] = POP(); args[47] = POP(); args[46] = POP(); args[45] = POP(); args[44] = POP(); args[43] = POP(); args[42] = POP(); args[41] = POP(); args[40] = POP(); args[39] = POP(); args[38] = POP(); args[37] = POP(); args[36] = POP(); args[35] = POP(); args[34] = POP(); args[33] = POP(); args[32] = POP(); args[31] = POP(); args[30] = POP(); args[29] = POP(); args[28] = POP(); args[27] = POP(); args[26] = POP(); args[25] = POP(); args[24] = POP(); args[23] = POP(); args[22] = POP(); args[21] = POP(); args[20] = POP(); args[19] = POP(); args[18] = POP(); args[17] = POP(); args[16] = POP(); args[15] = POP(); args[14] = POP(); args[13] = POP(); args[12] = POP(); args[11] = POP(); args[10] = POP(); args[9] = POP(); args[8] = POP(); args[7] = POP(); args[6] = POP(); args[5] = POP(); args[4] = POP(); args[3] = POP(); args[2] = POP(); args[1] = POP(); args[0] = POP(); JSValue method = POP(); JSValue this_obj = POP();
              JSValue ret = JS_Call(ctx, method, this_obj, 344, args);
              FROZEN_FREE(ctx, method); FROZEN_FREE(ctx, this_obj); FROZEN_FREE(ctx, args[0]); FROZEN_FREE(ctx, args[1]); FROZEN_FREE(ctx, args[2]); FROZEN_FREE(ctx, args[3]); FROZEN_FREE(ctx, args[4]); FROZEN_FREE(ctx, args[5]); FROZEN_FREE(ctx, args[6]); FROZEN_FREE(ctx, args[7]); FROZEN_FREE(ctx, args[8]); FROZEN_FREE(ctx, args[9]); FROZEN_FREE(ctx, args[10]); FROZEN_FREE(ctx, args[11]); FROZEN_FREE(ctx, args[12]); FROZEN_FREE(ctx, args[13]); FROZEN_FREE(ctx, args[14]); FROZEN_FREE(ctx, args[15]); FROZEN_FREE(ctx, args[16]); FROZEN_FREE(ctx, args[17]); FROZEN_FREE(ctx, args[18]); FROZEN_FREE(ctx, args[19]); FROZEN_FREE(ctx, args[20]); FROZEN_FREE(ctx, args[21]); FROZEN_FREE(ctx, args[22]); FROZEN_FREE(ctx, args[23]); FROZEN_FREE(ctx, args[24]); FROZEN_FREE(ctx, args[25]); FROZEN_FREE(ctx, args[26]); FROZEN_FREE(ctx, args[27]); FROZEN_FREE(ctx, args[28]); FROZEN_FREE(ctx, args[29]); FROZEN_FREE(ctx, args[30]); FROZEN_FREE(ctx, args[31]); FROZEN_FREE(ctx, args[32]); FROZEN_FREE(ctx, args[33]); FROZEN_FREE(ctx, args[34]); FROZEN_FREE(ctx, args[35]); FROZEN_FREE(ctx, args[36]); FROZEN_FREE(ctx, args[37]); FROZEN_FREE(ctx, args[38]); FROZEN_FREE(ctx, args[39]); FROZEN_FREE(ctx, args[40]); FROZEN_FREE(ctx, args[41]); FROZEN_FREE(ctx, args[42]); FROZEN_FREE(ctx, args[43]); FROZEN_FREE(ctx, args[44]); FROZEN_FREE(ctx, args[45]); FROZEN_FREE(ctx, args[46]); FROZEN_FREE(ctx, args[47]); FROZEN_FREE(ctx, args[48]); FROZEN_FREE(ctx, args[49]); FROZEN_FREE(ctx, args[50]); FROZEN_FREE(ctx, args[51]); FROZEN_FREE(ctx, args[52]); FROZEN_FREE(ctx, args[53]); FROZEN_FREE(ctx, args[54]); FROZEN_FREE(ctx, args[55]); FROZEN_FREE(ctx, args[56]); FROZEN_FREE(ctx, args[57]); FROZEN_FREE(ctx, args[58]); FROZEN_FREE(ctx, args[59]); FROZEN_FREE(ctx, args[60]); FROZEN_FREE(ctx, args[61]); FROZEN_FREE(ctx, args[62]); FROZEN_FREE(ctx, args[63]); FROZEN_FREE(ctx, args[64]); FROZEN_FREE(ctx, args[65]); FROZEN_FREE(ctx, args[66]); FROZEN_FREE(ctx, args[67]); FROZEN_FREE(ctx, args[68]); FROZEN_FREE(ctx, args[69]); FROZEN_FREE(ctx, args[70]); FROZEN_FREE(ctx, args[71]); FROZEN_FREE(ctx, args[72]); FROZEN_FREE(ctx, args[73]); FROZEN_FREE(ctx, args[74]); FROZEN_FREE(ctx, args[75]); FROZEN_FREE(ctx, args[76]); FROZEN_FREE(ctx, args[77]); FROZEN_FREE(ctx, args[78]); FROZEN_FREE(ctx, args[79]); FROZEN_FREE(ctx, args[80]); FROZEN_FREE(ctx, args[81]); FROZEN_FREE(ctx, args[82]); FROZEN_FREE(ctx, args[83]); FROZEN_FREE(ctx, args[84]); FROZEN_FREE(ctx, args[85]); FROZEN_FREE(ctx, args[86]); FROZEN_FREE(ctx, args[87]); FROZEN_FREE(ctx, args[88]); FROZEN_FREE(ctx, args[89]); FROZEN_FREE(ctx, args[90]); FROZEN_FREE(ctx, args[91]); FROZEN_FREE(ctx, args[92]); FROZEN_FREE(ctx, args[93]); FROZEN_FREE(ctx, args[94]); FROZEN_FREE(ctx, args[95]); FROZEN_FREE(ctx, args[96]); FROZEN_FREE(ctx, args[97]); FROZEN_FREE(ctx, args[98]); FROZEN_FREE(ctx, args[99]); FROZEN_FREE(ctx, args[100]); FROZEN_FREE(ctx, args[101]); FROZEN_FREE(ctx, args[102]); FROZEN_FREE(ctx, args[103]); FROZEN_FREE(ctx, args[104]); FROZEN_FREE(ctx, args[105]); FROZEN_FREE(ctx, args[106]); FROZEN_FREE(ctx, args[107]); FROZEN_FREE(ctx, args[108]); FROZEN_FREE(ctx, args[109]); FROZEN_FREE(ctx, args[110]); FROZEN_FREE(ctx, args[111]); FROZEN_FREE(ctx, args[112]); FROZEN_FREE(ctx, args[113]); FROZEN_FREE(ctx, args[114]); FROZEN_FREE(ctx, args[115]); FROZEN_FREE(ctx, args[116]); FROZEN_FREE(ctx, args[117]); FROZEN_FREE(ctx, args[118]); FROZEN_FREE(ctx, args[119]); FROZEN_FREE(ctx, args[120]); FROZEN_FREE(ctx, args[121]); FROZEN_FREE(ctx, args[122]); FROZEN_FREE(ctx, args[123]); FROZEN_FREE(ctx, args[124]); FROZEN_FREE(ctx, args[125]); FROZEN_FREE(ctx, args[126]); FROZEN_FREE(ctx, args[127]); FROZEN_FREE(ctx, args[128]); FROZEN_FREE(ctx, args[129]); FROZEN_FREE(ctx, args[130]); FROZEN_FREE(ctx, args[131]); FROZEN_FREE(ctx, args[132]); FROZEN_FREE(ctx, args[133]); FROZEN_FREE(ctx, args[134]); FROZEN_FREE(ctx, args[135]); FROZEN_FREE(ctx, args[136]); FROZEN_FREE(ctx, args[137]); FROZEN_FREE(ctx, args[138]); FROZEN_FREE(ctx, args[139]); FROZEN_FREE(ctx, args[140]); FROZEN_FREE(ctx, args[141]); FROZEN_FREE(ctx, args[142]); FROZEN_FREE(ctx, args[143]); FROZEN_FREE(ctx, args[144]); FROZEN_FREE(ctx, args[145]); FROZEN_FREE(ctx, args[146]); FROZEN_FREE(ctx, args[147]); FROZEN_FREE(ctx, args[148]); FROZEN_FREE(ctx, args[149]); FROZEN_FREE(ctx, args[150]); FROZEN_FREE(ctx, args[151]); FROZEN_FREE(ctx, args[152]); FROZEN_FREE(ctx, args[153]); FROZEN_FREE(ctx, args[154]); FROZEN_FREE(ctx, args[155]); FROZEN_FREE(ctx, args[156]); FROZEN_FREE(ctx, args[157]); FROZEN_FREE(ctx, args[158]); FROZEN_FREE(ctx, args[159]); FROZEN_FREE(ctx, args[160]); FROZEN_FREE(ctx, args[161]); FROZEN_FREE(ctx, args[162]); FROZEN_FREE(ctx, args[163]); FROZEN_FREE(ctx, args[164]); FROZEN_FREE(ctx, args[165]); FROZEN_FREE(ctx, args[166]); FROZEN_FREE(ctx, args[167]); FROZEN_FREE(ctx, args[168]); FROZEN_FREE(ctx, args[169]); FROZEN_FREE(ctx, args[170]); FROZEN_FREE(ctx, args[171]); FROZEN_FREE(ctx, args[172]); FROZEN_FREE(ctx, args[173]); FROZEN_FREE(ctx, args[174]); FROZEN_FREE(ctx, args[175]); FROZEN_FREE(ctx, args[176]); FROZEN_FREE(ctx, args[177]); FROZEN_FREE(ctx, args[178]); FROZEN_FREE(ctx, args[179]); FROZEN_FREE(ctx, args[180]); FROZEN_FREE(ctx, args[181]); FROZEN_FREE(ctx, args[182]); FROZEN_FREE(ctx, args[183]); FROZEN_FREE(ctx, args[184]); FROZEN_FREE(ctx, args[185]); FROZEN_FREE(ctx, args[186]); FROZEN_FREE(ctx, args[187]); FROZEN_FREE(ctx, args[188]); FROZEN_FREE(ctx, args[189]); FROZEN_FREE(ctx, args[190]); FROZEN_FREE(ctx, args[191]); FROZEN_FREE(ctx, args[192]); FROZEN_FREE(ctx, args[193]); FROZEN_FREE(ctx, args[194]); FROZEN_FREE(ctx, args[195]); FROZEN_FREE(ctx, args[196]); FROZEN_FREE(ctx, args[197]); FROZEN_FREE(ctx, args[198]); FROZEN_FREE(ctx, args[199]); FROZEN_FREE(ctx, args[200]); FROZEN_FREE(ctx, args[201]); FROZEN_FREE(ctx, args[202]); FROZEN_FREE(ctx, args[203]); FROZEN_FREE(ctx, args[204]); FROZEN_FREE(ctx, args[205]); FROZEN_FREE(ctx, args[206]); FROZEN_FREE(ctx, args[207]); FROZEN_FREE(ctx, args[208]); FROZEN_FREE(ctx, args[209]); FROZEN_FREE(ctx, args[210]); FROZEN_FREE(ctx, args[211]); FROZEN_FREE(ctx, args[212]); FROZEN_FREE(ctx, args[213]); FROZEN_FREE(ctx, args[214]); FROZEN_FREE(ctx, args[215]); FROZEN_FREE(ctx, args[216]); FROZEN_FREE(ctx, args[217]); FROZEN_FREE(ctx, args[218]); FROZEN_FREE(ctx, args[219]); FROZEN_FREE(ctx, args[220]); FROZEN_FREE(ctx, args[221]); FROZEN_FREE(ctx, args[222]); FROZEN_FREE(ctx, args[223]); FROZEN_FREE(ctx, args[224]); FROZEN_FREE(ctx, args[225]); FROZEN_FREE(ctx, args[226]); FROZEN_FREE(ctx, args[227]); FROZEN_FREE(ctx, args[228]); FROZEN_FREE(ctx, args[229]); FROZEN_FREE(ctx, args[230]); FROZEN_FREE(ctx, args[231]); FROZEN_FREE(ctx, args[232]); FROZEN_FREE(ctx, args[233]); FROZEN_FREE(ctx, args[234]); FROZEN_FREE(ctx, args[235]); FROZEN_FREE(ctx, args[236]); FROZEN_FREE(ctx, args[237]); FROZEN_FREE(ctx, args[238]); FROZEN_FREE(ctx, args[239]); FROZEN_FREE(ctx, args[240]); FROZEN_FREE(ctx, args[241]); FROZEN_FREE(ctx, args[242]); FROZEN_FREE(ctx, args[243]); FROZEN_FREE(ctx, args[244]); FROZEN_FREE(ctx, args[245]); FROZEN_FREE(ctx, args[246]); FROZEN_FREE(ctx, args[247]); FROZEN_FREE(ctx, args[248]); FROZEN_FREE(ctx, args[249]); FROZEN_FREE(ctx, args[250]); FROZEN_FREE(ctx, args[251]); FROZEN_FREE(ctx, args[252]); FROZEN_FREE(ctx, args[253]); FROZEN_FREE(ctx, args[254]); FROZEN_FREE(ctx, args[255]); FROZEN_FREE(ctx, args[256]); FROZEN_FREE(ctx, args[257]); FROZEN_FREE(ctx, args[258]); FROZEN_FREE(ctx, args[259]); FROZEN_FREE(ctx, args[260]); FROZEN_FREE(ctx, args[261]); FROZEN_FREE(ctx, args[262]); FROZEN_FREE(ctx, args[263]); FROZEN_FREE(ctx, args[264]); FROZEN_FREE(ctx, args[265]); FROZEN_FREE(ctx, args[266]); FROZEN_FREE(ctx, args[267]); FROZEN_FREE(ctx, args[268]); FROZEN_FREE(ctx, args[269]); FROZEN_FREE(ctx, args[270]); FROZEN_FREE(ctx, args[271]); FROZEN_FREE(ctx, args[272]); FROZEN_FREE(ctx, args[273]); FROZEN_FREE(ctx, args[274]); FROZEN_FREE(ctx, args[275]); FROZEN_FREE(ctx, args[276]); FROZEN_FREE(ctx, args[277]); FROZEN_FREE(ctx, args[278]); FROZEN_FREE(ctx, args[279]); FROZEN_FREE(ctx, args[280]); FROZEN_FREE(ctx, args[281]); FROZEN_FREE(ctx, args[282]); FROZEN_FREE(ctx, args[283]); FROZEN_FREE(ctx, args[284]); FROZEN_FREE(ctx, args[285]); FROZEN_FREE(ctx, args[286]); FROZEN_FREE(ctx, args[287]); FROZEN_FREE(ctx, args[288]); FROZEN_FREE(ctx, args[289]); FROZEN_FREE(ctx, args[290]); FROZEN_FREE(ctx, args[291]); FROZEN_FREE(ctx, args[292]); FROZEN_FREE(ctx, args[293]); FROZEN_FREE(ctx, args[294]); FROZEN_FREE(ctx, args[295]); FROZEN_FREE(ctx, args[296]); FROZEN_FREE(ctx, args[297]); FROZEN_FREE(ctx, args[298]); FROZEN_FREE(ctx, args[299]); FROZEN_FREE(ctx, args[300]); FROZEN_FREE(ctx, args[301]); FROZEN_FREE(ctx, args[302]); FROZEN_FREE(ctx, args[303]); FROZEN_FREE(ctx, args[304]); FROZEN_FREE(ctx, args[305]); FROZEN_FREE(ctx, args[306]); FROZEN_FREE(ctx, args[307]); FROZEN_FREE(ctx, args[308]); FROZEN_FREE(ctx, args[309]); FROZEN_FREE(ctx, args[310]); FROZEN_FREE(ctx, args[311]); FROZEN_FREE(ctx, args[312]); FROZEN_FREE(ctx, args[313]); FROZEN_FREE(ctx, args[314]); FROZEN_FREE(ctx, args[315]); FROZEN_FREE(ctx, args[316]); FROZEN_FREE(ctx, args[317]); FROZEN_FREE(ctx, args[318]); FROZEN_FREE(ctx, args[319]); FROZEN_FREE(ctx, args[320]); FROZEN_FREE(ctx, args[321]); FROZEN_FREE(ctx, args[322]); FROZEN_FREE(ctx, args[323]); FROZEN_FREE(ctx, args[324]); FROZEN_FREE(ctx, args[325]); FROZEN_FREE(ctx, args[326]); FROZEN_FREE(ctx, args[327]); FROZEN_FREE(ctx, args[328]); FROZEN_FREE(ctx, args[329]); FROZEN_FREE(ctx, args[330]); FROZEN_FREE(ctx, args[331]); FROZEN_FREE(ctx, args[332]); FROZEN_FREE(ctx, args[333]); FROZEN_FREE(ctx, args[334]); FROZEN_FREE(ctx, args[335]); FROZEN_FREE(ctx, args[336]); FROZEN_FREE(ctx, args[337]); FROZEN_FREE(ctx, args[338]); FROZEN_FREE(ctx, args[339]); FROZEN_FREE(ctx, args[340]); FROZEN_FREE(ctx, args[341]); FROZEN_FREE(ctx, args[342]); FROZEN_FREE(ctx, args[343]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              frame->result = ret; next_block = -1; break; }
            break;
            }
            next_block = 7;
            break;
        case 7:
            switch (frame->instr_offset) {
            case 0:
            { JSValue b = POP(), a = POP(); PUSH(JS_MKVAL(JS_TAG_INT, JS_VALUE_GET_INT(a) ^ JS_VALUE_GET_INT(b))); }
            /* put_var: atom 2061057638 out of bounds */
            { FROZEN_FREE(ctx, POP()); }
            { FROZEN_FREE(ctx, frame->locals[2]); frame->locals[2] = POP(); }
            { JSValue exc = JS_GetException(ctx); PUSH(exc); }
            break;
            }
            next_block = 8;
            break;
        case 8:
            switch (frame->instr_offset) {
            case 0:
            /* Unsupported opcode 123 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { JSValue e = stack[sp-1], d = stack[sp-2], c = stack[sp-3], b = stack[sp-4], a = stack[sp-5]; stack[sp-5] = b; stack[sp-4] = c; stack[sp-3] = d; stack[sp-2] = e; stack[sp-1] = a; }
            break;
            }
            next_block = 9;
            break;
        case 9:
            switch (frame->instr_offset) {
            }
            next_block = -1;
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func427_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func427, "frozen_func427", 6);
    JS_SetPropertyStr(ctx, global, "frozen_func427", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func430(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func430(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* is_null */
    { JSValue v = POP(); PUSH(JS_NewBool(ctx, JS_IsNull(v))); FROZEN_FREE(ctx, v); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func430_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func430, "frozen_func430", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func430", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func435(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func435(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* typeof_is_function */
    { JSValue v = POP(); PUSH(JS_NewBool(ctx, JS_IsFunction(ctx, v))); FROZEN_FREE(ctx, v); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func435_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func435, "frozen_func435", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func435", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func439(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func439(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 720); if (JS_IsException(val)) return val; PUSH(val); }
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* get_arg1 */
    PUSH(argc > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func439_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func439, "frozen_func439", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func439", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func442(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func442(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 726); if (JS_IsException(val)) return val; PUSH(val); }
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* get_arg1 */
    PUSH(argc > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func442_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func442, "frozen_func442", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func442", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func443(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func443(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    PUSH(JS_UNDEFINED); /* TODO: closure var_ref */
    /* strict_neq */
    { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, frozen_neq(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
    /* dup */
    { JSValue tmp = TOP(); PUSH(FROZEN_DUP(ctx, tmp)); }
    { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); goto block_2; } JS_FreeValue(ctx, cond); }
block_1:
    /* drop */
    FROZEN_FREE(ctx, POP());
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 899); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    PUSH(JS_UNDEFINED); /* TODO: closure var_ref */
    /* strict_neq */
    { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, frozen_neq(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
block_2:
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func443_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func443, "frozen_func443", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func443", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func447(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func447(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 897); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* get_array_el */
    { JSValue idx = POP(); JSValue obj = POP(); JSValue val = frozen_array_get(ctx, obj, idx); FROZEN_FREE(ctx, obj); FROZEN_FREE(ctx, idx); if (JS_IsException(val)) return val; PUSH(val); }
    /* dup */
    { JSValue tmp = TOP(); PUSH(FROZEN_DUP(ctx, tmp)); }
    { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); goto block_2; } JS_FreeValue(ctx, cond); }
block_1:
    /* drop */
    FROZEN_FREE(ctx, POP());
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 897); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* get_array_el */
    { JSValue idx = POP(); JSValue obj = POP(); JSValue val = frozen_array_get(ctx, obj, idx); FROZEN_FREE(ctx, obj); FROZEN_FREE(ctx, idx); if (JS_IsException(val)) return val; PUSH(val); }
    /* get_length */
    { JSValue obj = POP(); int64_t len = frozen_get_length(ctx, obj); FROZEN_FREE(ctx, obj); PUSH(JS_NewInt64(ctx, len)); }
block_2:
    /* dup */
    { JSValue tmp = TOP(); PUSH(FROZEN_DUP(ctx, tmp)); }
    { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); goto block_4; } JS_FreeValue(ctx, cond); }
block_3:
    /* drop */
    FROZEN_FREE(ctx, POP());
    /* push_0 */
    PUSH(JS_MKVAL(JS_TAG_INT, 0));
block_4:
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func447_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func447, "frozen_func447", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func447", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func448(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func448(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 899); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* dup */
    { JSValue tmp = TOP(); PUSH(FROZEN_DUP(ctx, tmp)); }
    { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); goto block_2; } JS_FreeValue(ctx, cond); }
block_1:
    /* drop */
    FROZEN_FREE(ctx, POP());
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
block_2:
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func448_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func448, "frozen_func448", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func448", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func450(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func450(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 898, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func450_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func450, "frozen_func450", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func450", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func451(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func451(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 898); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func451_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func451, "frozen_func451", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func451", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func453(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func453(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); goto block_3; } JS_FreeValue(ctx, cond); }
block_1:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 906); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* typeof_is_function */
    { JSValue v = POP(); PUSH(JS_NewBool(ctx, JS_IsFunction(ctx, v))); FROZEN_FREE(ctx, v); }
    { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); goto block_3; } JS_FreeValue(ctx, cond); }
block_2:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 906); if (JS_IsException(val)) return val; PUSH(val); }
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }
block_3:
    PUSH(JS_MKVAL(JS_TAG_INT, 10));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func453_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func453, "frozen_func453", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func453", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func454(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func454(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    PUSH(JS_UNDEFINED); /* TODO: closure var_ref */
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 505); if (JS_IsException(val)) return val; PUSH(val); }
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func454_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func454, "frozen_func454", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func454", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func455(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func455(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    PUSH(JS_UNDEFINED); /* TODO: closure var_ref */
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 704); if (JS_IsException(val)) return val; PUSH(val); }
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func455_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func455, "frozen_func455", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func455", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func459(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func459(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* null */
    PUSH(JS_NULL);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func459_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func459, "frozen_func459", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func459", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func466(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func466(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func466_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func466, "frozen_func466", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func466", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func468(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func468(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg2 */
    PUSH(argc > 2 ? FROZEN_DUP(ctx, argv[2]) : JS_UNDEFINED);
    { JSValue func = POP(); JSValue ret = JS_Call(ctx, func, JS_UNDEFINED, 0, NULL); JS_FreeValue(ctx, func); if (JS_IsException(ret)) return ret; PUSH(ret); }
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func468_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func468, "frozen_func468", 3);
    JS_SetPropertyStr(ctx, global, "frozen_func468", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func471(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func471(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* null */
    PUSH(JS_NULL);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func471_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func471, "frozen_func471", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func471", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func472(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func472(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* push_true */
    PUSH(JS_TRUE);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func472_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func472, "frozen_func472", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func472", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func474(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func474(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg2 */
    PUSH(argc > 2 ? FROZEN_DUP(ctx, argv[2]) : JS_UNDEFINED);
    /* null */
    PUSH(JS_NULL);
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue args[2]; args[1] = POP(); args[0] = POP(); JSValue func = POP(); JSValue ret = JS_Call(ctx, func, JS_UNDEFINED, 2, args); JS_FreeValue(ctx, func); JS_FreeValue(ctx, args[0]); JS_FreeValue(ctx, args[1]); if (JS_IsException(ret)) return ret; PUSH(ret); }
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func474_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func474, "frozen_func474", 3);
    JS_SetPropertyStr(ctx, global, "frozen_func474", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func479(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func479(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    PUSH(JS_UNDEFINED); /* TODO: closure var_ref */
    /* strict_neq */
    { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, frozen_neq(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func479_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func479, "frozen_func479", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func479", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func481(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func481(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func481_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func481, "frozen_func481", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func481", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func482(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func482(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func482_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func482, "frozen_func482", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func482", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func485(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func485(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func485_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func485, "frozen_func485", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func485", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func486(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func486(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func486_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func486, "frozen_func486", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func486", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func488(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func488_Frame {
    JSValue args[2];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[4];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func488_Frame;

static JSValue frozen_func488(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func488_Frame *frames = js_malloc(ctx, sizeof(frozen_func488_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 2; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 4; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func488_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 2;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[0] = JS_UNINITIALIZED;
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 3 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = JS_UNDEFINED;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 4; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { FROZEN_FREE(ctx, frame->args[0]); frame->args[0] = POP(); }
            PUSH(JS_UNDEFINED);
            /* Unsupported opcode 146 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { FROZEN_FREE(ctx, POP()); }
            { FROZEN_FREE(ctx, POP()); }
            PUSH(JS_UNDEFINED);
            PUSH(JS_MKVAL(JS_TAG_INT, 30));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, frozen_lte(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 2; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            PUSH(JS_NewString(ctx, "deflateDynamicTableSize"));
            PUSH(JS_UNDEFINED);
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            PUSH(JS_NewString(ctx, "p"));
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            { JSValue arg0 = POP(); JSValue func = POP();
              JSValue ret = JS_Call(ctx, func, JS_UNDEFINED, 1, &arg0);
              FROZEN_FREE(ctx, func); FROZEN_FREE(ctx, arg0);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { FROZEN_FREE(ctx, POP()); }
            break;
            }
            next_block = 2;
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            /* Unsupported opcode 152 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            PUSH(JS_NewString(ctx, "_origExit"));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 4; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 3;
            break;
        case 3:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            next_block = 6; break;
            }
            break;
        case 4:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 6; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 5;
            break;
        case 5:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, POP()); }
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, ", mimeType=");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            break;
            }
            next_block = 6;
            break;
        case 6:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "inflateDynamicTableSize");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = POP(); PUSH(JS_NewBool(ctx, JS_IsFunction(ctx, v))); FROZEN_FREE(ctx, v); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 12; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 7;
            break;
        case 7:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[1] = JS_UNINITIALIZED;
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "inflateDynamicTableSize");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            {
              JSValue args[1];
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 1, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = POP(); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "open"));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 9; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 8;
            break;
        case 8:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, POP()); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, ", dataLen="));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            break;
            }
            next_block = 9;
            break;
        case 9:
            switch (frame->instr_offset) {
            case 0:
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 11; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 10;
            break;
        case 10:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            frame->result = POP(); next_block = -1; break;
            }
            break;
        case 11:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "__initialize");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            {
              JSValue args[1];
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 1, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            frame->result = POP(); next_block = -1; break;
            }
            break;
        case 12:
            switch (frame->instr_offset) {
            case 0:
            /* Unsupported opcode 246 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 21; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 13;
            break;
        case 13:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "settings");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 21; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 14;
            break;
        case 14:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[2] = JS_UNINITIALIZED;
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "settings");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            {
              JSValue args[1];
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 1, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, frame->locals[2]); frame->locals[2] = POP(); }
            { JSValue v = locals[2];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            /* Unsupported opcode 245 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 16; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 15;
            break;
        case 15:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[3] = JS_UNINITIALIZED;
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "lastStreamId"));
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue ctor = POP();
              JSValue ret = JS_CallConstructor(ctx, ctor, 1, args);
              FROZEN_FREE(ctx, ctor); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { FROZEN_FREE(ctx, frame->locals[3]); frame->locals[3] = POP(); }
            { JSValue v = locals[3];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "copy"));
            { JSValue val = POP(); JSValue obj = POP();
              int ret = JS_SetPropertyStr(ctx, obj, "_transformer", val);
              FROZEN_FREE(ctx, obj);
              if (ret < 0) { next_block = -1; frame->result = JS_EXCEPTION; break; } }
            { JSValue v = locals[3];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = 16;
            break;
        case 16:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "open"));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 18; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 17;
            break;
        case 17:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, POP()); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, ", dataLen="));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            break;
            }
            next_block = 18;
            break;
        case 18:
            switch (frame->instr_offset) {
            case 0:
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 20; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 19;
            break;
        case 19:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[2];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            frame->result = POP(); next_block = -1; break;
            }
            break;
        case 20:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "__initialize");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[2];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            {
              JSValue args[1];
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 1, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            frame->result = POP(); next_block = -1; break;
            }
            break;
        case 21:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "session"));
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "inflateDynamicTableSize");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            /* Unsupported opcode 152 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue ctor = POP();
              JSValue ret = JS_CallConstructor(ctx, ctor, 1, args);
              FROZEN_FREE(ctx, ctor); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = -1;
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func488_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func488, "frozen_func488", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func488", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func489(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func489_Frame {
    JSValue args[3];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[8];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func489_Frame;

static JSValue frozen_func489(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func489_Frame *frames = js_malloc(ctx, sizeof(frozen_func489_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 3; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 8; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func489_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 3;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[0] = JS_UNINITIALIZED;
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            /* Unsupported opcode 152 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            PUSH(JS_NewString(ctx, "_origExit"));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 2; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = JS_UNDEFINED;
                    frames[frame_depth].args[2] = JS_UNDEFINED;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 8; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { FROZEN_FREE(ctx, frame->args[0]); frame->args[0] = POP(); }
            break;
            }
            next_block = 2;
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            /* Unsupported opcode 152 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            PUSH(JS_NewString(ctx, "_origExit"));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 4; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 3;
            break;
        case 3:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            next_block = 5; break;
            }
            break;
        case 4:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = JS_UNDEFINED;
                    frames[frame_depth].args[2] = JS_UNDEFINED;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 8; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            }
            next_block = 5;
            break;
        case 5:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            /* Unsupported opcode 152 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            PUSH(JS_NewString(ctx, "_edgeboxKeepalive"));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 0; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 6;
            break;
        case 6:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[6] = JS_UNINITIALIZED;
            frame->locals[2] = JS_UNINITIALIZED;
            frame->locals[1] = JS_UNINITIALIZED;
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = POP(); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "dataMatch");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 10; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 7;
            break;
        case 7:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, POP()); }
            /* Unsupported opcode 246 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 9; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 8;
            break;
        case 8:
            switch (frame->instr_offset) {
            case 0:
            next_block = 10; break;
            }
            break;
        case 9:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NULL);
            break;
            }
            next_block = 10;
            break;
        case 10:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, frame->locals[2]); frame->locals[2] = POP(); }
            { JSValue v = locals[2];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 14; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 11;
            break;
        case 11:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[2];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "destroy");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = POP(); PUSH(JS_NewBool(ctx, JS_IsFunction(ctx, v))); FROZEN_FREE(ctx, v); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 14; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 12;
            break;
        case 12:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_MKVAL(JS_TAG_INT, 100));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, frozen_lt(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 14; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 13;
            break;
        case 13:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[5] = JS_UNINITIALIZED;
            frame->locals[4] = JS_UNINITIALIZED;
            frame->locals[3] = JS_UNINITIALIZED;
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue args[0 > 0 ? 0 : 1]; JSValue ctor = POP();
              JSValue ret = JS_CallConstructor(ctx, ctor, 0, args);
              FROZEN_FREE(ctx, ctor);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { FROZEN_FREE(ctx, frame->locals[3]); frame->locals[3] = POP(); }
            { JSValue v = locals[3];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "endsWith");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            {
              JSValue args[1];
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 1, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "array");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { FROZEN_FREE(ctx, frame->locals[4]); frame->locals[4] = POP(); }
            { JSValue v = locals[2];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "destroy");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue v = locals[4];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_MKVAL(JS_TAG_INT, 0));
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            /* Unsupported opcode 235 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            {
              JSValue args[4];
              args[3] = POP();
              args[2] = POP();
              args[1] = POP();
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 4, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              FROZEN_FREE(ctx, args[1]);
              FROZEN_FREE(ctx, args[2]);
              FROZEN_FREE(ctx, args[3]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, frame->locals[5]); frame->locals[5] = POP(); }
            { JSValue v = locals[5];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            frame->result = POP(); next_block = -1; break;
            }
            break;
        case 14:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "http2");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 16; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 15;
            break;
        case 15:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "http2");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue idx = POP(); JSValue arr = POP();
              int64_t i; JS_ToInt64(ctx, &i, idx);
              JSValue ret = JS_GetPropertyInt64(ctx, arr, i);
              FROZEN_FREE(ctx, arr); FROZEN_FREE(ctx, idx);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            next_block = 17; break;
            }
            break;
        case 16:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NULL);
            break;
            }
            next_block = 17;
            break;
        case 17:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, frame->locals[6]); frame->locals[6] = POP(); }
            { JSValue v = locals[6];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 20; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 18;
            break;
        case 18:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "readUInt16BE");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = POP(); PUSH(JS_NewBool(ctx, JS_IsFunction(ctx, v))); FROZEN_FREE(ctx, v); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 20; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 19;
            break;
        case 19:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "readUInt16BE");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[6];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue args[2 > 0 ? 2 : 1]; args[1] = POP(); args[0] = POP(); JSValue method = POP(); JSValue this_obj = POP();
              JSValue ret = JS_Call(ctx, method, this_obj, 2, args);
              FROZEN_FREE(ctx, method); FROZEN_FREE(ctx, this_obj); FROZEN_FREE(ctx, args[0]); FROZEN_FREE(ctx, args[1]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              frame->result = ret; next_block = -1; break; }
            break;
            }
            next_block = 20;
            break;
        case 20:
            switch (frame->instr_offset) {
            case 0:
            frame->result = JS_UNDEFINED; next_block = -1; break;
            }
            break;
        case 21:
            switch (frame->instr_offset) {
            case 0:
            break;
            }
            next_block = 22;
            break;
        case 22:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "readUInt16BE");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = POP(); PUSH(JS_NewBool(ctx, JS_IsFunction(ctx, v))); FROZEN_FREE(ctx, v); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 24; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 23;
            break;
        case 23:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "readUInt16BE");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue args[2 > 0 ? 2 : 1]; args[1] = POP(); args[0] = POP(); JSValue method = POP(); JSValue this_obj = POP();
              JSValue ret = JS_Call(ctx, method, this_obj, 2, args);
              FROZEN_FREE(ctx, method); FROZEN_FREE(ctx, this_obj); FROZEN_FREE(ctx, args[0]); FROZEN_FREE(ctx, args[1]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              frame->result = ret; next_block = -1; break; }
            break;
            }
            next_block = 24;
            break;
        case 24:
            switch (frame->instr_offset) {
            case 0:
            /* Unsupported opcode 246 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 29; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 25;
            break;
        case 25:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "readUInt32BE");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 29; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 26;
            break;
        case 26:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[7] = JS_UNINITIALIZED;
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "readUInt32BE");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(JS_NewString(ctx, "_socketId"));
            {
              JSValue args[2];
              args[1] = POP();
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 2, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              FROZEN_FREE(ctx, args[1]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, frame->locals[7]); frame->locals[7] = POP(); }
            { JSValue v = locals[7];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue a = POP(); PUSH(JS_NewBool(ctx, !JS_ToBool(ctx, a))); FROZEN_FREE(ctx, a); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 28; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 27;
            break;
        case 27:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "lastStreamId"));
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue ctor = POP();
              JSValue ret = JS_CallConstructor(ctx, ctor, 1, args);
              FROZEN_FREE(ctx, ctor); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = 28;
            break;
        case 28:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[7];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "_readPollInterval");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 4 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = JS_UNDEFINED;
                    frames[frame_depth].args[2] = JS_UNDEFINED;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 8; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            {
              JSValue args[1];
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 1, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, POP()); }
            { JSValue v = locals[7];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "_encoding");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            {
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 0, NULL);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            frame->result = JS_UNDEFINED; next_block = -1; break;
            }
            break;
        case 29:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "connecting"));
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue ctor = POP();
              JSValue ret = JS_CallConstructor(ctx, ctor, 1, args);
              FROZEN_FREE(ctx, ctor); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = -1;
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func489_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func489, "frozen_func489", 3);
    JS_SetPropertyStr(ctx, global, "frozen_func489", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func490(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func490_Frame {
    JSValue args[3];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[5];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func490_Frame;

static JSValue frozen_func490(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func490_Frame *frames = js_malloc(ctx, sizeof(frozen_func490_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 3; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 5; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func490_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 3;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_DupValue(ctx, this_val));
            { FROZEN_FREE(ctx, frame->locals[4]); frame->locals[4] = POP(); }
            frame->locals[3] = JS_UNINITIALIZED;
            frame->locals[1] = JS_UNINITIALIZED;
            frame->locals[0] = JS_UNINITIALIZED;
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            /* Unsupported opcode 152 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            PUSH(JS_NewString(ctx, "_origExit"));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 2; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = JS_UNDEFINED;
                    frames[frame_depth].args[2] = JS_UNDEFINED;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 5; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { FROZEN_FREE(ctx, frame->args[0]); frame->args[0] = POP(); }
            break;
            }
            next_block = 2;
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            /* Unsupported opcode 152 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            PUSH(JS_NewString(ctx, "_origExit"));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 4; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 3;
            break;
        case 3:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            next_block = 5; break;
            }
            break;
        case 4:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = JS_UNDEFINED;
                    frames[frame_depth].args[2] = JS_UNDEFINED;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 5; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            }
            next_block = 5;
            break;
        case 5:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            /* Unsupported opcode 152 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            PUSH(JS_NewString(ctx, "_edgeboxKeepalive"));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 7; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 6;
            break;
        case 6:
            switch (frame->instr_offset) {
            case 0:
            PUSH(FROZEN_DUP(ctx, frame->locals[4]));
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "remotePort");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue args[2 > 0 ? 2 : 1]; args[1] = POP(); args[0] = POP(); JSValue method = POP(); JSValue this_obj = POP();
              JSValue ret = JS_Call(ctx, method, this_obj, 2, args);
              FROZEN_FREE(ctx, method); FROZEN_FREE(ctx, this_obj); FROZEN_FREE(ctx, args[0]); FROZEN_FREE(ctx, args[1]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              frame->result = ret; next_block = -1; break; }
            break;
            }
            next_block = 7;
            break;
        case 7:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "localPort");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = POP(); PUSH(JS_NewBool(ctx, JS_IsFunction(ctx, v))); FROZEN_FREE(ctx, v); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 9; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 8;
            break;
        case 8:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "localPort");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue args[2 > 0 ? 2 : 1]; args[1] = POP(); args[0] = POP(); JSValue method = POP(); JSValue this_obj = POP();
              JSValue ret = JS_Call(ctx, method, this_obj, 2, args);
              FROZEN_FREE(ctx, method); FROZEN_FREE(ctx, this_obj); FROZEN_FREE(ctx, args[0]); FROZEN_FREE(ctx, args[1]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              frame->result = ret; next_block = -1; break; }
            break;
            }
            next_block = 9;
            break;
        case 9:
            switch (frame->instr_offset) {
            case 0:
            /* Unsupported opcode 194 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = POP(); }
            { JSValue exc = JS_GetException(ctx); PUSH(exc); }
            break;
            }
            next_block = 10;
            break;
        case 10:
            switch (frame->instr_offset) {
            case 0:
            PUSH(FROZEN_DUP(ctx, frame->locals[4]));
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "bytesRead");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            PUSH(JS_NewObject(ctx));
            PUSH(JS_NewString(ctx, "open"));
            { JSValue val = POP(); JSValue obj = TOP();
              JSAtom prop = JS_NewAtom(ctx, ", mimeType=");
              JS_DefinePropertyValue(ctx, obj, prop, val, JS_PROP_C_W_E);
              JS_FreeAtom(ctx, prop); }
            {
              JSValue args[2];
              args[1] = POP();
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 2, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              FROZEN_FREE(ctx, args[1]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue v = frame->locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = POP(); }
            { FROZEN_FREE(ctx, POP()); }
            { FROZEN_FREE(ctx, POP()); }
            next_block = 15; break;
            }
            break;
        case 11:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, frame->locals[2]); frame->locals[2] = POP(); }
            { JSValue exc = JS_GetException(ctx); PUSH(exc); }
            break;
            }
            next_block = 12;
            break;
        case 12:
            switch (frame->instr_offset) {
            }
            next_block = 13;
            break;
        case 13:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, POP()); }
            next_block = 15; break;
            }
            break;
        case 14:
            switch (frame->instr_offset) {
            case 0:
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = 15;
            break;
        case 15:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            break;
            }
            next_block = 16;
            break;
        case 16:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            { FROZEN_FREE(ctx, frame->locals[3]); frame->locals[3] = POP(); }
            PUSH(FROZEN_DUP(ctx, frame->locals[4]));
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "bytesWritten");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue v = locals[3];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(argc_inner > 2 ? FROZEN_DUP(ctx, argv[2]) : JS_UNDEFINED);
            { JSValue args[3 > 0 ? 3 : 1]; args[2] = POP(); args[1] = POP(); args[0] = POP(); JSValue method = POP(); JSValue this_obj = POP();
              JSValue ret = JS_Call(ctx, method, this_obj, 3, args);
              FROZEN_FREE(ctx, method); FROZEN_FREE(ctx, this_obj); FROZEN_FREE(ctx, args[0]); FROZEN_FREE(ctx, args[1]); FROZEN_FREE(ctx, args[2]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              frame->result = ret; next_block = -1; break; }
            break;
            }
            next_block = -1;
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func490_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func490, "frozen_func490", 3);
    JS_SetPropertyStr(ctx, global, "frozen_func490", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func492(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func492_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func492_Frame;

static JSValue frozen_func492(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func492_Frame *frames = js_malloc(ctx, sizeof(frozen_func492_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func492_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { FROZEN_FREE(ctx, frame->args[0]); frame->args[0] = POP(); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "opening");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = POP(); PUSH(JS_NewBool(ctx, JS_IsFunction(ctx, v))); FROZEN_FREE(ctx, v); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 2; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "opening");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue method = POP(); JSValue this_obj = POP();
              JSValue ret = JS_Call(ctx, method, this_obj, 1, args);
              FROZEN_FREE(ctx, method); FROZEN_FREE(ctx, this_obj); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              frame->result = ret; next_block = -1; break; }
            break;
            }
            next_block = 2;
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            /* Unsupported opcode 246 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 10; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 3;
            break;
        case 3:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "readyState");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 10; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 4;
            break;
        case 4:
            switch (frame->instr_offset) {
            case 0:
            { JSValue exc = JS_GetException(ctx); PUSH(exc); }
            break;
            }
            next_block = 5;
            break;
        case 5:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "readyState");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            {
              JSValue args[1];
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 1, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            PUSH(JS_MKVAL(JS_TAG_INT, 1));
            { JSValue idx = POP(); JSValue arr = POP();
              int64_t i; JS_ToInt64(ctx, &i, idx);
              JSValue ret = JS_GetPropertyInt64(ctx, arr, i);
              FROZEN_FREE(ctx, arr); FROZEN_FREE(ctx, idx);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            PUSH(JS_MKVAL(JS_TAG_INT, 0));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { FROZEN_FREE(ctx, POP()); }
            frame->result = POP(); next_block = -1; break;
            }
            break;
        case 6:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            { JSValue exc = JS_GetException(ctx); PUSH(exc); }
            break;
            }
            next_block = 7;
            break;
        case 7:
            switch (frame->instr_offset) {
            }
            next_block = 8;
            break;
        case 8:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_FALSE);
            { FROZEN_FREE(ctx, POP()); }
            frame->result = POP(); next_block = -1; break;
            }
            break;
        case 9:
            switch (frame->instr_offset) {
            case 0:
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = 10;
            break;
        case 10:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_FALSE);
            frame->result = POP(); next_block = -1; break;
            }
            break;
        case 11:
            switch (frame->instr_offset) {
            }
            next_block = -1;
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func492_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func492, "frozen_func492", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func492", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func493(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func493_Frame {
    JSValue args[2];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[2];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func493_Frame;

static JSValue frozen_func493(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func493_Frame *frames = js_malloc(ctx, sizeof(frozen_func493_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 2; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 2; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func493_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 2;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[0] = JS_UNINITIALIZED;
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 3 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = JS_UNDEFINED;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 2; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { FROZEN_FREE(ctx, frame->args[0]); frame->args[0] = POP(); }
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 2; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, POP()); }
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "_startReadPolling");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            break;
            }
            next_block = 2;
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 4; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 3;
            break;
        case 3:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, POP()); }
            PUSH(JS_FALSE);
            break;
            }
            next_block = 4;
            break;
        case 4:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "__edgebox_socket_create");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = POP(); PUSH(JS_NewBool(ctx, JS_IsFunction(ctx, v))); FROZEN_FREE(ctx, v); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 6; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 5;
            break;
        case 5:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "__edgebox_socket_create");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue args[2 > 0 ? 2 : 1]; args[1] = POP(); args[0] = POP(); JSValue method = POP(); JSValue this_obj = POP();
              JSValue ret = JS_Call(ctx, method, this_obj, 2, args);
              FROZEN_FREE(ctx, method); FROZEN_FREE(ctx, this_obj); FROZEN_FREE(ctx, args[0]); FROZEN_FREE(ctx, args[1]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              frame->result = ret; next_block = -1; break; }
            break;
            }
            next_block = 6;
            break;
        case 6:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            /* Unsupported opcode 246 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 16; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 7;
            break;
        case 7:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "Failed to create socket");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 16; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 8;
            break;
        case 8:
            switch (frame->instr_offset) {
            case 0:
            { JSValue exc = JS_GetException(ctx); PUSH(exc); }
            break;
            }
            next_block = 9;
            break;
        case 9:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "Failed to create socket");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            {
              JSValue args[1];
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 1, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, POP()); }
            { FROZEN_FREE(ctx, POP()); }
            frame->result = JS_UNDEFINED; next_block = -1; break;
            }
            break;
        case 10:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = POP(); }
            { JSValue exc = JS_GetException(ctx); PUSH(exc); }
            break;
            }
            next_block = 11;
            break;
        case 11:
            switch (frame->instr_offset) {
            }
            next_block = 12;
            break;
        case 12:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue a = POP(); PUSH(JS_NewBool(ctx, !JS_ToBool(ctx, a))); FROZEN_FREE(ctx, a); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 14; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 13;
            break;
        case 13:
            switch (frame->instr_offset) {
            case 0:
            PUSH(FROZEN_DUP(ctx, frame->locals[1]));
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = 14;
            break;
        case 14:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, POP()); }
            frame->result = JS_UNDEFINED; next_block = -1; break;
            }
            break;
        case 15:
            switch (frame->instr_offset) {
            case 0:
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = 16;
            break;
        case 16:
            switch (frame->instr_offset) {
            case 0:
            break;
            }
            next_block = 17;
            break;
        case 17:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "state"));
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue ctor = POP();
              JSValue ret = JS_CallConstructor(ctx, ctor, 1, args);
              FROZEN_FREE(ctx, ctor); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = -1;
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func493_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func493, "frozen_func493", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func493", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func497(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func497(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* push_false */
    PUSH(JS_FALSE);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func497_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func497, "frozen_func497", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func497", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func499(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func499_Frame {
    JSValue args[2];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[4];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func499_Frame;

static JSValue frozen_func499(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func499_Frame *frames = js_malloc(ctx, sizeof(frozen_func499_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 2; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 4; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func499_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 2;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_DupValue(ctx, this_val));
            { FROZEN_FREE(ctx, frame->locals[3]); frame->locals[3] = POP(); }
            frame->locals[0] = JS_UNINITIALIZED;
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 5 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = JS_UNDEFINED;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 4; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { FROZEN_FREE(ctx, frame->args[0]); frame->args[0] = POP(); }
            PUSH(JS_UNDEFINED);
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "__edgebox_socket_read");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = POP(); PUSH(JS_NewBool(ctx, JS_IsFunction(ctx, v))); FROZEN_FREE(ctx, v); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 2; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "__edgebox_socket_read");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            {
              JSValue args[1];
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 1, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue v = frame->locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            { FROZEN_FREE(ctx, POP()); }
            next_block = 8; break;
            }
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            /* Unsupported opcode 246 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 7; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 3;
            break;
        case 3:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "optionsOrPort");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 7; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 4;
            break;
        case 4:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[1] = JS_UNINITIALIZED;
            PUSH(JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "optionsOrPort");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            {
              JSValue args[1];
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 1, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = POP(); }
            { JSValue v = locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_MKVAL(JS_TAG_INT, 1));
            { JSValue idx = POP(); JSValue arr = POP();
              int64_t i; JS_ToInt64(ctx, &i, idx);
              JSValue ret = JS_GetPropertyInt64(ctx, arr, i);
              FROZEN_FREE(ctx, arr); FROZEN_FREE(ctx, idx);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            PUSH(JS_MKVAL(JS_TAG_INT, 0));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, !JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 6; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 5;
            break;
        case 5:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[2] = JS_UNINITIALIZED;
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "lastStreamId"));
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue ctor = POP();
              JSValue ret = JS_CallConstructor(ctx, ctor, 1, args);
              FROZEN_FREE(ctx, ctor); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { FROZEN_FREE(ctx, frame->locals[2]); frame->locals[2] = POP(); }
            { JSValue v = locals[2];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "copy"));
            { JSValue val = POP(); JSValue obj = POP();
              int ret = JS_SetPropertyStr(ctx, obj, "_transformer", val);
              FROZEN_FREE(ctx, obj);
              if (ret < 0) { next_block = -1; frame->result = JS_EXCEPTION; break; } }
            { JSValue v = locals[2];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = 6;
            break;
        case 6:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_MKVAL(JS_TAG_INT, 0));
            { JSValue idx = POP(); JSValue arr = POP();
              int64_t i; JS_ToInt64(ctx, &i, idx);
              JSValue ret = JS_GetPropertyInt64(ctx, arr, i);
              FROZEN_FREE(ctx, arr); FROZEN_FREE(ctx, idx);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "__edgebox_map_new");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            /* Unsupported opcode 193 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            {
              JSValue args[1];
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 1, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue v = frame->locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            { FROZEN_FREE(ctx, POP()); }
            next_block = 8; break;
            }
            break;
        case 7:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "hostOrCallback"));
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue ctor = POP();
              JSValue ret = JS_CallConstructor(ctx, ctor, 1, args);
              FROZEN_FREE(ctx, ctor); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = 8;
            break;
        case 8:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 11; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 9;
            break;
        case 9:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "maybeCallback");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 11; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 10;
            break;
        case 10:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "_h2ConnectionId");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            /* Unsupported opcode 193 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue method = POP(); JSValue this_obj = POP();
              JSValue ret = JS_Call(ctx, method, this_obj, 1, args);
              FROZEN_FREE(ctx, method); FROZEN_FREE(ctx, this_obj); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              frame->result = ret; next_block = -1; break; }
            break;
            }
            next_block = 11;
            break;
        case 11:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            frame->result = POP(); next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func499_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func499, "frozen_func499", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func499", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func503(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func503_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[3];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func503_Frame;

static JSValue frozen_func503(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func503_Frame *frames = js_malloc(ctx, sizeof(frozen_func503_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 3; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func503_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 3; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { FROZEN_FREE(ctx, frame->args[0]); frame->args[0] = POP(); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "_createSocket");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = POP(); PUSH(JS_NewBool(ctx, JS_IsFunction(ctx, v))); FROZEN_FREE(ctx, v); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 2; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "_createSocket");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue method = POP(); JSValue this_obj = POP();
              JSValue ret = JS_Call(ctx, method, this_obj, 1, args);
              FROZEN_FREE(ctx, method); FROZEN_FREE(ctx, this_obj); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              frame->result = ret; next_block = -1; break; }
            break;
            }
            next_block = 2;
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            /* Unsupported opcode 246 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 0; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 3;
            break;
        case 3:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "readyState");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 0; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 4;
            break;
        case 4:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[2] = JS_UNINITIALIZED;
            frame->locals[0] = JS_UNINITIALIZED;
            PUSH(JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "readyState");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            {
              JSValue args[1];
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 1, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_MKVAL(JS_TAG_INT, 1));
            { JSValue idx = POP(); JSValue arr = POP();
              int64_t i; JS_ToInt64(ctx, &i, idx);
              JSValue ret = JS_GetPropertyInt64(ctx, arr, i);
              FROZEN_FREE(ctx, arr); FROZEN_FREE(ctx, idx);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            PUSH(JS_MKVAL(JS_TAG_INT, 0));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, !JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 6; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 5;
            break;
        case 5:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[1] = JS_UNINITIALIZED;
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "lastStreamId"));
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue ctor = POP();
              JSValue ret = JS_CallConstructor(ctx, ctor, 1, args);
              FROZEN_FREE(ctx, ctor); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = POP(); }
            { JSValue v = locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "copy"));
            { JSValue val = POP(); JSValue obj = POP();
              int ret = JS_SetPropertyStr(ctx, obj, "_transformer", val);
              FROZEN_FREE(ctx, obj);
              if (ret < 0) { next_block = -1; frame->result = JS_EXCEPTION; break; } }
            { JSValue v = locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = 6;
            break;
        case 6:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_MKVAL(JS_TAG_INT, 0));
            { JSValue idx = POP(); JSValue arr = POP();
              int64_t i; JS_ToInt64(ctx, &i, idx);
              JSValue ret = JS_GetPropertyInt64(ctx, arr, i);
              FROZEN_FREE(ctx, arr); FROZEN_FREE(ctx, idx);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { FROZEN_FREE(ctx, frame->locals[2]); frame->locals[2] = POP(); }
            PUSH(JS_NewObject(ctx));
            /* Unsupported opcode 193 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            /* set_name: ignored */
            { JSValue val = POP(); JSValue obj = TOP();
              JSAtom prop = JS_NewAtom(ctx, "__edgebox_socket_state");
              JS_DefinePropertyValue(ctx, obj, prop, val, JS_PROP_C_W_E);
              JS_FreeAtom(ctx, prop); }
            /* Unsupported opcode 193 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            /* set_name: ignored */
            { JSValue val = POP(); JSValue obj = TOP();
              JSAtom prop = JS_NewAtom(ctx, "CLOSED");
              JS_DefinePropertyValue(ctx, obj, prop, val, JS_PROP_C_W_E);
              JS_FreeAtom(ctx, prop); }
            /* Unsupported opcode 193 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            /* set_name: ignored */
            { JSValue val = POP(); JSValue obj = TOP();
              JSAtom prop = JS_NewAtom(ctx, "CONNECTED");
              JS_DefinePropertyValue(ctx, obj, prop, val, JS_PROP_C_W_E);
              JS_FreeAtom(ctx, prop); }
            { JSValue v = locals[2];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "HostArray");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue val = POP(); JSValue obj = TOP();
              JSAtom prop = JS_NewAtom(ctx, "HostArray");
              JS_DefinePropertyValue(ctx, obj, prop, val, JS_PROP_C_W_E);
              JS_FreeAtom(ctx, prop); }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue v = locals[2];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "__edgebox_socket_connect");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(JS_MKVAL(JS_TAG_INT, 1000));
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t prod = (int64_t)JS_VALUE_GET_INT(a) * JS_VALUE_GET_INT(b);
                  if (likely(prod >= INT32_MIN && prod <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)prod));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)prod));
                  }
              } else {
                  JSValue r = frozen_mul(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue ctor = POP();
              JSValue ret = JS_CallConstructor(ctx, ctor, 1, args);
              FROZEN_FREE(ctx, ctor); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { JSValue val = POP(); JSValue obj = TOP();
              JSAtom prop = JS_NewAtom(ctx, "__edgebox_socket_connect");
              JS_DefinePropertyValue(ctx, obj, prop, val, JS_PROP_C_W_E);
              JS_FreeAtom(ctx, prop); }
            { JSValue v = locals[2];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "on");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue val = POP(); JSValue obj = TOP();
              JSAtom prop = JS_NewAtom(ctx, "on");
              JS_DefinePropertyValue(ctx, obj, prop, val, JS_PROP_C_W_E);
              JS_FreeAtom(ctx, prop); }
            frame->result = POP(); next_block = -1; break;
            }
            break;
        case 7:
            switch (frame->instr_offset) {
            case 0:
            break;
            }
            next_block = 8;
            break;
        case 8:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "Connection failed: "));
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue ctor = POP();
              JSValue ret = JS_CallConstructor(ctx, ctor, 1, args);
              FROZEN_FREE(ctx, ctor); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = -1;
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func503_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func503, "frozen_func503", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func503", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func504(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func504(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 948); if (JS_IsException(val)) return val; PUSH(val); }
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func504_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func504, "frozen_func504", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func504", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func505(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func505_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[2];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func505_Frame;

static JSValue frozen_func505(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func505_Frame *frames = js_malloc(ctx, sizeof(frozen_func505_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 2; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func505_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 2; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { FROZEN_FREE(ctx, frame->args[0]); frame->args[0] = POP(); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "ready");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = POP(); PUSH(JS_NewBool(ctx, JS_IsFunction(ctx, v))); FROZEN_FREE(ctx, v); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 2; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "ready");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue method = POP(); JSValue this_obj = POP();
              JSValue ret = JS_Call(ctx, method, this_obj, 1, args);
              FROZEN_FREE(ctx, method); FROZEN_FREE(ctx, this_obj); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              frame->result = ret; next_block = -1; break; }
            break;
            }
            next_block = 2;
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            /* Unsupported opcode 246 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 10; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 3;
            break;
        case 3:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "Socket is not writable");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 10; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 4;
            break;
        case 4:
            switch (frame->instr_offset) {
            case 0:
            { JSValue exc = JS_GetException(ctx); PUSH(exc); }
            break;
            }
            next_block = 5;
            break;
        case 5:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "Socket is not writable");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            {
              JSValue args[1];
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 1, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, POP()); }
            { FROZEN_FREE(ctx, POP()); }
            frame->result = JS_UNDEFINED; next_block = -1; break;
            }
            break;
        case 6:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            { JSValue exc = JS_GetException(ctx); PUSH(exc); }
            break;
            }
            next_block = 7;
            break;
        case 7:
            switch (frame->instr_offset) {
            }
            next_block = 8;
            break;
        case 8:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[1] = JS_UNINITIALIZED;
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "lastStreamId"));
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue ctor = POP();
              JSValue ret = JS_CallConstructor(ctx, ctor, 1, args);
              FROZEN_FREE(ctx, ctor); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = POP(); }
            { JSValue v = locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "copy"));
            { JSValue val = POP(); JSValue obj = POP();
              int ret = JS_SetPropertyStr(ctx, obj, "_transformer", val);
              FROZEN_FREE(ctx, obj);
              if (ret < 0) { next_block = -1; frame->result = JS_EXCEPTION; break; } }
            { JSValue v = locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = 9;
            break;
        case 9:
            switch (frame->instr_offset) {
            case 0:
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = 10;
            break;
        case 10:
            switch (frame->instr_offset) {
            case 0:
            break;
            }
            next_block = 11;
            break;
        case 11:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "Socket not connected"));
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue ctor = POP();
              JSValue ret = JS_CallConstructor(ctx, ctor, 1, args);
              FROZEN_FREE(ctx, ctor); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = -1;
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func505_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func505, "frozen_func505", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func505", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func506(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func506_Frame {
    JSValue args[2];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[2];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func506_Frame;

static JSValue frozen_func506(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func506_Frame *frames = js_malloc(ctx, sizeof(frozen_func506_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 2; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 2; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func506_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 2;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[0] = JS_UNINITIALIZED;
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 3 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = JS_UNDEFINED;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 2; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { FROZEN_FREE(ctx, frame->args[0]); frame->args[0] = POP(); }
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 2; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, POP()); }
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "_startReadPolling");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            break;
            }
            next_block = 2;
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 4; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 3;
            break;
        case 3:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, POP()); }
            PUSH(JS_FALSE);
            break;
            }
            next_block = 4;
            break;
        case 4:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "__edgebox_socket_write");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = POP(); PUSH(JS_NewBool(ctx, JS_IsFunction(ctx, v))); FROZEN_FREE(ctx, v); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 6; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 5;
            break;
        case 5:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "__edgebox_socket_write");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue args[2 > 0 ? 2 : 1]; args[1] = POP(); args[0] = POP(); JSValue method = POP(); JSValue this_obj = POP();
              JSValue ret = JS_Call(ctx, method, this_obj, 2, args);
              FROZEN_FREE(ctx, method); FROZEN_FREE(ctx, this_obj); FROZEN_FREE(ctx, args[0]); FROZEN_FREE(ctx, args[1]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              frame->result = ret; next_block = -1; break; }
            break;
            }
            next_block = 6;
            break;
        case 6:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            /* Unsupported opcode 246 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 14; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 7;
            break;
        case 7:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "Socket is not writable");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 14; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 8;
            break;
        case 8:
            switch (frame->instr_offset) {
            case 0:
            { JSValue exc = JS_GetException(ctx); PUSH(exc); }
            break;
            }
            next_block = 9;
            break;
        case 9:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "Socket is not writable");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            {
              JSValue args[1];
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 1, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, POP()); }
            { FROZEN_FREE(ctx, POP()); }
            frame->result = JS_UNDEFINED; next_block = -1; break;
            }
            break;
        case 10:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = POP(); }
            { JSValue exc = JS_GetException(ctx); PUSH(exc); }
            break;
            }
            next_block = 11;
            break;
        case 11:
            switch (frame->instr_offset) {
            }
            next_block = 12;
            break;
        case 12:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "lastStreamId"));
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue ctor = POP();
              JSValue ret = JS_CallConstructor(ctx, ctor, 1, args);
              FROZEN_FREE(ctx, ctor); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = 13;
            break;
        case 13:
            switch (frame->instr_offset) {
            case 0:
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = 14;
            break;
        case 14:
            switch (frame->instr_offset) {
            case 0:
            break;
            }
            next_block = 15;
            break;
        case 15:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "Write failed: "));
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue ctor = POP();
              JSValue ret = JS_CallConstructor(ctx, ctor, 1, args);
              FROZEN_FREE(ctx, ctor); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = -1;
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func506_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func506, "frozen_func506", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func506", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func507(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func507(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 964); if (JS_IsException(val)) return val; PUSH(val); }
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* get_arg1 */
    PUSH(argc > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func507_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func507, "frozen_func507", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func507", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func508(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func508_Frame {
    JSValue args[2];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func508_Frame;

static JSValue frozen_func508(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func508_Frame *frames = js_malloc(ctx, sizeof(frozen_func508_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 2; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func508_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 2;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = JS_UNDEFINED;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { FROZEN_FREE(ctx, frame->args[0]); frame->args[0] = POP(); }
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            case 3:
                /* Recursive call 6 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 4;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = JS_UNDEFINED;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 4:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { FROZEN_FREE(ctx, frame->args[1]); frame->args[1] = POP(); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "noDelay");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = POP(); PUSH(JS_NewBool(ctx, JS_IsFunction(ctx, v))); FROZEN_FREE(ctx, v); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 2; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "noDelay");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            { JSValue args[2 > 0 ? 2 : 1]; args[1] = POP(); args[0] = POP(); JSValue method = POP(); JSValue this_obj = POP();
              JSValue ret = JS_Call(ctx, method, this_obj, 2, args);
              FROZEN_FREE(ctx, method); FROZEN_FREE(ctx, this_obj); FROZEN_FREE(ctx, args[0]); FROZEN_FREE(ctx, args[1]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              frame->result = ret; next_block = -1; break; }
            break;
            }
            next_block = 2;
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            /* Unsupported opcode 246 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 10; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 3;
            break;
        case 3:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "address");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 10; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 4;
            break;
        case 4:
            switch (frame->instr_offset) {
            case 0:
            { JSValue exc = JS_GetException(ctx); PUSH(exc); }
            break;
            }
            next_block = 5;
            break;
        case 5:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "address");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            {
              JSValue args[2];
              args[1] = POP();
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 2, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              FROZEN_FREE(ctx, args[1]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, POP()); }
            { FROZEN_FREE(ctx, POP()); }
            frame->result = JS_UNDEFINED; next_block = -1; break;
            }
            break;
        case 6:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            { JSValue exc = JS_GetException(ctx); PUSH(exc); }
            break;
            }
            next_block = 7;
            break;
        case 7:
            switch (frame->instr_offset) {
            }
            next_block = 8;
            break;
        case 8:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "lastStreamId"));
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue ctor = POP();
              JSValue ret = JS_CallConstructor(ctx, ctor, 1, args);
              FROZEN_FREE(ctx, ctor); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = 9;
            break;
        case 9:
            switch (frame->instr_offset) {
            case 0:
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = 10;
            break;
        case 10:
            switch (frame->instr_offset) {
            case 0:
            break;
            }
            next_block = 11;
            break;
        case 11:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "IPv4"));
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue ctor = POP();
              JSValue ret = JS_CallConstructor(ctx, ctor, 1, args);
              FROZEN_FREE(ctx, ctor); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = -1;
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func508_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func508, "frozen_func508", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func508", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func509(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func509_Frame {
    JSValue args[2];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func509_Frame;

static JSValue frozen_func509(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func509_Frame *frames = js_malloc(ctx, sizeof(frozen_func509_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 2; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func509_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 2;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_DupValue(ctx, this_val));
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 4 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = JS_UNDEFINED;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { FROZEN_FREE(ctx, frame->args[0]); frame->args[0] = POP(); }
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            case 3:
                /* Recursive call 8 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 4;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = JS_UNDEFINED;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 4:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { FROZEN_FREE(ctx, frame->args[1]); frame->args[1] = POP(); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "connectionListener");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = POP(); PUSH(JS_NewBool(ctx, JS_IsFunction(ctx, v))); FROZEN_FREE(ctx, v); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 2; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "connectionListener");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            { JSValue args[2 > 0 ? 2 : 1]; args[1] = POP(); args[0] = POP(); JSValue method = POP(); JSValue this_obj = POP();
              JSValue ret = JS_Call(ctx, method, this_obj, 2, args);
              FROZEN_FREE(ctx, method); FROZEN_FREE(ctx, this_obj); FROZEN_FREE(ctx, args[0]); FROZEN_FREE(ctx, args[1]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              frame->result = ret; next_block = -1; break; }
            break;
            }
            next_block = 2;
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            PUSH(FROZEN_DUP(ctx, frame->locals[0]));
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "bytesWritten");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            PUSH(FROZEN_DUP(ctx, frame->locals[0]));
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "bytesRead");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            {
              JSValue args[1];
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 1, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            {
              JSValue args[2];
              args[1] = POP();
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 2, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              FROZEN_FREE(ctx, args[1]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            frame->result = JS_UNDEFINED; next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func509_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func509, "frozen_func509", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func509", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func510(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func510(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func510_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func510, "frozen_func510", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func510", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func511(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func511(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func511_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func511, "frozen_func511", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func511", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func513(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func513(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg1 */
    PUSH(argc > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
    /* typeof_is_function */
    { JSValue v = POP(); PUSH(JS_NewBool(ctx, JS_IsFunction(ctx, v))); FROZEN_FREE(ctx, v); }
    { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); goto block_2; } JS_FreeValue(ctx, cond); }
block_1:
    /* get_arg1 */
    PUSH(argc > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
    /* put_arg2 */
    if (argc > 2) { JS_FreeValue(ctx, argv[2]); argv[2] = POP(); }
block_2:
    /* get_arg2 */
    PUSH(argc > 2 ? FROZEN_DUP(ctx, argv[2]) : JS_UNDEFINED);
    { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); goto block_4; } JS_FreeValue(ctx, cond); }
block_3:
    /* get_arg2 */
    PUSH(argc > 2 ? FROZEN_DUP(ctx, argv[2]) : JS_UNDEFINED);
    /* null */
    PUSH(JS_NULL);
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue args[2]; args[1] = POP(); args[0] = POP(); JSValue func = POP(); JSValue ret = JS_Call(ctx, func, JS_UNDEFINED, 2, args); JS_FreeValue(ctx, func); JS_FreeValue(ctx, args[0]); JS_FreeValue(ctx, args[1]); if (JS_IsException(ret)) return ret; PUSH(ret); }
    /* drop */
    FROZEN_FREE(ctx, POP());
block_4:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func513_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func513, "frozen_func513", 3);
    JS_SetPropertyStr(ctx, global, "frozen_func513", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func514(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func514_Frame {
    JSValue args[2];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[3];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func514_Frame;

static JSValue frozen_func514(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func514_Frame *frames = js_malloc(ctx, sizeof(frozen_func514_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 2; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 3; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func514_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 2;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = JS_UNDEFINED;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 3; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { FROZEN_FREE(ctx, frame->args[0]); frame->args[0] = POP(); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "opening");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = POP(); PUSH(JS_NewBool(ctx, JS_IsFunction(ctx, v))); FROZEN_FREE(ctx, v); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 3; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "opening");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            {
              JSValue args[1];
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 1, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { JSValue a = POP(); PUSH(JS_NewBool(ctx, !JS_ToBool(ctx, a))); FROZEN_FREE(ctx, a); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 0; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 2;
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[0] = JS_UNINITIALIZED;
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "_acceptPollInterval"));
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            PUSH(JS_NewString(ctx, "_connections"));
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue ctor = POP();
              JSValue ret = JS_CallConstructor(ctx, ctor, 1, args);
              FROZEN_FREE(ctx, ctor); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "copy"));
            { JSValue val = POP(); JSValue obj = POP();
              int ret = JS_SetPropertyStr(ctx, obj, "_transformer", val);
              FROZEN_FREE(ctx, obj);
              if (ret < 0) { next_block = -1; frame->result = JS_EXCEPTION; break; } }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = 3;
            break;
        case 3:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            /* Unsupported opcode 246 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 13; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 4;
            break;
        case 4:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "readyState");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 13; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 5;
            break;
        case 5:
            switch (frame->instr_offset) {
            case 0:
            { JSValue exc = JS_GetException(ctx); PUSH(exc); }
            break;
            }
            next_block = 6;
            break;
        case 6:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "readyState");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            {
              JSValue args[1];
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 1, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            PUSH(JS_MKVAL(JS_TAG_INT, 1));
            { JSValue idx = POP(); JSValue arr = POP();
              int64_t i; JS_ToInt64(ctx, &i, idx);
              JSValue ret = JS_GetPropertyInt64(ctx, arr, i);
              FROZEN_FREE(ctx, arr); FROZEN_FREE(ctx, idx);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            PUSH(JS_MKVAL(JS_TAG_INT, 0));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, !JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 8; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 7;
            break;
        case 7:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "copy"));
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue ctor = POP();
              JSValue ret = JS_CallConstructor(ctx, ctor, 1, args);
              FROZEN_FREE(ctx, ctor); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = 8;
            break;
        case 8:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, POP()); }
            frame->result = JS_UNDEFINED; next_block = -1; break;
            }
            break;
        case 9:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = POP(); }
            { JSValue exc = JS_GetException(ctx); PUSH(exc); }
            break;
            }
            next_block = 10;
            break;
        case 10:
            switch (frame->instr_offset) {
            }
            next_block = 11;
            break;
        case 11:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[2] = JS_UNINITIALIZED;
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "lastStreamId"));
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue ctor = POP();
              JSValue ret = JS_CallConstructor(ctx, ctor, 1, args);
              FROZEN_FREE(ctx, ctor); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { FROZEN_FREE(ctx, frame->locals[2]); frame->locals[2] = POP(); }
            { JSValue v = locals[2];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "copy"));
            { JSValue val = POP(); JSValue obj = POP();
              int ret = JS_SetPropertyStr(ctx, obj, "_transformer", val);
              FROZEN_FREE(ctx, obj);
              if (ret < 0) { next_block = -1; frame->result = JS_EXCEPTION; break; } }
            { JSValue v = locals[2];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = 12;
            break;
        case 12:
            switch (frame->instr_offset) {
            case 0:
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = 13;
            break;
        case 13:
            switch (frame->instr_offset) {
            case 0:
            frame->result = JS_UNDEFINED; next_block = -1; break;
            }
            break;
        case 14:
            switch (frame->instr_offset) {
            }
            next_block = 15;
            break;
        case 15:
            switch (frame->instr_offset) {
            }
            next_block = -1;
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func514_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func514, "frozen_func514", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func514", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func515(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func515_Frame {
    JSValue args[3];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[5];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func515_Frame;

static JSValue frozen_func515(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func515_Frame *frames = js_malloc(ctx, sizeof(frozen_func515_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 3; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 5; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func515_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 3;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[4] = JS_UNINITIALIZED;
            frame->locals[1] = JS_UNINITIALIZED;
            frame->locals[0] = JS_UNINITIALIZED;
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 5 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = JS_UNDEFINED;
                    frames[frame_depth].args[2] = JS_UNDEFINED;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 5; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { FROZEN_FREE(ctx, frame->args[0]); frame->args[0] = POP(); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "dataMatch");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 4; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, POP()); }
            /* Unsupported opcode 246 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 3; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 2;
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            next_block = 4; break;
            }
            break;
        case 3:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NULL);
            break;
            }
            next_block = 4;
            break;
        case 4:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            PUSH(JS_MKVAL(JS_TAG_INT, 0));
            { FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = POP(); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 0; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 5;
            break;
        case 5:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "readUInt32BE");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = POP(); PUSH(JS_NewBool(ctx, JS_IsFunction(ctx, v))); FROZEN_FREE(ctx, v); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 0; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 6;
            break;
        case 6:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[2] = JS_UNINITIALIZED;
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            PUSH(JS_NewString(ctx, "once"));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 9; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 7;
            break;
        case 7:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, POP()); }
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            PUSH(JS_NewString(ctx, "hostOrBacklogOrCallback"));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 9; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 8;
            break;
        case 8:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, POP()); }
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            { JSValue a = POP(); PUSH(JS_NewBool(ctx, !JS_ToBool(ctx, a))); FROZEN_FREE(ctx, a); }
            break;
            }
            next_block = 9;
            break;
        case 9:
            switch (frame->instr_offset) {
            case 0:
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 11; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 10;
            break;
        case 10:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "backlogOrCallback");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue v = frame->locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = POP(); }
            { FROZEN_FREE(ctx, POP()); }
            next_block = 0; break;
            }
            break;
        case 11:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            PUSH(JS_NewString(ctx, "backlog"));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 13; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 12;
            break;
        case 12:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "bindResult");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue v = frame->locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = POP(); }
            { FROZEN_FREE(ctx, POP()); }
            next_block = 0; break;
            }
            break;
        case 13:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            PUSH(JS_NewString(ctx, "_socketId"));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 15; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 14;
            break;
        case 14:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "listenResult");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "clientSocketId");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue b = POP(), a = POP(); PUSH(JS_MKVAL(JS_TAG_INT, JS_VALUE_GET_INT(a) | JS_VALUE_GET_INT(b))); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "clientSocket");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue b = POP(), a = POP(); PUSH(JS_MKVAL(JS_TAG_INT, JS_VALUE_GET_INT(a) | JS_VALUE_GET_INT(b))); }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue v = frame->locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = POP(); }
            { FROZEN_FREE(ctx, POP()); }
            next_block = 0; break;
            }
            break;
        case 15:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            PUSH(JS_NewString(ctx, "_stopAcceptPolling"));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 17; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 16;
            break;
        case 16:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, POP()); }
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            PUSH(JS_NewString(ctx, "__edgebox_socket_accept"));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            break;
            }
            next_block = 17;
            break;
        case 17:
            switch (frame->instr_offset) {
            case 0:
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 19; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 18;
            break;
        case 18:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "listenResult");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "clientSocketId");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue b = POP(), a = POP(); PUSH(JS_MKVAL(JS_TAG_INT, JS_VALUE_GET_INT(a) | JS_VALUE_GET_INT(b))); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "Failed to create server socket");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue b = POP(), a = POP(); PUSH(JS_MKVAL(JS_TAG_INT, JS_VALUE_GET_INT(a) | JS_VALUE_GET_INT(b))); }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue v = frame->locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = POP(); }
            { FROZEN_FREE(ctx, POP()); }
            next_block = 0; break;
            }
            break;
        case 19:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            PUSH(JS_NewString(ctx, "__edgebox_socket_bind"));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 21; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 20;
            break;
        case 20:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "bindResult");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "clientSocketId");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue b = POP(), a = POP(); PUSH(JS_MKVAL(JS_TAG_INT, JS_VALUE_GET_INT(a) | JS_VALUE_GET_INT(b))); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "clientSocket");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue b = POP(), a = POP(); PUSH(JS_MKVAL(JS_TAG_INT, JS_VALUE_GET_INT(a) | JS_VALUE_GET_INT(b))); }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue v = frame->locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = POP(); }
            { FROZEN_FREE(ctx, POP()); }
            next_block = 26; break;
            }
            break;
        case 21:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            PUSH(JS_NewString(ctx, "opts"));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 23; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 22;
            break;
        case 22:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "listenResult");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "clientSocketId");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue b = POP(), a = POP(); PUSH(JS_MKVAL(JS_TAG_INT, JS_VALUE_GET_INT(a) | JS_VALUE_GET_INT(b))); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "Failed to bind to port ");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue b = POP(), a = POP(); PUSH(JS_MKVAL(JS_TAG_INT, JS_VALUE_GET_INT(a) | JS_VALUE_GET_INT(b))); }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue v = frame->locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = POP(); }
            { FROZEN_FREE(ctx, POP()); }
            next_block = 26; break;
            }
            break;
        case 23:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            PUSH(JS_NewString(ctx, "__edgebox_socket_listen"));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 25; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 24;
            break;
        case 24:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "bindResult");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "clientSocketId");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue b = POP(), a = POP(); PUSH(JS_MKVAL(JS_TAG_INT, JS_VALUE_GET_INT(a) | JS_VALUE_GET_INT(b))); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "Failed to bind to port ");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue b = POP(), a = POP(); PUSH(JS_MKVAL(JS_TAG_INT, JS_VALUE_GET_INT(a) | JS_VALUE_GET_INT(b))); }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue v = frame->locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = POP(); }
            { FROZEN_FREE(ctx, POP()); }
            next_block = 26; break;
            }
            break;
        case 25:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "bindResult");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "clientSocketId");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue b = POP(), a = POP(); PUSH(JS_MKVAL(JS_TAG_INT, JS_VALUE_GET_INT(a) | JS_VALUE_GET_INT(b))); }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue v = frame->locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = POP(); }
            { FROZEN_FREE(ctx, POP()); }
            break;
            }
            next_block = 26;
            break;
        case 26:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            break;
            }
            next_block = 27;
            break;
        case 27:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "readUInt32BE");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue v = locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(argc_inner > 2 ? FROZEN_DUP(ctx, argv[2]) : JS_UNDEFINED);
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 29; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 28;
            break;
        case 28:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, POP()); }
            PUSH(JS_MKVAL(JS_TAG_INT, 438));
            break;
            }
            next_block = 29;
            break;
        case 29:
            switch (frame->instr_offset) {
            case 0:
            {
              JSValue args[3];
              args[2] = POP();
              args[1] = POP();
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 3, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              FROZEN_FREE(ctx, args[1]);
              FROZEN_FREE(ctx, args[2]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, frame->locals[2]); frame->locals[2] = POP(); }
            { JSValue v = locals[2];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_MKVAL(JS_TAG_INT, 0));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, frozen_lt(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 31; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 30;
            break;
        case 30:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[3] = JS_UNINITIALIZED;
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "Failed to listen: "));
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            PUSH(JS_NewString(ctx, "_connections"));
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue ctor = POP();
              JSValue ret = JS_CallConstructor(ctx, ctor, 1, args);
              FROZEN_FREE(ctx, ctor); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { FROZEN_FREE(ctx, frame->locals[3]); frame->locals[3] = POP(); }
            { JSValue v = locals[3];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "copy"));
            { JSValue val = POP(); JSValue obj = POP();
              int ret = JS_SetPropertyStr(ctx, obj, "_transformer", val);
              FROZEN_FREE(ctx, obj);
              if (ret < 0) { next_block = -1; frame->result = JS_EXCEPTION; break; } }
            { JSValue v = locals[3];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = 31;
            break;
        case 31:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "http2");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue a = POP(); PUSH(JS_NewBool(ctx, !JS_ToBool(ctx, a))); FROZEN_FREE(ctx, a); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 33; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 32;
            break;
        case 32:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NewObject(ctx));
            { JSValue val = POP(); JSValue obj = POP();
              int ret = JS_SetPropertyStr(ctx, obj, "http2", val);
              FROZEN_FREE(ctx, obj);
              if (ret < 0) { next_block = -1; frame->result = JS_EXCEPTION; break; } }
            break;
            }
            next_block = 33;
            break;
        case 33:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "http2");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[2];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue b = stack[sp-1], a = stack[sp-2]; stack[sp-2] = b; stack[sp-1] = a; }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            /* Unsupported opcode 177 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 35; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 34;
            break;
        case 34:
            switch (frame->instr_offset) {
            case 0:
            { JSValue b = stack[sp-1], a = stack[sp-2]; stack[sp-2] = b; stack[sp-1] = a; }
            { JSValue v = POP(); PUSH(JS_ToPropertyKey(ctx, v)); FROZEN_FREE(ctx, v); }
            { JSValue b = stack[sp-1], a = stack[sp-2]; stack[sp-2] = b; stack[sp-1] = a; }
            break;
            }
            next_block = 35;
            break;
        case 35:
            switch (frame->instr_offset) {
            case 0:
            { JSValue b = stack[sp-1], a = stack[sp-2]; stack[sp-2] = b; stack[sp-1] = a; }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue b = stack[sp-1], a = stack[sp-2]; stack[sp-2] = b; stack[sp-1] = a; }
            { JSValue v = POP(); PUSH(JS_ToPropertyKey(ctx, v)); FROZEN_FREE(ctx, v); }
            { JSValue b = stack[sp-1], a = stack[sp-2]; stack[sp-2] = b; stack[sp-1] = a; }
            { JSValue val = POP(); JSValue idx = POP(); JSValue arr = POP();
              int64_t i; JS_ToInt64(ctx, &i, idx);
              int ret = JS_SetPropertyInt64(ctx, arr, i, val);
              FROZEN_FREE(ctx, arr); FROZEN_FREE(ctx, idx);
              if (ret < 0) { next_block = -1; frame->result = JS_EXCEPTION; break; } }
            { JSValue v = locals[2];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            frame->result = POP(); next_block = -1; break;
            }
            break;
        case 36:
            switch (frame->instr_offset) {
            case 0:
            break;
            }
            next_block = 37;
            break;
        case 37:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "0.0.0.0");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue a = POP(); if (JS_VALUE_GET_TAG(a) == JS_TAG_INT) { PUSH(JS_MKVAL(JS_TAG_INT, JS_VALUE_GET_INT(a) + 1)); } else { PUSH(JS_NewFloat64(ctx, JS_VALUE_GET_FLOAT64(JS_ToNumber(ctx, a)) + 1)); } FROZEN_FREE(ctx, a); }
            { JSValue v = POP(); JSValue a = stack[sp-1]; stack[sp-1] = v; PUSH(a); }
            { JSValue val = POP(); JSValue obj = POP();
              int ret = JS_SetPropertyStr(ctx, obj, "0.0.0.0", val);
              FROZEN_FREE(ctx, obj);
              if (ret < 0) { next_block = -1; frame->result = JS_EXCEPTION; break; } }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 39; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 38;
            break;
        case 38:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, POP()); }
            PUSH(JS_MKVAL(JS_TAG_INT, 100));
            { JSValue v = POP(); JSValue a = stack[sp-1]; stack[sp-1] = v; PUSH(a); }
            { JSValue val = POP(); JSValue obj = POP();
              int ret = JS_SetPropertyStr(ctx, obj, "0.0.0.0", val);
              FROZEN_FREE(ctx, obj);
              if (ret < 0) { next_block = -1; frame->result = JS_EXCEPTION; break; } }
            break;
            }
            next_block = 39;
            break;
        case 39:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, frame->locals[4]); frame->locals[4] = POP(); }
            { JSValue v = locals[4];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue val = POP(); JSValue obj = POP();
              int ret = JS_SetPropertyStr(ctx, obj, "0.0.0.0", val);
              FROZEN_FREE(ctx, obj);
              if (ret < 0) { next_block = -1; frame->result = JS_EXCEPTION; break; } }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "http2");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue a = POP(); PUSH(JS_NewBool(ctx, !JS_ToBool(ctx, a))); FROZEN_FREE(ctx, a); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 41; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 40;
            break;
        case 40:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NewObject(ctx));
            { JSValue val = POP(); JSValue obj = POP();
              int ret = JS_SetPropertyStr(ctx, obj, "http2", val);
              FROZEN_FREE(ctx, obj);
              if (ret < 0) { next_block = -1; frame->result = JS_EXCEPTION; break; } }
            break;
            }
            next_block = 41;
            break;
        case 41:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "http2");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[4];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue b = stack[sp-1], a = stack[sp-2]; stack[sp-2] = b; stack[sp-1] = a; }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            /* Unsupported opcode 177 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 43; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 42;
            break;
        case 42:
            switch (frame->instr_offset) {
            case 0:
            { JSValue b = stack[sp-1], a = stack[sp-2]; stack[sp-2] = b; stack[sp-1] = a; }
            { JSValue v = POP(); PUSH(JS_ToPropertyKey(ctx, v)); FROZEN_FREE(ctx, v); }
            { JSValue b = stack[sp-1], a = stack[sp-2]; stack[sp-2] = b; stack[sp-1] = a; }
            break;
            }
            next_block = 43;
            break;
        case 43:
            switch (frame->instr_offset) {
            case 0:
            { JSValue b = stack[sp-1], a = stack[sp-2]; stack[sp-2] = b; stack[sp-1] = a; }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue b = stack[sp-1], a = stack[sp-2]; stack[sp-2] = b; stack[sp-1] = a; }
            { JSValue v = POP(); PUSH(JS_ToPropertyKey(ctx, v)); FROZEN_FREE(ctx, v); }
            { JSValue b = stack[sp-1], a = stack[sp-2]; stack[sp-2] = b; stack[sp-1] = a; }
            { JSValue val = POP(); JSValue idx = POP(); JSValue arr = POP();
              int64_t i; JS_ToInt64(ctx, &i, idx);
              int ret = JS_SetPropertyInt64(ctx, arr, i, val);
              FROZEN_FREE(ctx, arr); FROZEN_FREE(ctx, idx);
              if (ret < 0) { next_block = -1; frame->result = JS_EXCEPTION; break; } }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "conn");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 45; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 44;
            break;
        case 44:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, POP()); }
            PUSH(JS_NewObject(ctx));
            break;
            }
            next_block = 45;
            break;
        case 45:
            switch (frame->instr_offset) {
            case 0:
            { JSValue val = POP(); JSValue obj = POP();
              int ret = JS_SetPropertyStr(ctx, obj, "conn", val);
              FROZEN_FREE(ctx, obj);
              if (ret < 0) { next_block = -1; frame->result = JS_EXCEPTION; break; } }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "conn");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[4];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue b = stack[sp-1], a = stack[sp-2]; stack[sp-2] = b; stack[sp-1] = a; }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            /* Unsupported opcode 177 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 47; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 46;
            break;
        case 46:
            switch (frame->instr_offset) {
            case 0:
            { JSValue b = stack[sp-1], a = stack[sp-2]; stack[sp-2] = b; stack[sp-1] = a; }
            { JSValue v = POP(); PUSH(JS_ToPropertyKey(ctx, v)); FROZEN_FREE(ctx, v); }
            { JSValue b = stack[sp-1], a = stack[sp-2]; stack[sp-2] = b; stack[sp-1] = a; }
            break;
            }
            next_block = 47;
            break;
        case 47:
            switch (frame->instr_offset) {
            case 0:
            { JSValue b = stack[sp-1], a = stack[sp-2]; stack[sp-2] = b; stack[sp-1] = a; }
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            { JSValue b = stack[sp-1], a = stack[sp-2]; stack[sp-2] = b; stack[sp-1] = a; }
            { JSValue v = POP(); PUSH(JS_ToPropertyKey(ctx, v)); FROZEN_FREE(ctx, v); }
            { JSValue b = stack[sp-1], a = stack[sp-2]; stack[sp-2] = b; stack[sp-1] = a; }
            { JSValue val = POP(); JSValue idx = POP(); JSValue arr = POP();
              int64_t i; JS_ToInt64(ctx, &i, idx);
              int ret = JS_SetPropertyInt64(ctx, arr, i, val);
              FROZEN_FREE(ctx, arr); FROZEN_FREE(ctx, idx);
              if (ret < 0) { next_block = -1; frame->result = JS_EXCEPTION; break; } }
            { JSValue v = locals[4];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            frame->result = POP(); next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func515_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func515, "frozen_func515", 3);
    JS_SetPropertyStr(ctx, global, "frozen_func515", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func519(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func519(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* push_true */
    PUSH(JS_TRUE);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func519_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func519, "frozen_func519", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func519", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func520(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func520(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* push_false */
    PUSH(JS_FALSE);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func520_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func520, "frozen_func520", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func520", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func522(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func522(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func522_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func522, "frozen_func522", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func522", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func528(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func528(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func528_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func528, "frozen_func528", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func528", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func534(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func534_Frame {
    JSValue args[2];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[3];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func534_Frame;

static JSValue frozen_func534(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func534_Frame *frames = js_malloc(ctx, sizeof(frozen_func534_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 2; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 3; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func534_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 2;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[2] = JS_UNINITIALIZED;
            frame->locals[0] = JS_UNINITIALIZED;
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "secureConnectionListener");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(JS_UNDEFINED);
            {
              JSValue args[2];
              args[1] = POP();
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 2, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              FROZEN_FREE(ctx, args[1]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_MKVAL(JS_TAG_INT, 0));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, frozen_lt(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 2; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[1] = JS_UNINITIALIZED;
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "tls.createServer() not supported in WASM environment"));
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            PUSH(JS_NewString(ctx, "_connections"));
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue ctor = POP();
              JSValue ret = JS_CallConstructor(ctx, ctor, 1, args);
              FROZEN_FREE(ctx, ctor); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = POP(); }
            { JSValue v = locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "secureConnect"));
            { JSValue val = POP(); JSValue obj = POP();
              int ret = JS_SetPropertyStr(ctx, obj, "_transformer", val);
              FROZEN_FREE(ctx, obj);
              if (ret < 0) { next_block = -1; frame->result = JS_EXCEPTION; break; } }
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            { JSValue v = locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue arg0 = POP(); JSValue func = POP();
              JSValue ret = JS_Call(ctx, func, JS_UNDEFINED, 1, &arg0);
              FROZEN_FREE(ctx, func); FROZEN_FREE(ctx, arg0);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            frame->result = JS_UNDEFINED; next_block = -1; break;
            }
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            /* Unsupported opcode 193 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            /* set_name: ignored */
            { FROZEN_FREE(ctx, frame->locals[2]); frame->locals[2] = POP(); }
            { JSValue v = locals[2];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_MKVAL(JS_TAG_INT, 0));
            case 1:
                /* Recursive call 6 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 3; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            frame->result = JS_UNDEFINED; next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func534_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func534, "frozen_func534", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func534", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func535(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func535_Frame {
    JSValue args[3];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[3];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func535_Frame;

static JSValue frozen_func535(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func535_Frame *frames = js_malloc(ctx, sizeof(frozen_func535_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 3; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 3; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func535_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 3;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_DupValue(ctx, this_val));
            { FROZEN_FREE(ctx, frame->locals[2]); frame->locals[2] = POP(); }
            frame->locals[1] = JS_UNINITIALIZED;
            frame->locals[0] = JS_UNINITIALIZED;
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 6 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = JS_UNDEFINED;
                    frames[frame_depth].args[2] = JS_UNDEFINED;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 3; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { FROZEN_FREE(ctx, frame->args[0]); frame->args[0] = POP(); }
            PUSH(FROZEN_DUP(ctx, frame->locals[2]));
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            /* Unsupported opcode 152 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            PUSH(JS_NewString(ctx, "_origExit"));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 2; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            next_block = 3; break;
            }
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = JS_UNDEFINED;
                    frames[frame_depth].args[2] = JS_UNDEFINED;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 3; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            }
            next_block = 3;
            break;
        case 3:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = POP(); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "secureConnectionListener");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = POP(); PUSH(JS_NewBool(ctx, JS_IsFunction(ctx, v))); FROZEN_FREE(ctx, v); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 5; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 4;
            break;
        case 4:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            /* Unsupported opcode 193 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue ctor = POP();
              JSValue ret = JS_CallConstructor(ctx, ctor, 1, args);
              FROZEN_FREE(ctx, ctor); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            frame->result = POP(); next_block = -1; break;
            }
            break;
        case 5:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "[WASM PROXY ERROR] ");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "bytesWritten");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            PUSH(argc_inner > 2 ? FROZEN_DUP(ctx, argv[2]) : JS_UNDEFINED);
            {
              JSValue args[3];
              args[2] = POP();
              args[1] = POP();
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 3, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              FROZEN_FREE(ctx, args[1]);
              FROZEN_FREE(ctx, args[2]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue method = POP(); JSValue this_obj = POP();
              JSValue ret = JS_Call(ctx, method, this_obj, 1, args);
              FROZEN_FREE(ctx, method); FROZEN_FREE(ctx, this_obj); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              frame->result = ret; next_block = -1; break; }
            break;
            }
            next_block = -1;
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func535_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func535, "frozen_func535", 3);
    JS_SetPropertyStr(ctx, global, "frozen_func535", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func547(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func547(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func547_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func547, "frozen_func547", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func547", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func548(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func548(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func548_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func548, "frozen_func548", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func548", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func549(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func549(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func549_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func549, "frozen_func549", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func549", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func551(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func551(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg1 */
    PUSH(argc > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
    /* typeof_is_function */
    { JSValue v = POP(); PUSH(JS_NewBool(ctx, JS_IsFunction(ctx, v))); FROZEN_FREE(ctx, v); }
    { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); goto block_2; } JS_FreeValue(ctx, cond); }
block_1:
    /* get_arg1 */
    PUSH(argc > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
    /* put_arg2 */
    if (argc > 2) { JS_FreeValue(ctx, argv[2]); argv[2] = POP(); }
    /* object */
    PUSH(JS_NewObject(ctx));
    /* put_arg1 */
    if (argc > 1) { JS_FreeValue(ctx, argv[1]); argv[1] = POP(); }
block_2:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func551_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func551, "frozen_func551", 3);
    JS_SetPropertyStr(ctx, global, "frozen_func551", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func552(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func552(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func552_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func552, "frozen_func552", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func552", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func560(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func560_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[5];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func560_Frame;

static JSValue frozen_func560(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func560_Frame *frames = js_malloc(ctx, sizeof(frozen_func560_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 5; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func560_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[3] = JS_UNINITIALIZED;
            frame->locals[0] = JS_UNINITIALIZED;
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "u");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(JS_UNDEFINED);
            PUSH(JS_UNDEFINED);
            {
              JSValue args[2];
              args[1] = POP();
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 2, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              FROZEN_FREE(ctx, args[1]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            PUSH(JS_NewString(ctx, "__edgebox_map_get"));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 2; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            frame->result = POP(); next_block = -1; break;
            }
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            PUSH(JS_NewString(ctx, "urlOrString"));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 7; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 3;
            break;
        case 3:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[1] = JS_UNINITIALIZED;
            { JSValue len = POP(); JSValue arr = POP();
              JSValue new_arr = JS_NewArray(ctx);
              if (!JS_IsException(new_arr)) {
                int64_t length = 0;
                JS_ToInt64(ctx, &length, len);
                for (int64_t i = 0; i < length; i++) {
                  JSValue elem = JS_GetPropertyInt64(ctx, arr, i);
                  JS_SetPropertyInt64(ctx, new_arr, i, elem);
                }
              }
              FROZEN_FREE(ctx, arr); FROZEN_FREE(ctx, len);
              if (JS_IsException(new_arr)) { next_block = -1; frame->result = new_arr; break; }
              PUSH(new_arr); }
            { FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = POP(); }
            frame->locals[2] = JS_UNINITIALIZED;
            PUSH(JS_MKVAL(JS_TAG_INT, 0));
            { FROZEN_FREE(ctx, frame->locals[2]); frame->locals[2] = POP(); }
            break;
            }
            next_block = 4;
            break;
        case 4:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[2];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            /* Unsupported opcode 235 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, frozen_lt(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 6; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 5;
            break;
        case 5:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "follow");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "[emit] listener #");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[2];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue v = locals[2];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_MKVAL(JS_TAG_INT, 2));
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            {
              JSValue args[2];
              args[1] = POP();
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 2, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              FROZEN_FREE(ctx, args[1]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            PUSH(JS_MKVAL(JS_TAG_INT, 16));
            case 1:
                /* Recursive call 11 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 5; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            {
              JSValue args[1];
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 1, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, POP()); }
            { JSValue v = locals[2];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_MKVAL(JS_TAG_INT, 2));
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue v = frame->locals[2];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              FROZEN_FREE(ctx, frame->locals[2]); frame->locals[2] = POP(); }
            { FROZEN_FREE(ctx, POP()); }
            next_block = 4; break;
            }
            break;
        case 6:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "locale");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "val");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(JS_NULL);
            { JSValue v = locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            {
              JSValue args[2];
              args[1] = POP();
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 2, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              FROZEN_FREE(ctx, args[1]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            case 1:
                /* Recursive call 7 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 5; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        case 7:
            switch (frame->instr_offset) {
            case 0:
            { JSValue len = POP(); JSValue arr = POP();
              JSValue new_arr = JS_NewArray(ctx);
              if (!JS_IsException(new_arr)) {
                int64_t length = 0;
                JS_ToInt64(ctx, &length, len);
                for (int64_t i = 0; i < length; i++) {
                  JSValue elem = JS_GetPropertyInt64(ctx, arr, i);
                  JS_SetPropertyInt64(ctx, new_arr, i, elem);
                }
              }
              FROZEN_FREE(ctx, arr); FROZEN_FREE(ctx, len);
              if (JS_IsException(new_arr)) { next_block = -1; frame->result = new_arr; break; }
              PUSH(new_arr); }
            { FROZEN_FREE(ctx, frame->locals[3]); frame->locals[3] = POP(); }
            frame->locals[4] = JS_UNINITIALIZED;
            PUSH(JS_MKVAL(JS_TAG_INT, 0));
            { FROZEN_FREE(ctx, frame->locals[4]); frame->locals[4] = POP(); }
            break;
            }
            next_block = 8;
            break;
        case 8:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[4];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            /* Unsupported opcode 235 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, frozen_lt(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 10; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 9;
            break;
        case 9:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[3];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "follow");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "[emit] listener #");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[4];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue v = locals[4];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_MKVAL(JS_TAG_INT, 2));
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            {
              JSValue args[2];
              args[1] = POP();
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 2, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              FROZEN_FREE(ctx, args[1]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            PUSH(JS_MKVAL(JS_TAG_INT, 16));
            case 1:
                /* Recursive call 11 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 5; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            {
              JSValue args[1];
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 1, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, POP()); }
            { JSValue v = locals[4];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_MKVAL(JS_TAG_INT, 2));
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue v = frame->locals[4];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              FROZEN_FREE(ctx, frame->locals[4]); frame->locals[4] = POP(); }
            { FROZEN_FREE(ctx, POP()); }
            next_block = 8; break;
            }
            break;
        case 10:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "__initialize");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[3];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue method = POP(); JSValue this_obj = POP();
              JSValue ret = JS_Call(ctx, method, this_obj, 1, args);
              FROZEN_FREE(ctx, method); FROZEN_FREE(ctx, this_obj); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              frame->result = ret; next_block = -1; break; }
            break;
            }
            next_block = -1;
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func560_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func560, "frozen_func560", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func560", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func563(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func563_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[5];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func563_Frame;

static JSValue frozen_func563(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func563_Frame *frames = js_malloc(ctx, sizeof(frozen_func563_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 5; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func563_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[3] = JS_UNINITIALIZED;
            frame->locals[0] = JS_UNINITIALIZED;
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "edgebox");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(JS_UNDEFINED);
            PUSH(JS_UNDEFINED);
            PUSH(JS_UNDEFINED);
            {
              JSValue args[3];
              args[2] = POP();
              args[1] = POP();
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 3, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              FROZEN_FREE(ctx, args[1]);
              FROZEN_FREE(ctx, args[2]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            PUSH(JS_NewString(ctx, "__edgebox_map_get"));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 2; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            frame->result = POP(); next_block = -1; break;
            }
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            PUSH(JS_NewString(ctx, "urlOrString"));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 7; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 3;
            break;
        case 3:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[1] = JS_UNINITIALIZED;
            { JSValue len = POP(); JSValue arr = POP();
              JSValue new_arr = JS_NewArray(ctx);
              if (!JS_IsException(new_arr)) {
                int64_t length = 0;
                JS_ToInt64(ctx, &length, len);
                for (int64_t i = 0; i < length; i++) {
                  JSValue elem = JS_GetPropertyInt64(ctx, arr, i);
                  JS_SetPropertyInt64(ctx, new_arr, i, elem);
                }
              }
              FROZEN_FREE(ctx, arr); FROZEN_FREE(ctx, len);
              if (JS_IsException(new_arr)) { next_block = -1; frame->result = new_arr; break; }
              PUSH(new_arr); }
            { FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = POP(); }
            frame->locals[2] = JS_UNINITIALIZED;
            PUSH(JS_MKVAL(JS_TAG_INT, 0));
            { FROZEN_FREE(ctx, frame->locals[2]); frame->locals[2] = POP(); }
            break;
            }
            next_block = 4;
            break;
        case 4:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[2];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            /* Unsupported opcode 235 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, frozen_lt(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 6; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 5;
            break;
        case 5:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "follow");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "[emit] listener #");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[2];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue v = locals[2];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_MKVAL(JS_TAG_INT, 2));
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            {
              JSValue args[2];
              args[1] = POP();
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 2, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              FROZEN_FREE(ctx, args[1]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            PUSH(JS_MKVAL(JS_TAG_INT, 16));
            case 1:
                /* Recursive call 11 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 5; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            {
              JSValue args[1];
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 1, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, POP()); }
            { JSValue v = locals[2];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_MKVAL(JS_TAG_INT, 2));
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue v = frame->locals[2];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              FROZEN_FREE(ctx, frame->locals[2]); frame->locals[2] = POP(); }
            { FROZEN_FREE(ctx, POP()); }
            next_block = 4; break;
            }
            break;
        case 6:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "locale");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "val");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(JS_NULL);
            { JSValue v = locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            {
              JSValue args[2];
              args[1] = POP();
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 2, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              FROZEN_FREE(ctx, args[1]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            case 1:
                /* Recursive call 7 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 5; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        case 7:
            switch (frame->instr_offset) {
            case 0:
            { JSValue len = POP(); JSValue arr = POP();
              JSValue new_arr = JS_NewArray(ctx);
              if (!JS_IsException(new_arr)) {
                int64_t length = 0;
                JS_ToInt64(ctx, &length, len);
                for (int64_t i = 0; i < length; i++) {
                  JSValue elem = JS_GetPropertyInt64(ctx, arr, i);
                  JS_SetPropertyInt64(ctx, new_arr, i, elem);
                }
              }
              FROZEN_FREE(ctx, arr); FROZEN_FREE(ctx, len);
              if (JS_IsException(new_arr)) { next_block = -1; frame->result = new_arr; break; }
              PUSH(new_arr); }
            { FROZEN_FREE(ctx, frame->locals[3]); frame->locals[3] = POP(); }
            frame->locals[4] = JS_UNINITIALIZED;
            PUSH(JS_MKVAL(JS_TAG_INT, 0));
            { FROZEN_FREE(ctx, frame->locals[4]); frame->locals[4] = POP(); }
            break;
            }
            next_block = 8;
            break;
        case 8:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[4];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            /* Unsupported opcode 235 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, frozen_lt(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 10; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 9;
            break;
        case 9:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[3];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "follow");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "[emit] listener #");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[4];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue v = locals[4];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_MKVAL(JS_TAG_INT, 2));
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            {
              JSValue args[2];
              args[1] = POP();
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 2, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              FROZEN_FREE(ctx, args[1]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            PUSH(JS_MKVAL(JS_TAG_INT, 16));
            case 1:
                /* Recursive call 11 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 5; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            {
              JSValue args[1];
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 1, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, POP()); }
            { JSValue v = locals[4];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_MKVAL(JS_TAG_INT, 2));
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue v = frame->locals[4];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              FROZEN_FREE(ctx, frame->locals[4]); frame->locals[4] = POP(); }
            { FROZEN_FREE(ctx, POP()); }
            next_block = 8; break;
            }
            break;
        case 10:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "__initialize");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[3];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue method = POP(); JSValue this_obj = POP();
              JSValue ret = JS_Call(ctx, method, this_obj, 1, args);
              FROZEN_FREE(ctx, method); FROZEN_FREE(ctx, this_obj); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              frame->result = ret; next_block = -1; break; }
            break;
            }
            next_block = -1;
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func563_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func563, "frozen_func563", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func563", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func575(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func575(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* object */
    PUSH(JS_NewObject(ctx));
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 1052, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* object */
    PUSH(JS_NewObject(ctx));
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 1053, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* object */
    PUSH(JS_NewObject(ctx));
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 1054, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func575_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func575, "frozen_func575", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func575", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func624(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func624(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 476); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func624_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func624, "frozen_func624", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func624", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func625(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func625(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 476); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func625_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func625, "frozen_func625", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func625", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func626(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func626(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 1117); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func626_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func626, "frozen_func626", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func626", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func629(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func629(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* push_false */
    PUSH(JS_FALSE);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func629_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func629, "frozen_func629", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func629", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func630(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func630(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 1112); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func630_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func630, "frozen_func630", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func630", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func631(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func631(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 1112); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func631_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func631, "frozen_func631", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func631", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func632(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func632(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 1103); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func632_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func632, "frozen_func632", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func632", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func634(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func634(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* push_1 */
    PUSH(JS_MKVAL(JS_TAG_INT, 1));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func634_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func634, "frozen_func634", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func634", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func635(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func635(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    PUSH(JS_UNDEFINED); /* TODO: closure var_ref */
    /* null */
    PUSH(JS_NULL);
    /* push_0 */
    PUSH(JS_MKVAL(JS_TAG_INT, 0));
    PUSH(JS_UNDEFINED); /* TODO: closure var_ref */
    { JSValue args[3]; args[2] = POP(); args[1] = POP(); args[0] = POP(); JSValue func = POP(); JSValue ret = JS_Call(ctx, func, JS_UNDEFINED, 3, args); JS_FreeValue(ctx, func); JS_FreeValue(ctx, args[0]); JS_FreeValue(ctx, args[1]); JS_FreeValue(ctx, args[2]); if (JS_IsException(ret)) return ret; PUSH(ret); }
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func635_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func635, "frozen_func635", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func635", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func640(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func640(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func640_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func640, "frozen_func640", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func640", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func641(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func641(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func641_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func641, "frozen_func641", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func641", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func643(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func643(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func643_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func643, "frozen_func643", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func643", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func648(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func648(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 429); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func648_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func648, "frozen_func648", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func648", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func649(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func649(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 1149); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* lnot */
    { JSValue v = POP(); PUSH(JS_NewBool(ctx, !JS_ToBool(ctx, v))); FROZEN_FREE(ctx, v); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func649_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func649, "frozen_func649", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func649", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func650(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func650(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 476); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func650_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func650, "frozen_func650", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func650", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func651(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func651(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 476); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func651_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func651, "frozen_func651", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func651", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func652(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func652(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* push_false */
    PUSH(JS_FALSE);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func652_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func652, "frozen_func652", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func652", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func653(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func653(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 1148); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func653_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func653, "frozen_func653", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func653", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func654(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func654(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 1149); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func654_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func654, "frozen_func654", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func654", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func655(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func655(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 1150); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func655_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func655, "frozen_func655", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func655", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func656(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func656(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 1151); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func656_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func656, "frozen_func656", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func656", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func657(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func657(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func657_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func657, "frozen_func657", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func657", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func659(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func659(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* push_true */
    PUSH(JS_TRUE);
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 1150, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func659_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func659, "frozen_func659", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func659", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func662(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func662(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    PUSH(JS_UNDEFINED); /* TODO: closure var_ref */
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* get_arg1 */
    PUSH(argc > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
    { JSValue args[2]; args[1] = POP(); args[0] = POP(); JSValue func = POP(); JSValue ret = JS_Call(ctx, func, JS_UNDEFINED, 2, args); JS_FreeValue(ctx, func); JS_FreeValue(ctx, args[0]); JS_FreeValue(ctx, args[1]); if (JS_IsException(ret)) return ret; PUSH(ret); }
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func662_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func662, "frozen_func662", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func662", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func672(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func672_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[3];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func672_Frame;

static JSValue frozen_func672(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func672_Frame *frames = js_malloc(ctx, sizeof(frozen_func672_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 3; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func672_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[1] = JS_UNINITIALIZED;
            frame->locals[0] = JS_UNINITIALIZED;
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "[spawnSync] cmd=");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 2; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, POP()); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "'\"'\"'");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue a = POP(); PUSH(JS_NewBool(ctx, !JS_ToBool(ctx, a))); FROZEN_FREE(ctx, a); }
            break;
            }
            next_block = 2;
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 4; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 3;
            break;
        case 3:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "file");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            {
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 0, NULL);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            frame->result = JS_UNDEFINED; next_block = -1; break;
            }
            break;
        case 4:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "'\"'\"'");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            case 1:
                /* Recursive call 3 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 3; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "hasAsyncSpawn");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 6; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 5;
            break;
        case 5:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "file");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            {
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 0, NULL);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, POP()); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "fs.readdirSync not implemented");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(JS_NewString(ctx, "w"));
            {
              JSValue args[1];
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 1, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, POP()); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "fs.readdirSync not implemented");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(JS_NewString(ctx, "_encoding"));
            PUSH(JS_FALSE);
            {
              JSValue args[2];
              args[1] = POP();
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 2, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              FROZEN_FREE(ctx, args[1]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            frame->result = JS_UNDEFINED; next_block = -1; break;
            }
            break;
        case 6:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "fullCmd");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, !JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 8; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 7;
            break;
        case 7:
            switch (frame->instr_offset) {
            case 0:
            frame->result = JS_UNDEFINED; next_block = -1; break;
            }
            break;
        case 8:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "'\"'\"'");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(JS_MKVAL(JS_TAG_INT, 65536));
            case 1:
                /* Recursive call 4 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 3; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = POP(); }
            { JSValue v = locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            /* Unsupported opcode 245 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 10; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 9;
            break;
        case 9:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "file");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            {
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 0, NULL);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, POP()); }
            PUSH(JS_FALSE);
            { JSValue val = POP(); JSValue obj = POP();
              int ret = JS_SetPropertyStr(ctx, obj, "readableLength", val);
              FROZEN_FREE(ctx, obj);
              if (ret < 0) { next_block = -1; frame->result = JS_EXCEPTION; break; } }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "fs.readdirSync not implemented");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(JS_NewString(ctx, "w"));
            {
              JSValue args[1];
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 1, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, POP()); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "fs.readdirSync not implemented");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(JS_NewString(ctx, "_encoding"));
            PUSH(JS_FALSE);
            {
              JSValue args[2];
              args[1] = POP();
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 2, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              FROZEN_FREE(ctx, args[1]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            frame->result = JS_UNDEFINED; next_block = -1; break;
            }
            break;
        case 10:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 16; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 11;
            break;
        case 11:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            /* Unsupported opcode 235 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            PUSH(JS_MKVAL(JS_TAG_INT, 0));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, frozen_gt(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 16; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 12;
            break;
        case 12:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[2] = JS_UNINITIALIZED;
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "stdout");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            /* Unsupported opcode 235 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            { JSValue val = POP(); JSValue obj = POP();
              int ret = JS_SetPropertyStr(ctx, obj, "stdout", val);
              FROZEN_FREE(ctx, obj);
              if (ret < 0) { next_block = -1; frame->result = JS_EXCEPTION; break; } }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "stat");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 14; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 13;
            break;
        case 13:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            next_block = 15; break;
            }
            break;
        case 14:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "__initialize");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            {
              JSValue args[1];
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 1, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            break;
            }
            next_block = 15;
            break;
        case 15:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, frame->locals[2]); frame->locals[2] = POP(); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "fs.readdirSync not implemented");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(JS_NewString(ctx, "trim"));
            { JSValue v = locals[2];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            {
              JSValue args[2];
              args[1] = POP();
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 2, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              FROZEN_FREE(ctx, args[1]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, POP()); }
            break;
            }
            next_block = 16;
            break;
        case 16:
            switch (frame->instr_offset) {
            case 0:
            frame->result = JS_UNDEFINED; next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func672_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func672, "frozen_func672", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func672", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func677(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func677_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func677_Frame;

static JSValue frozen_func677(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func677_Frame *frames = js_malloc(ctx, sizeof(frozen_func677_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func677_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func677_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func677, "frozen_func677", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func677", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func678(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func678_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func678_Frame;

static JSValue frozen_func678(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func678_Frame *frames = js_malloc(ctx, sizeof(frozen_func678_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func678_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func678_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func678, "frozen_func678", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func678", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func679(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func679_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func679_Frame;

static JSValue frozen_func679(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func679_Frame *frames = js_malloc(ctx, sizeof(frozen_func679_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func679_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func679_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func679, "frozen_func679", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func679", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func684(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func684(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 716, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func684_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func684, "frozen_func684", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func684", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func685(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func685(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func685_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func685, "frozen_func685", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func685", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func686(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func686(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func686_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func686, "frozen_func686", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func686", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func688(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func688(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func688_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func688, "frozen_func688", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func688", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func689(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func689(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func689_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func689, "frozen_func689", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func689", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func695(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func695_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[2];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func695_Frame;

static JSValue frozen_func695(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func695_Frame *frames = js_malloc(ctx, sizeof(frozen_func695_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 2; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func695_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[0] = JS_UNINITIALIZED;
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "[spawn] ERROR: ");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue a = POP(); PUSH(JS_NewBool(ctx, !JS_ToBool(ctx, a))); FROZEN_FREE(ctx, a); }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 2; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, POP()); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "'\"'\"'");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            /* Unsupported opcode 245 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            break;
            }
            next_block = 2;
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 4; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 3;
            break;
        case 3:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "__edgebox_spawn_start");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            {
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 0, NULL);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            frame->result = JS_UNDEFINED; next_block = -1; break;
            }
            break;
        case 4:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "'\"'\"'");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            case 1:
                /* Recursive call 3 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 2; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_MKVAL(JS_TAG_INT, 0));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, frozen_gt(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 6; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 5;
            break;
        case 5:
            switch (frame->instr_offset) {
            case 0:
            frame->locals[1] = JS_UNINITIALIZED;
            PUSH(JS_UNDEFINED);
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewObject(ctx));
            { JSValue v = locals[0];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue val = POP(); JSValue obj = TOP();
              JSAtom prop = JS_NewAtom(ctx, "isFile");
              JS_DefinePropertyValue(ctx, obj, prop, val, JS_PROP_C_W_E);
              JS_FreeAtom(ctx, prop); }
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue ctor = POP();
              JSValue ret = JS_CallConstructor(ctx, ctor, 1, args);
              FROZEN_FREE(ctx, ctor); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            { FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = POP(); }
            { JSValue v = locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_UNDEFINED);
            { JSValue val = POP(); JSValue obj = POP();
              int ret = JS_SetPropertyStr(ctx, obj, "cwd", val);
              FROZEN_FREE(ctx, obj);
              if (ret < 0) { next_block = -1; frame->result = JS_EXCEPTION; break; } }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "[spawn] exit emit error: ");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "delta");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            {
              JSValue args[1];
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 1, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, POP()); }
            { JSValue v = locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "fs.mkdirSync not implemented");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(JS_NewString(ctx, "_encoding"));
            /* Unsupported opcode 193 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            {
              JSValue args[2];
              args[1] = POP();
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 2, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              FROZEN_FREE(ctx, args[1]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, POP()); }
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "fs.readdirSync not implemented");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(JS_NewString(ctx, "_startReading"));
            { JSValue v = locals[1];
              if (JS_IsUninitialized(v)) {
                next_block = -1; frame->result = JS_ThrowReferenceError(ctx, "Cannot access before initialization"); break;
              }
              PUSH(FROZEN_DUP(ctx, v)); }
            {
              JSValue args[2];
              args[1] = POP();
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 2, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              FROZEN_FREE(ctx, args[1]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, POP()); }
            /* Unsupported opcode 105 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            break;
            }
            next_block = 6;
            break;
        case 6:
            switch (frame->instr_offset) {
            case 0:
            frame->result = JS_UNDEFINED; next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func695_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func695, "frozen_func695", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func695", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func702(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func702_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func702_Frame;

static JSValue frozen_func702(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func702_Frame *frames = js_malloc(ctx, sizeof(frozen_func702_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func702_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NULL);
            PUSH(JS_UNDEFINED);
            case 1:
                /* Recursive call 3 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func702_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func702, "frozen_func702", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func702", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func704(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func704(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func704_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func704, "frozen_func704", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func704", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func705(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func705(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func705_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func705, "frozen_func705", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func705", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func707(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func707(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 1099); if (JS_IsException(val)) return val; PUSH(val); }
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* get_arg1 */
    PUSH(argc > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func707_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func707, "frozen_func707", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func707", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func714(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func714(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* object */
    PUSH(JS_NewObject(ctx));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func714_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func714, "frozen_func714", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func714", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func717(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func717(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* null */
    PUSH(JS_NULL);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func717_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func717, "frozen_func717", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func717", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func718(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func718(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* null */
    PUSH(JS_NULL);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func718_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func718, "frozen_func718", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func718", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func719(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func719(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* push_false */
    PUSH(JS_FALSE);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func719_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func719, "frozen_func719", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func719", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func720(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func720(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* push_true */
    PUSH(JS_TRUE);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func720_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func720, "frozen_func720", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func720", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func721(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func721(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func721_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func721, "frozen_func721", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func721", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func740(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func740(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func740_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func740, "frozen_func740", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func740", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func741(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func741(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func741_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func741, "frozen_func741", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func741", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func742(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func742(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func742_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func742, "frozen_func742", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func742", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func743(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func743(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func743_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func743, "frozen_func743", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func743", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func744(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func744(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func744_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func744, "frozen_func744", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func744", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func745(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func745(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func745_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func745, "frozen_func745", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func745", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func746(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func746(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func746_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func746, "frozen_func746", 3);
    JS_SetPropertyStr(ctx, global, "frozen_func746", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func747(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func747(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func747_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func747, "frozen_func747", 3);
    JS_SetPropertyStr(ctx, global, "frozen_func747", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func748(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func748(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func748_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func748, "frozen_func748", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func748", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func749(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func749(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func749_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func749, "frozen_func749", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func749", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func750(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func750(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func750_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func750, "frozen_func750", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func750", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func751(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func751(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    PUSH(JS_MKVAL(JS_TAG_INT, 65536));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func751_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func751, "frozen_func751", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func751", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func752(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func752(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    PUSH(JS_MKVAL(JS_TAG_INT, 65536));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func752_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func752, "frozen_func752", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func752", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func753(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func753(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func753_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func753, "frozen_func753", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func753", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func754(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func754(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func754_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func754, "frozen_func754", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func754", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func757(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func757(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func757_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func757, "frozen_func757", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func757", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func770(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func770(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    PUSH(JS_MKVAL(JS_TAG_INT, 256));
    PUSH(JS_MKVAL(JS_TAG_INT, 1024));
    { JSValue b = POP(), a = POP();
      if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
          int64_t prod = (int64_t)JS_VALUE_GET_INT(a) * JS_VALUE_GET_INT(b);
          if (likely(prod >= INT32_MIN && prod <= INT32_MAX)) {
              PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)prod));  /* Fast path: no alloc */
          } else {
              PUSH(JS_NewFloat64(ctx, (double)prod));  /* Overflow to float64 */
          }
      } else {
          JSValue r = frozen_mul(ctx, a, b);  /* Slow path */
          FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
          if (JS_IsException(r)) return r;
          PUSH(r);
      }
    }
    PUSH(JS_MKVAL(JS_TAG_INT, 1024));
    { JSValue b = POP(), a = POP();
      if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
          int64_t prod = (int64_t)JS_VALUE_GET_INT(a) * JS_VALUE_GET_INT(b);
          if (likely(prod >= INT32_MIN && prod <= INT32_MAX)) {
              PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)prod));  /* Fast path: no alloc */
          } else {
              PUSH(JS_NewFloat64(ctx, (double)prod));  /* Overflow to float64 */
          }
      } else {
          JSValue r = frozen_mul(ctx, a, b);  /* Slow path */
          FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
          if (JS_IsException(r)) return r;
          PUSH(r);
      }
    }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func770_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func770, "frozen_func770", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func770", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func771(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func771(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    PUSH(JS_MKVAL(JS_TAG_INT, 128));
    PUSH(JS_MKVAL(JS_TAG_INT, 1024));
    { JSValue b = POP(), a = POP();
      if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
          int64_t prod = (int64_t)JS_VALUE_GET_INT(a) * JS_VALUE_GET_INT(b);
          if (likely(prod >= INT32_MIN && prod <= INT32_MAX)) {
              PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)prod));  /* Fast path: no alloc */
          } else {
              PUSH(JS_NewFloat64(ctx, (double)prod));  /* Overflow to float64 */
          }
      } else {
          JSValue r = frozen_mul(ctx, a, b);  /* Slow path */
          FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
          if (JS_IsException(r)) return r;
          PUSH(r);
      }
    }
    PUSH(JS_MKVAL(JS_TAG_INT, 1024));
    { JSValue b = POP(), a = POP();
      if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
          int64_t prod = (int64_t)JS_VALUE_GET_INT(a) * JS_VALUE_GET_INT(b);
          if (likely(prod >= INT32_MIN && prod <= INT32_MAX)) {
              PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)prod));  /* Fast path: no alloc */
          } else {
              PUSH(JS_NewFloat64(ctx, (double)prod));  /* Overflow to float64 */
          }
      } else {
          JSValue r = frozen_mul(ctx, a, b);  /* Slow path */
          FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
          if (JS_IsException(r)) return r;
          PUSH(r);
      }
    }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func771_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func771, "frozen_func771", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func771", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func772(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func772(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* push_0 */
    PUSH(JS_MKVAL(JS_TAG_INT, 0));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func772_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func772, "frozen_func772", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func772", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func774(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func774(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* object */
    PUSH(JS_NewObject(ctx));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func774_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func774, "frozen_func774", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func774", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func777(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func777_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func777_Frame;

static JSValue frozen_func777(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func777_Frame *frames = js_malloc(ctx, sizeof(frozen_func777_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func777_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func777_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func777, "frozen_func777", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func777", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func778(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func778_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func778_Frame;

static JSValue frozen_func778(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func778_Frame *frames = js_malloc(ctx, sizeof(frozen_func778_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func778_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func778_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func778, "frozen_func778", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func778", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func781(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func781_Frame {
    JSValue args[2];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func781_Frame;

static JSValue frozen_func781(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func781_Frame *frames = js_malloc(ctx, sizeof(frozen_func781_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 2; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func781_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 2;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 2; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = JS_UNDEFINED;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            frame->result = POP(); next_block = -1; break;
            }
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            PUSH(argc_inner > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
            { JSValue arg0 = POP(); JSValue func = POP();
              JSValue ret = JS_Call(ctx, func, JS_UNDEFINED, 1, &arg0);
              FROZEN_FREE(ctx, func); FROZEN_FREE(ctx, arg0);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            frame->result = POP(); next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func781_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func781, "frozen_func781", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func781", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func787(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func787(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* is_null */
    { JSValue v = POP(); PUSH(JS_NewBool(ctx, JS_IsNull(v))); FROZEN_FREE(ctx, v); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func787_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func787, "frozen_func787", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func787", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func788(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func788(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* null */
    PUSH(JS_NULL);
    /* eq */
    { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, frozen_eq(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func788_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func788, "frozen_func788", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func788", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func797(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func797(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* typeof_is_function */
    { JSValue v = POP(); PUSH(JS_NewBool(ctx, JS_IsFunction(ctx, v))); FROZEN_FREE(ctx, v); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func797_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func797, "frozen_func797", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func797", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func802(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func802(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func802_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func802, "frozen_func802", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func802", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func804(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func804(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func804_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func804, "frozen_func804", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func804", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func805(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func805(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func805_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func805, "frozen_func805", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func805", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func806(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func806(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func806_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func806, "frozen_func806", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func806", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func807(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func807(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func807_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func807, "frozen_func807", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func807", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func808(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func808(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* push_false */
    PUSH(JS_FALSE);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func808_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func808, "frozen_func808", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func808", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func814(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func814(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    PUSH(JS_MKVAL(JS_TAG_INT, 8));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func814_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func814, "frozen_func814", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func814", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func815(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func815(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* dup */
    { JSValue tmp = TOP(); PUSH(FROZEN_DUP(ctx, tmp)); }
    { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); goto block_2; } JS_FreeValue(ctx, cond); }
block_1:
    /* drop */
    FROZEN_FREE(ctx, POP());
    PUSH(JS_MKVAL(JS_TAG_INT, 16));
block_2:
    PUSH(JS_MKVAL(JS_TAG_INT, 256));
    /* lte */
    { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, frozen_lte(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func815_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func815, "frozen_func815", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func815", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func816(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func816(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func816_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func816, "frozen_func816", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func816", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func817(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func817(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func817_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func817, "frozen_func817", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func817", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func818(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func818(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func818_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func818, "frozen_func818", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func818", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func819(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func819(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* push_false */
    PUSH(JS_FALSE);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func819_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func819, "frozen_func819", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func819", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func825(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func825(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    PUSH(JS_MKVAL(JS_TAG_INT, 8));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func825_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func825, "frozen_func825", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func825", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func826(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func826(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* dup */
    { JSValue tmp = TOP(); PUSH(FROZEN_DUP(ctx, tmp)); }
    { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); goto block_2; } JS_FreeValue(ctx, cond); }
block_1:
    /* drop */
    FROZEN_FREE(ctx, POP());
    PUSH(JS_MKVAL(JS_TAG_INT, 16));
block_2:
    PUSH(JS_MKVAL(JS_TAG_INT, 256));
    /* lte */
    { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, frozen_lte(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func826_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func826, "frozen_func826", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func826", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func830(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func830(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 1307, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func830_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func830, "frozen_func830", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func830", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func831(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func831(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 716, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func831_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func831, "frozen_func831", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func831", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func832(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func832(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* push_true */
    PUSH(JS_TRUE);
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 1308, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func832_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func832, "frozen_func832", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func832", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func835(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func835(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    PUSH(JS_UNDEFINED); /* TODO: closure var_ref */
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 1315); if (JS_IsException(val)) return val; PUSH(val); }
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func835_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func835, "frozen_func835", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func835", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func836(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func836(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    PUSH(JS_UNDEFINED); /* TODO: closure var_ref */
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 1315); if (JS_IsException(val)) return val; PUSH(val); }
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func836_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func836, "frozen_func836", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func836", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func844(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func844(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func844_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func844, "frozen_func844", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func844", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func845(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func845(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func845_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func845, "frozen_func845", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func845", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func846(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func846(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* push_false */
    PUSH(JS_FALSE);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func846_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func846, "frozen_func846", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func846", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func847(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func847(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func847_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func847, "frozen_func847", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func847", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func853(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func853(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 1328); if (JS_IsException(val)) return val; PUSH(val); }
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* get_arg1 */
    PUSH(argc > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func853_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func853, "frozen_func853", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func853", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func854(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func854(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 1329); if (JS_IsException(val)) return val; PUSH(val); }
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* get_arg1 */
    PUSH(argc > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func854_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func854, "frozen_func854", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func854", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func857(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func857_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func857_Frame;

static JSValue frozen_func857(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func857_Frame *frames = js_malloc(ctx, sizeof(frozen_func857_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func857_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NULL);
            PUSH(JS_UNDEFINED);
            case 1:
                /* Recursive call 3 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func857_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func857, "frozen_func857", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func857", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func858(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func858_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func858_Frame;

static JSValue frozen_func858(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func858_Frame *frames = js_malloc(ctx, sizeof(frozen_func858_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func858_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func858_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func858, "frozen_func858", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func858", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func860(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func860_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func860_Frame;

static JSValue frozen_func860(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func860_Frame *frames = js_malloc(ctx, sizeof(frozen_func860_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func860_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NULL);
            PUSH(JS_UNDEFINED);
            case 1:
                /* Recursive call 3 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func860_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func860, "frozen_func860", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func860", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func861(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func861_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func861_Frame;

static JSValue frozen_func861(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func861_Frame *frames = js_malloc(ctx, sizeof(frozen_func861_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func861_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func861_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func861, "frozen_func861", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func861", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func863(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func863_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func863_Frame;

static JSValue frozen_func863(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func863_Frame *frames = js_malloc(ctx, sizeof(frozen_func863_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func863_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NULL);
            PUSH(JS_UNDEFINED);
            case 1:
                /* Recursive call 3 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func863_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func863, "frozen_func863", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func863", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func864(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func864_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func864_Frame;

static JSValue frozen_func864(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func864_Frame *frames = js_malloc(ctx, sizeof(frozen_func864_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func864_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func864_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func864, "frozen_func864", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func864", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func866(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func866_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func866_Frame;

static JSValue frozen_func866(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func866_Frame *frames = js_malloc(ctx, sizeof(frozen_func866_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func866_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NULL);
            PUSH(JS_UNDEFINED);
            case 1:
                /* Recursive call 3 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func866_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func866, "frozen_func866", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func866", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func867(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func867_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func867_Frame;

static JSValue frozen_func867(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func867_Frame *frames = js_malloc(ctx, sizeof(frozen_func867_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func867_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func867_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func867, "frozen_func867", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func867", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func869(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func869_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func869_Frame;

static JSValue frozen_func869(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func869_Frame *frames = js_malloc(ctx, sizeof(frozen_func869_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func869_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func869_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func869, "frozen_func869", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func869", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func871(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func871_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func871_Frame;

static JSValue frozen_func871(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func871_Frame *frames = js_malloc(ctx, sizeof(frozen_func871_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func871_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NULL);
            PUSH(JS_UNDEFINED);
            case 1:
                /* Recursive call 3 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func871_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func871, "frozen_func871", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func871", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func872(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func872_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func872_Frame;

static JSValue frozen_func872(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func872_Frame *frames = js_malloc(ctx, sizeof(frozen_func872_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func872_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func872_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func872, "frozen_func872", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func872", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func874(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func874_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func874_Frame;

static JSValue frozen_func874(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func874_Frame *frames = js_malloc(ctx, sizeof(frozen_func874_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func874_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NULL);
            PUSH(JS_UNDEFINED);
            case 1:
                /* Recursive call 3 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func874_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func874, "frozen_func874", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func874", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func875(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func875_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func875_Frame;

static JSValue frozen_func875(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func875_Frame *frames = js_malloc(ctx, sizeof(frozen_func875_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func875_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func875_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func875, "frozen_func875", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func875", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func885(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func885(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 1338); if (JS_IsException(val)) return val; PUSH(val); }
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func885_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func885, "frozen_func885", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func885", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func886(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func886(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 1339); if (JS_IsException(val)) return val; PUSH(val); }
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func886_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func886, "frozen_func886", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func886", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func890(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func890(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg2 */
    PUSH(argc > 2 ? FROZEN_DUP(ctx, argv[2]) : JS_UNDEFINED);
    /* null */
    PUSH(JS_NULL);
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue args[2]; args[1] = POP(); args[0] = POP(); JSValue func = POP(); JSValue ret = JS_Call(ctx, func, JS_UNDEFINED, 2, args); JS_FreeValue(ctx, func); JS_FreeValue(ctx, args[0]); JS_FreeValue(ctx, args[1]); if (JS_IsException(ret)) return ret; PUSH(ret); }
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func890_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func890, "frozen_func890", 3);
    JS_SetPropertyStr(ctx, global, "frozen_func890", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func892(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func892(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg2 */
    PUSH(argc > 2 ? FROZEN_DUP(ctx, argv[2]) : JS_UNDEFINED);
    /* null */
    PUSH(JS_NULL);
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue args[2]; args[1] = POP(); args[0] = POP(); JSValue func = POP(); JSValue ret = JS_Call(ctx, func, JS_UNDEFINED, 2, args); JS_FreeValue(ctx, func); JS_FreeValue(ctx, args[0]); JS_FreeValue(ctx, args[1]); if (JS_IsException(ret)) return ret; PUSH(ret); }
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func892_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func892, "frozen_func892", 3);
    JS_SetPropertyStr(ctx, global, "frozen_func892", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func908(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func908(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 1344); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func908_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func908, "frozen_func908", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func908", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func909(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func909(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 1345); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func909_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func909, "frozen_func909", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func909", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func915(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func915(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    PUSH(JS_MKVAL(JS_TAG_INT, 8));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func915_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func915, "frozen_func915", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func915", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func918(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func918(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* push_0 */
    PUSH(JS_MKVAL(JS_TAG_INT, 0));
    /* gte */
    { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, frozen_gte(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
    /* dup */
    { JSValue tmp = TOP(); PUSH(FROZEN_DUP(ctx, tmp)); }
    { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); goto block_2; } JS_FreeValue(ctx, cond); }
block_1:
    /* drop */
    FROZEN_FREE(ctx, POP());
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* push_2 */
    PUSH(JS_MKVAL(JS_TAG_INT, 2));
    /* lte */
    { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, frozen_lte(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
block_2:
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func918_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func918, "frozen_func918", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func918", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func926(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func926(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* push_false */
    PUSH(JS_FALSE);
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 1355, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func926_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func926, "frozen_func926", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func926", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func930(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func930(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 1354, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* push_true */
    PUSH(JS_TRUE);
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 1355, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func930_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func930, "frozen_func930", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func930", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func938(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func938(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 1362); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func938_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func938, "frozen_func938", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func938", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func939(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func939(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 1363); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func939_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func939, "frozen_func939", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func939", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func944(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func944(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* push_true */
    PUSH(JS_TRUE);
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 1360, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func944_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func944, "frozen_func944", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func944", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func945(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func945(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* push_false */
    PUSH(JS_FALSE);
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 1360, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func945_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func945, "frozen_func945", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func945", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func950(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func950_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func950_Frame;

static JSValue frozen_func950(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func950_Frame *frames = js_malloc(ctx, sizeof(frozen_func950_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func950_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 3 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func950_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func950, "frozen_func950", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func950", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func952(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func952_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func952_Frame;

static JSValue frozen_func952(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func952_Frame *frames = js_malloc(ctx, sizeof(frozen_func952_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func952_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func952_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func952, "frozen_func952", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func952", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func956(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func956(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func956_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func956, "frozen_func956", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func956", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func966(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func966(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    PUSH(JS_UNDEFINED); /* TODO: closure var_ref */
    { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); goto block_2; } JS_FreeValue(ctx, cond); }
block_1:
    PUSH(JS_UNDEFINED); /* TODO: closure var_ref */
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* push_empty_string */
    PUSH(JS_NewString(ctx, ""));
    /* push_empty_string */
    PUSH(JS_NewString(ctx, ""));
    { JSValue args[3]; args[2] = POP(); args[1] = POP(); args[0] = POP(); JSValue func = POP(); JSValue ret = JS_Call(ctx, func, JS_UNDEFINED, 3, args); JS_FreeValue(ctx, func); JS_FreeValue(ctx, args[0]); JS_FreeValue(ctx, args[1]); JS_FreeValue(ctx, args[2]); if (JS_IsException(ret)) return ret; PUSH(ret); }
    /* drop */
    FROZEN_FREE(ctx, POP());
block_2:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func966_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func966, "frozen_func966", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func966", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func971(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func971(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    PUSH(JS_UNDEFINED); /* TODO: closure var_ref */
    { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); goto block_2; } JS_FreeValue(ctx, cond); }
block_1:
    PUSH(JS_UNDEFINED); /* TODO: closure var_ref */
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* push_empty_string */
    PUSH(JS_NewString(ctx, ""));
    /* push_empty_string */
    PUSH(JS_NewString(ctx, ""));
    { JSValue args[3]; args[2] = POP(); args[1] = POP(); args[0] = POP(); JSValue func = POP(); JSValue ret = JS_Call(ctx, func, JS_UNDEFINED, 3, args); JS_FreeValue(ctx, func); JS_FreeValue(ctx, args[0]); JS_FreeValue(ctx, args[1]); JS_FreeValue(ctx, args[2]); if (JS_IsException(ret)) return ret; PUSH(ret); }
    /* drop */
    FROZEN_FREE(ctx, POP());
block_2:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func971_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func971, "frozen_func971", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func971", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func974(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func974_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func974_Frame;

static JSValue frozen_func974(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func974_Frame *frames = js_malloc(ctx, sizeof(frozen_func974_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func974_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NULL);
            PUSH(JS_NewString(ctx, " args="));
            PUSH(JS_MKVAL(JS_TAG_INT, 4));
            case 1:
                /* Recursive call 4 (3 args) - push frame */
                {
                    JSValue arg2 = POP();
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].args[2] = arg2;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func974_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func974, "frozen_func974", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func974", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func975(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func975_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func975_Frame;

static JSValue frozen_func975(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func975_Frame *frames = js_malloc(ctx, sizeof(frozen_func975_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func975_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NULL);
            PUSH(JS_NewString(ctx, " args="));
            PUSH(JS_MKVAL(JS_TAG_INT, 4));
            case 1:
                /* Recursive call 4 (3 args) - push frame */
                {
                    JSValue arg2 = POP();
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].args[2] = arg2;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func975_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func975, "frozen_func975", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func975", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func977(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func977_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func977_Frame;

static JSValue frozen_func977(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func977_Frame *frames = js_malloc(ctx, sizeof(frozen_func977_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func977_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NULL);
            PUSH(JS_NewString(ctx, " args="));
            { JSValue len = POP(); JSValue arr = POP();
              JSValue new_arr = JS_NewArray(ctx);
              if (!JS_IsException(new_arr)) {
                int64_t length = 0;
                JS_ToInt64(ctx, &length, len);
                for (int64_t i = 0; i < length; i++) {
                  JSValue elem = JS_GetPropertyInt64(ctx, arr, i);
                  JS_SetPropertyInt64(ctx, new_arr, i, elem);
                }
              }
              FROZEN_FREE(ctx, arr); FROZEN_FREE(ctx, len);
              if (JS_IsException(new_arr)) { next_block = -1; frame->result = new_arr; break; }
              PUSH(new_arr); }
            case 1:
                /* Recursive call 4 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func977_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func977, "frozen_func977", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func977", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func980(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func980_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func980_Frame;

static JSValue frozen_func980(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func980_Frame *frames = js_malloc(ctx, sizeof(frozen_func980_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func980_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NULL);
            PUSH(JS_NewString(ctx, "function()"));
            { JSValue len = POP(); JSValue arr = POP();
              JSValue new_arr = JS_NewArray(ctx);
              if (!JS_IsException(new_arr)) {
                int64_t length = 0;
                JS_ToInt64(ctx, &length, len);
                for (int64_t i = 0; i < length; i++) {
                  JSValue elem = JS_GetPropertyInt64(ctx, arr, i);
                  JS_SetPropertyInt64(ctx, new_arr, i, elem);
                }
              }
              FROZEN_FREE(ctx, arr); FROZEN_FREE(ctx, len);
              if (JS_IsException(new_arr)) { next_block = -1; frame->result = new_arr; break; }
              PUSH(new_arr); }
            case 1:
                /* Recursive call 4 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func980_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func980, "frozen_func980", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func980", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func982(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func982_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func982_Frame;

static JSValue frozen_func982(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func982_Frame *frames = js_malloc(ctx, sizeof(frozen_func982_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func982_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NULL);
            { JSValue len = POP(); JSValue arr = POP();
              JSValue new_arr = JS_NewArray(ctx);
              if (!JS_IsException(new_arr)) {
                int64_t length = 0;
                JS_ToInt64(ctx, &length, len);
                for (int64_t i = 0; i < length; i++) {
                  JSValue elem = JS_GetPropertyInt64(ctx, arr, i);
                  JS_SetPropertyInt64(ctx, new_arr, i, elem);
                }
              }
              FROZEN_FREE(ctx, arr); FROZEN_FREE(ctx, len);
              if (JS_IsException(new_arr)) { next_block = -1; frame->result = new_arr; break; }
              PUSH(new_arr); }
            case 1:
                /* Recursive call 3 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func982_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func982, "frozen_func982", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func982", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func984(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func984_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func984_Frame;

static JSValue frozen_func984(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func984_Frame *frames = js_malloc(ctx, sizeof(frozen_func984_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func984_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NULL);
            { JSValue len = POP(); JSValue arr = POP();
              JSValue new_arr = JS_NewArray(ctx);
              if (!JS_IsException(new_arr)) {
                int64_t length = 0;
                JS_ToInt64(ctx, &length, len);
                for (int64_t i = 0; i < length; i++) {
                  JSValue elem = JS_GetPropertyInt64(ctx, arr, i);
                  JS_SetPropertyInt64(ctx, new_arr, i, elem);
                }
              }
              FROZEN_FREE(ctx, arr); FROZEN_FREE(ctx, len);
              if (JS_IsException(new_arr)) { next_block = -1; frame->result = new_arr; break; }
              PUSH(new_arr); }
            case 1:
                /* Recursive call 3 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func984_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func984, "frozen_func984", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func984", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func986(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func986_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func986_Frame;

static JSValue frozen_func986(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func986_Frame *frames = js_malloc(ctx, sizeof(frozen_func986_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func986_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NULL);
            { JSValue len = POP(); JSValue arr = POP();
              JSValue new_arr = JS_NewArray(ctx);
              if (!JS_IsException(new_arr)) {
                int64_t length = 0;
                JS_ToInt64(ctx, &length, len);
                for (int64_t i = 0; i < length; i++) {
                  JSValue elem = JS_GetPropertyInt64(ctx, arr, i);
                  JS_SetPropertyInt64(ctx, new_arr, i, elem);
                }
              }
              FROZEN_FREE(ctx, arr); FROZEN_FREE(ctx, len);
              if (JS_IsException(new_arr)) { next_block = -1; frame->result = new_arr; break; }
              PUSH(new_arr); }
            case 1:
                /* Recursive call 3 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func986_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func986, "frozen_func986", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func986", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func988(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func988_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func988_Frame;

static JSValue frozen_func988(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func988_Frame *frames = js_malloc(ctx, sizeof(frozen_func988_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func988_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NULL);
            { JSValue len = POP(); JSValue arr = POP();
              JSValue new_arr = JS_NewArray(ctx);
              if (!JS_IsException(new_arr)) {
                int64_t length = 0;
                JS_ToInt64(ctx, &length, len);
                for (int64_t i = 0; i < length; i++) {
                  JSValue elem = JS_GetPropertyInt64(ctx, arr, i);
                  JS_SetPropertyInt64(ctx, new_arr, i, elem);
                }
              }
              FROZEN_FREE(ctx, arr); FROZEN_FREE(ctx, len);
              if (JS_IsException(new_arr)) { next_block = -1; frame->result = new_arr; break; }
              PUSH(new_arr); }
            case 1:
                /* Recursive call 3 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func988_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func988, "frozen_func988", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func988", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func990(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func990_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func990_Frame;

static JSValue frozen_func990(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func990_Frame *frames = js_malloc(ctx, sizeof(frozen_func990_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func990_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NULL);
            { JSValue len = POP(); JSValue arr = POP();
              JSValue new_arr = JS_NewArray(ctx);
              if (!JS_IsException(new_arr)) {
                int64_t length = 0;
                JS_ToInt64(ctx, &length, len);
                for (int64_t i = 0; i < length; i++) {
                  JSValue elem = JS_GetPropertyInt64(ctx, arr, i);
                  JS_SetPropertyInt64(ctx, new_arr, i, elem);
                }
              }
              FROZEN_FREE(ctx, arr); FROZEN_FREE(ctx, len);
              if (JS_IsException(new_arr)) { next_block = -1; frame->result = new_arr; break; }
              PUSH(new_arr); }
            case 1:
                /* Recursive call 3 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func990_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func990, "frozen_func990", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func990", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func992(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func992_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func992_Frame;

static JSValue frozen_func992(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func992_Frame *frames = js_malloc(ctx, sizeof(frozen_func992_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func992_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NULL);
            { JSValue len = POP(); JSValue arr = POP();
              JSValue new_arr = JS_NewArray(ctx);
              if (!JS_IsException(new_arr)) {
                int64_t length = 0;
                JS_ToInt64(ctx, &length, len);
                for (int64_t i = 0; i < length; i++) {
                  JSValue elem = JS_GetPropertyInt64(ctx, arr, i);
                  JS_SetPropertyInt64(ctx, new_arr, i, elem);
                }
              }
              FROZEN_FREE(ctx, arr); FROZEN_FREE(ctx, len);
              if (JS_IsException(new_arr)) { next_block = -1; frame->result = new_arr; break; }
              PUSH(new_arr); }
            case 1:
                /* Recursive call 3 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func992_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func992, "frozen_func992", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func992", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func994(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func994_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func994_Frame;

static JSValue frozen_func994(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func994_Frame *frames = js_malloc(ctx, sizeof(frozen_func994_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func994_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NULL);
            { JSValue len = POP(); JSValue arr = POP();
              JSValue new_arr = JS_NewArray(ctx);
              if (!JS_IsException(new_arr)) {
                int64_t length = 0;
                JS_ToInt64(ctx, &length, len);
                for (int64_t i = 0; i < length; i++) {
                  JSValue elem = JS_GetPropertyInt64(ctx, arr, i);
                  JS_SetPropertyInt64(ctx, new_arr, i, elem);
                }
              }
              FROZEN_FREE(ctx, arr); FROZEN_FREE(ctx, len);
              if (JS_IsException(new_arr)) { next_block = -1; frame->result = new_arr; break; }
              PUSH(new_arr); }
            case 1:
                /* Recursive call 3 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func994_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func994, "frozen_func994", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func994", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func996(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func996_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func996_Frame;

static JSValue frozen_func996(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func996_Frame *frames = js_malloc(ctx, sizeof(frozen_func996_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func996_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NULL);
            PUSH(JS_NULL);
            case 1:
                /* Recursive call 3 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func996_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func996, "frozen_func996", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func996", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func998(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func998_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func998_Frame;

static JSValue frozen_func998(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func998_Frame *frames = js_malloc(ctx, sizeof(frozen_func998_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func998_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NULL);
            { JSValue len = POP(); JSValue arr = POP();
              JSValue new_arr = JS_NewArray(ctx);
              if (!JS_IsException(new_arr)) {
                int64_t length = 0;
                JS_ToInt64(ctx, &length, len);
                for (int64_t i = 0; i < length; i++) {
                  JSValue elem = JS_GetPropertyInt64(ctx, arr, i);
                  JS_SetPropertyInt64(ctx, new_arr, i, elem);
                }
              }
              FROZEN_FREE(ctx, arr); FROZEN_FREE(ctx, len);
              if (JS_IsException(new_arr)) { next_block = -1; frame->result = new_arr; break; }
              PUSH(new_arr); }
            case 1:
                /* Recursive call 3 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func998_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func998, "frozen_func998", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func998", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1000(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1000(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1000_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1000, "frozen_func1000", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func1000", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1006(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1006(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1006_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1006, "frozen_func1006", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func1006", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1009(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1009(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1009_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1009, "frozen_func1009", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1009", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1015(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1015(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1015_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1015, "frozen_func1015", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1015", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1016(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func1016_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func1016_Frame;

static JSValue frozen_func1016(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func1016_Frame *frames = js_malloc(ctx, sizeof(frozen_func1016_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func1016_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            PUSH(JS_NewString(ctx, "sep"));
            { JSValue args[1 > 0 ? 1 : 1]; args[0] = POP(); JSValue ctor = POP();
              JSValue ret = JS_CallConstructor(ctx, ctor, 1, args);
              FROZEN_FREE(ctx, ctor); FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(ret)) { next_block = -1; frame->result = ret; break; }
              PUSH(ret); }
            case 1:
                /* Recursive call 5 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func1016_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1016, "frozen_func1016", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1016", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1018(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1018(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* push_0 */
    PUSH(JS_MKVAL(JS_TAG_INT, 0));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1018_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1018, "frozen_func1018", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1018", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1028(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1028(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1028_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1028, "frozen_func1028", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1028", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1032(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1032(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* push_true */
    PUSH(JS_TRUE);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1032_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1032, "frozen_func1032", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1032", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1036(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1036(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1036_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1036, "frozen_func1036", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1036", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1037(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1037(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1037_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1037, "frozen_func1037", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1037", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1038(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1038(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1038_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1038, "frozen_func1038", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1038", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1039(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1039(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1039_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1039, "frozen_func1039", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1039", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1040(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1040(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1040_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1040, "frozen_func1040", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1040", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1041(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1041(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1041_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1041, "frozen_func1041", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1041", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1044(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1044(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 1478, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1044_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1044, "frozen_func1044", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func1044", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1046(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func1046_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func1046_Frame;

static JSValue frozen_func1046(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func1046_Frame *frames = js_malloc(ctx, sizeof(frozen_func1046_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func1046_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            /* Unsupported opcode 194 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            case 1:
                /* Recursive call 2 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func1046_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1046, "frozen_func1046", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1046", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1058(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1058(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1058_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1058, "frozen_func1058", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func1058", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1063(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1063(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 56); if (JS_IsException(val)) return val; PUSH(val); }
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 458); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1063_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1063, "frozen_func1063", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func1063", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1068(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1068(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1068_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1068, "frozen_func1068", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1068", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1069(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1069(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1069_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1069, "frozen_func1069", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1069", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1070(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1070(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1070_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1070, "frozen_func1070", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1070", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1071(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1071(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1071_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1071, "frozen_func1071", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1071", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1076(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1076(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1076_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1076, "frozen_func1076", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1076", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1077(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1077(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1077_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1077, "frozen_func1077", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1077", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1078(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1078(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1078_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1078, "frozen_func1078", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1078", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1079(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1079(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1079_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1079, "frozen_func1079", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1079", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1080(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1080(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* push_0 */
    PUSH(JS_MKVAL(JS_TAG_INT, 0));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1080_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1080, "frozen_func1080", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1080", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1082(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1082(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* dup */
    { JSValue tmp = TOP(); PUSH(FROZEN_DUP(ctx, tmp)); }
    { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); goto block_2; } JS_FreeValue(ctx, cond); }
block_1:
    /* drop */
    FROZEN_FREE(ctx, POP());
    /* object */
    PUSH(JS_NewObject(ctx));
block_2:
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1082_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1082, "frozen_func1082", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func1082", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1088(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1088(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 1496); if (JS_IsException(val)) return val; PUSH(val); }
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* dup */
    { JSValue tmp = TOP(); PUSH(FROZEN_DUP(ctx, tmp)); }
    { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); goto block_2; } JS_FreeValue(ctx, cond); }
block_1:
    /* drop */
    FROZEN_FREE(ctx, POP());
    /* object */
    PUSH(JS_NewObject(ctx));
block_2:
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1088_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1088, "frozen_func1088", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func1088", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1090(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1090(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* push_true */
    PUSH(JS_TRUE);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1090_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1090, "frozen_func1090", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1090", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1095(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1095(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1095_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1095, "frozen_func1095", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1095", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1096(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1096(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1096_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1096, "frozen_func1096", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1096", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1097(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1097(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1097_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1097, "frozen_func1097", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1097", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1108(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1108(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    PUSH(JS_UNDEFINED); /* TODO: closure var_ref */
    /* null */
    PUSH(JS_NULL);
    /* push_0 */
    PUSH(JS_MKVAL(JS_TAG_INT, 0));
    { JSValue args[2]; args[1] = POP(); args[0] = POP(); JSValue func = POP(); JSValue ret = JS_Call(ctx, func, JS_UNDEFINED, 2, args); JS_FreeValue(ctx, func); JS_FreeValue(ctx, args[0]); JS_FreeValue(ctx, args[1]); if (JS_IsException(ret)) return ret; PUSH(ret); }
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1108_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1108, "frozen_func1108", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1108", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1110(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1110(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1110_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1110, "frozen_func1110", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1110", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1111(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1111(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1111_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1111, "frozen_func1111", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1111", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1116(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1116(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1116_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1116, "frozen_func1116", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1116", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1117(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1117(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1117_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1117, "frozen_func1117", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1117", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1120(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1120(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1120_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1120, "frozen_func1120", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func1120", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1121(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1121(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1121_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1121, "frozen_func1121", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func1121", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1138(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func1138_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[2];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func1138_Frame;

static JSValue frozen_func1138(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func1138_Frame *frames = js_malloc(ctx, sizeof(frozen_func1138_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 2; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func1138_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "mod");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            {
              JSValue args[1];
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 1, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = FROZEN_DUP(ctx, TOP()); }
            /* Unsupported opcode 235 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = FROZEN_DUP(ctx, TOP()); }
            PUSH(JS_MKVAL(JS_TAG_INT, 0));
            { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, JS_IsStrictEqual(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 3; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 3; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 2;
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            PUSH(JS_MKVAL(JS_TAG_INT, 0));
            case 1:
                /* Recursive call 3 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 2; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        case 3:
            switch (frame->instr_offset) {
            case 0:
            PUSH(FROZEN_DUP(ctx, frame->locals[0]));
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "Failed to create HostMap");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            /* Unsupported opcode 193 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            {
              JSValue args[1];
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 1, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            frame->result = JS_UNDEFINED; next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func1138_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1138, "frozen_func1138", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func1138", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1142(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1142(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* push_false */
    PUSH(JS_FALSE);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1142_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1142, "frozen_func1142", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1142", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1143(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1143(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* push_true */
    PUSH(JS_TRUE);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1143_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1143, "frozen_func1143", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1143", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1146(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1146(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    PUSH(JS_UNDEFINED); /* TODO: closure var_ref */
    /* strict_neq */
    { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, frozen_neq(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1146_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1146, "frozen_func1146", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func1146", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1148(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func1148_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func1148_Frame;

static JSValue frozen_func1148(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func1148_Frame *frames = js_malloc(ctx, sizeof(frozen_func1148_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func1148_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            PUSH(JS_UNDEFINED);
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "onFulfilled");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            case 1:
                /* Recursive call 4 (2 args) - push frame */
                {
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func1148_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1148, "frozen_func1148", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func1148", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1150(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1150(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 1535); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* get_length */
    { JSValue obj = POP(); int64_t len = frozen_get_length(ctx, obj); FROZEN_FREE(ctx, obj); PUSH(JS_NewInt64(ctx, len)); }
    /* push_0 */
    PUSH(JS_MKVAL(JS_TAG_INT, 0));
    /* gt */
    { JSValue b = POP(), a = POP(); PUSH(JS_NewBool(ctx, frozen_gt(ctx, a, b))); FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1150_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1150, "frozen_func1150", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1150", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1155(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1155(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1155_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1155, "frozen_func1155", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func1155", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1156(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1156(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1156_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1156, "frozen_func1156", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func1156", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1157(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1157(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1157_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1157, "frozen_func1157", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func1157", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1158(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1158(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1158_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1158, "frozen_func1158", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func1158", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1159(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func1159_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func1159_Frame;

static JSValue frozen_func1159(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func1159_Frame *frames = js_malloc(ctx, sizeof(frozen_func1159_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func1159_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "hostname");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            PUSH(JS_NULL);
            PUSH(JS_MKVAL(JS_TAG_INT, 2));
            {
              JSValue args[3];
              args[2] = POP();
              args[1] = POP();
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 3, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              FROZEN_FREE(ctx, args[1]);
              FROZEN_FREE(ctx, args[2]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            case 1:
                /* Recursive call 7 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func1159_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1159, "frozen_func1159", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func1159", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1160(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1160(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1160_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1160, "frozen_func1160", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1160", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1161(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1161(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1161_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1161, "frozen_func1161", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1161", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1164(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1164(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* dup */
    { JSValue tmp = TOP(); PUSH(FROZEN_DUP(ctx, tmp)); }
    { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); goto block_2; } JS_FreeValue(ctx, cond); }
block_1:
    /* drop */
    FROZEN_FREE(ctx, POP());
    /* object */
    PUSH(JS_NewObject(ctx));
block_2:
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 619, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1164_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1164, "frozen_func1164", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func1164", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1166(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1166(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 624, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    /* get_arg1 */
    PUSH(argc > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
    /* dup */
    { JSValue tmp = TOP(); PUSH(FROZEN_DUP(ctx, tmp)); }
    /* is_undefined_or_null */
    { JSValue v = POP(); PUSH(JS_NewBool(ctx, JS_IsUndefined(v) || JS_IsNull(v))); FROZEN_FREE(ctx, v); }
    { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); goto block_2; } JS_FreeValue(ctx, cond); }
block_1:
    /* drop */
    FROZEN_FREE(ctx, POP());
    /* undefined */
    PUSH(JS_UNDEFINED);
    goto block_3;
block_2:
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 139); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
block_3:
    /* dup */
    { JSValue tmp = TOP(); PUSH(FROZEN_DUP(ctx, tmp)); }
    { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); goto block_5; } JS_FreeValue(ctx, cond); }
block_4:
    /* drop */
    FROZEN_FREE(ctx, POP());
    PUSH(JS_MKVAL(JS_TAG_INT, 200));
block_5:
    { JSValue val = POP(); JSValue obj = POP(); int r = JS_SetProperty(ctx, obj, 139, val); FROZEN_FREE(ctx, obj); if (r < 0) return JS_EXCEPTION; }
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1166_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1166, "frozen_func1166", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func1166", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1168(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1168(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1168_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1168, "frozen_func1168", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func1168", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1186(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1186(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    PUSH(JS_UNDEFINED); /* TODO: closure var_ref */
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 616); if (JS_IsException(val)) return val; PUSH(val); }
    /* get_arg1 */
    PUSH(argc > 1 ? FROZEN_DUP(ctx, argv[1]) : JS_UNDEFINED);
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1186_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1186, "frozen_func1186", 2);
    JS_SetPropertyStr(ctx, global, "frozen_func1186", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1192(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1192(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 580); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 100); if (JS_IsException(val)) return val; PUSH(val); }
    /* get_arg0 */
    PUSH(argc > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1192_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1192, "frozen_func1192", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func1192", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1197(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func1197_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[1];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func1197_Frame;

static JSValue frozen_func1197(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func1197_Frame *frames = js_malloc(ctx, sizeof(frozen_func1197_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 1; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func1197_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(argc_inner > 0 ? FROZEN_DUP(ctx, argv[0]) : JS_UNDEFINED);
            PUSH(JS_UNDEFINED);
            PUSH(JS_UNDEFINED);
            case 1:
                /* Recursive call 4 (3 args) - push frame */
                {
                    JSValue arg2 = POP();
                    JSValue arg1 = POP();
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].args[1] = arg1;
                    frames[frame_depth].args[2] = arg2;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 1; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after tail_call - return child result */
            frame->result = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
            next_block = -1; break;
            }
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func1197_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1197, "frozen_func1197", 1);
    JS_SetPropertyStr(ctx, global, "frozen_func1197", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1203(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1203(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = TOP(); JSValue val = JS_GetProperty(ctx, obj, 584); if (JS_IsException(val)) return val; PUSH(val); }
    { JSValue arg = POP(); JSValue this = POP(); JSValue func = POP(); FROZEN_EXIT_STACK(); return JS_Call(ctx, func, this, 1, &arg); }

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1203_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1203, "frozen_func1203", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1203", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1207(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1207(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 595); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 604); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    { JSValue b = POP(), a = POP();
      if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
          int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
          if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
              PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));  /* Fast path: no alloc */
          } else {
              PUSH(JS_NewFloat64(ctx, (double)sum));  /* Overflow to float64 */
          }
      } else {
          JSValue r = frozen_add(ctx, a, b);  /* Slow path */
          FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
          if (JS_IsException(r)) return r;
          PUSH(r);
      }
    }
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 605); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    { JSValue b = POP(), a = POP();
      if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
          int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
          if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
              PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));  /* Fast path: no alloc */
          } else {
              PUSH(JS_NewFloat64(ctx, (double)sum));  /* Overflow to float64 */
          }
      } else {
          JSValue r = frozen_add(ctx, a, b);  /* Slow path */
          FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
          if (JS_IsException(r)) return r;
          PUSH(r);
      }
    }
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 606); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    { JSValue b = POP(), a = POP();
      if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
          int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
          if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
              PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));  /* Fast path: no alloc */
          } else {
              PUSH(JS_NewFloat64(ctx, (double)sum));  /* Overflow to float64 */
          }
      } else {
          JSValue r = frozen_add(ctx, a, b);  /* Slow path */
          FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
          if (JS_IsException(r)) return r;
          PUSH(r);
      }
    }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1207_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1207, "frozen_func1207", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1207", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1208(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1208(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 598); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1208_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1208, "frozen_func1208", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1208", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1209(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1209(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* complex handler - not auto-generated */
    /* put_loc0 */
    FROZEN_FREE(ctx, locals[0]); locals[0] = POP();
    /* get_loc0 */
    PUSH(FROZEN_DUP(ctx, locals[0]));
    { JSValue obj = POP(); JSValue val = JS_GetProperty(ctx, obj, 598); FROZEN_FREE(ctx, obj); if (JS_IsException(val)) return val; PUSH(val); }
    /* return */
    FROZEN_EXIT_STACK(); return POP();

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1209_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1209, "frozen_func1209", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1209", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1234(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* ============================================================================
 * JSC-style Trampoline: Heap-allocated frames, no C stack recursion
 * ============================================================================ */

/* Call frame lives on heap, not C stack */
typedef struct frozen_func1234_Frame {
    JSValue args[1];             /* Input arguments */
    JSValue result;                /* Return value */
    JSValue stack[256];            /* Operand stack */
    JSValue locals[3];           /* Local variables */
    int sp;                        /* Stack pointer */
    int block_id;                  /* Current basic block (PC) */
    int instr_offset;              /* Instruction offset within block */
    uint8_t waiting_for_call;      /* 0=running, 1=waiting for result */
} frozen_func1234_Frame;

static JSValue frozen_func1234(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
    (void)this_val;
    (void)argc;

    /* Allocate frame stack on heap (JSC approach) */
    const int MAX_FRAMES = 10000;
    frozen_func1234_Frame *frames = js_malloc(ctx, sizeof(frozen_func1234_Frame) * MAX_FRAMES);
    if (!frames) return JS_ThrowOutOfMemory(ctx);

    int frame_depth = 0;

    /* Initialize root frame */
    for (int i = 0; i < 1; i++) frames[0].args[i] = (i < argc) ? FROZEN_DUP(ctx, argv[i]) : JS_UNDEFINED;
    frames[0].sp = 0;
    frames[0].block_id = 0;
    frames[0].instr_offset = 0;
    frames[0].waiting_for_call = 0;
    for (int i = 0; i < 3; i++) frames[0].locals[i] = JS_UNDEFINED;

    /* Trampoline loop - iterative execution, not recursive! */
    while (frame_depth >= 0) {
trampoline_continue: ;  /* Jump here when pushing new frame (semicolon for C99 compat) */
        frozen_func1234_Frame *frame = &frames[frame_depth];

        /* Check for stack overflow */
        if (frame_depth >= MAX_FRAMES - 1) {
            js_free(ctx, frames);
            return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded");
        }

        /* Set up execution context for current frame */
        JSValue *stack = frame->stack;
        int sp = frame->sp;
        JSValue *locals = frame->locals;
        JSValue *argv = frame->args;
        int argc_inner = 1;
        (void)argc_inner;
        const int max_stack = 256;
        (void)max_stack;

        /* Execute bytecode for current frame */
        int next_block = -1;  /* -1 = return, >= 0 = goto block */
        /* printf("[TRAMPOLINE] depth=%d block=%d offset=%d sp=%d\n", frame_depth, frame->block_id, frame->instr_offset, sp); */

        switch (frame->block_id) {
        case 0:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_DupValue(ctx, this_val));
            { FROZEN_FREE(ctx, frame->locals[1]); frame->locals[1] = POP(); }
            /* Unsupported opcode 12 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { FROZEN_FREE(ctx, frame->locals[2]); frame->locals[2] = POP(); }
            { JSValue exc = JS_GetException(ctx); PUSH(exc); }
            break;
            }
            next_block = 1;
            break;
        case 1:
            switch (frame->instr_offset) {
            case 0:
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "val");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            PUSH(FROZEN_DUP(ctx, frame->locals[1]));
            PUSH(FROZEN_DUP(ctx, frame->locals[2]));
            {
              JSValue args[2];
              args[1] = POP();
              args[0] = POP();
              JSValue this_obj = POP();
              JSValue func = POP();
              JSValue result = JS_Call(ctx, func, this_obj, 2, args);
              FROZEN_FREE(ctx, func);
              FROZEN_FREE(ctx, this_obj);
              FROZEN_FREE(ctx, args[0]);
              FROZEN_FREE(ctx, args[1]);
              if (JS_IsException(result)) { next_block = -1; frame->result = result; break; }
              PUSH(result);
            }
            /* Unsupported opcode 140 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            { FROZEN_FREE(ctx, POP()); }
            /* Unsupported opcode 47 in trampoline */
            next_block = -1; frame->result = JS_UNDEFINED; break;
            break;
            }
            next_block = 2;
            break;
        case 2:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, frame->locals[0]); frame->locals[0] = POP(); }
            { JSValue exc = JS_GetException(ctx); PUSH(exc); }
            break;
            }
            next_block = 3;
            break;
        case 3:
            switch (frame->instr_offset) {
            }
            next_block = 4;
            break;
        case 4:
            switch (frame->instr_offset) {
            case 0:
            PUSH(JS_NewString(ctx, "O_NOFOLLOW"));
            PUSH(FROZEN_DUP(ctx, frame->locals[0]));
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "arr");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue v = TOP(); PUSH(FROZEN_DUP(ctx, v)); }
            { JSValue cond = POP(); if (JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 6; break; } JS_FreeValue(ctx, cond); }
            break;
            }
            next_block = 5;
            break;
        case 5:
            switch (frame->instr_offset) {
            case 0:
            { FROZEN_FREE(ctx, POP()); }
            PUSH(FROZEN_DUP(ctx, frame->locals[0]));
            break;
            }
            next_block = 6;
            break;
        case 6:
            switch (frame->instr_offset) {
            case 0:
            { JSValue b = POP(), a = POP();
              if (likely(JS_VALUE_GET_TAG(a) == JS_TAG_INT && JS_VALUE_GET_TAG(b) == JS_TAG_INT)) {
                  int64_t sum = (int64_t)JS_VALUE_GET_INT(a) + JS_VALUE_GET_INT(b);
                  if (likely(sum >= INT32_MIN && sum <= INT32_MAX)) {
                      PUSH(JS_MKVAL(JS_TAG_INT, (int32_t)sum));
                  } else {
                      PUSH(JS_NewFloat64(ctx, (double)sum));
                  }
              } else {
                  JSValue r = frozen_add(ctx, a, b);
                  FROZEN_FREE(ctx, a); FROZEN_FREE(ctx, b);
                  if (JS_IsException(r)) { next_block = -1; frame->result = r; break; }
                  PUSH(r);
              }
            }
            case 1:
                /* Recursive call 1 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 3; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { FROZEN_FREE(ctx, POP()); }
            PUSH(FROZEN_DUP(ctx, frame->locals[0]));
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "objects");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            { JSValue cond = POP(); if (!JS_ToBool(ctx, cond)) { JS_FreeValue(ctx, cond); next_block = 8; break; } JS_FreeValue(ctx, cond); }
            }
            if (next_block == -1) next_block = 7;
            break;
        case 7:
            switch (frame->instr_offset) {
            case 0:
            PUSH(FROZEN_DUP(ctx, frame->locals[0]));
            { JSValue obj = POP();
              JSValue val = JS_GetPropertyStr(ctx, obj, "objects");
              FROZEN_FREE(ctx, obj);
              if (JS_IsException(val)) { next_block = -1; frame->result = val; break; }
              PUSH(val); }
            case 1:
                /* Recursive call 3 (1 args) - push frame */
                {
                    JSValue arg0 = POP();
                    frame->sp = sp;
                    frame->instr_offset = 2;  /* Resume at next phase */
                    frame->waiting_for_call = 1;

                    frame_depth++;
                    frames[frame_depth].args[0] = arg0;
                    frames[frame_depth].sp = 0;
                    frames[frame_depth].block_id = 0;
                    frames[frame_depth].instr_offset = 0;
                    frames[frame_depth].waiting_for_call = 0;
                    /* Note: result is uninitialized, will be set when frame returns */
                    for (int i = 0; i < 3; i++) frames[frame_depth].locals[i] = JS_UNDEFINED;

                    goto trampoline_continue;
                }
            case 2:
            /* Resume after recursive call - push child result */
            if (frame->waiting_for_call) {
                stack[sp++] = FROZEN_DUP(ctx, frames[frame_depth + 1].result);
                frame->waiting_for_call = 0;
            }
            { FROZEN_FREE(ctx, POP()); }
            break;
            }
            next_block = 8;
            break;
        case 8:
            switch (frame->instr_offset) {
            case 0:
            PUSH(FROZEN_DUP(ctx, frame->locals[0]));
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = 9;
            break;
        case 9:
            switch (frame->instr_offset) {
            case 0:
            { JSValue exc = POP(); JS_Throw(ctx, exc); next_block = -1; frame->result = JS_EXCEPTION; break; }
            break;
            }
            next_block = 10;
            break;
        case 10:
            switch (frame->instr_offset) {
            }
            next_block = -1;
            break;
        default:
            /* Unknown block - return undefined */
            next_block = -1;
            frame->result = JS_UNDEFINED;
            break;
        }

        /* Update frame state based on execution result */
        frame->sp = sp;

        if (next_block == -1) {
            /* Current frame returned - pop it */
            if (frame_depth == 0) {
                /* Root frame returned - we're done! */
                JSValue result = frame->result;
                js_free(ctx, frames);
                return result;
            }
            /* Return to parent frame */
            frame_depth--;
        } else {
            /* Continue to next block in same frame */
            frame->block_id = next_block;
            frame->instr_offset = 0;
        }
    }

    /* Should never reach here */
    js_free(ctx, frames);
    return JS_UNDEFINED;
}

int frozen_func1234_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1234, "frozen_func1234", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1234", func);
    JS_FreeValue(ctx, global);
    return 0;
}

static JSValue frozen_func1236(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

static JSValue frozen_func1236(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    (void)this_val;
    const int max_stack = 256;
    JSValue stack[256];
    int sp = 0;
    FROZEN_CHECK_STACK(ctx);
    JSValue locals[1];
    for (int i = 0; i < 1; i++) locals[i] = JS_UNDEFINED;
    /* Cached length for array operations (V8-style) */
    int64_t _arg0_len = -1;

block_0:
    /* return_undef */
    FROZEN_EXIT_STACK(); return JS_UNDEFINED;

    FROZEN_EXIT_STACK();
    return JS_UNDEFINED;
}

int frozen_func1236_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_func1236, "frozen_func1236", 0);
    JS_SetPropertyStr(ctx, global, "frozen_func1236", func);
    JS_FreeValue(ctx, global);
    return 0;
}

int frozen_init(JSContext *ctx)
{
    (void)ctx;
    frozen_func0_init(ctx);
    frozen_tick_init(ctx);
    frozen_func5_init(ctx);
    frozen_func7_init(ctx);
    frozen_func19_init(ctx);
    frozen_func21_init(ctx);
    frozen_func22_init(ctx);
    frozen_func23_init(ctx);
    frozen_MockModule_init(ctx);
    frozen_func30_init(ctx);
    frozen_func32_init(ctx);
    frozen_func33_init(ctx);
    frozen_func37_init(ctx);
    frozen_func49_init(ctx);
    frozen_func50_init(ctx);
    frozen_func52_init(ctx);
    frozen_func53_init(ctx);
    frozen_func54_init(ctx);
    frozen_func55_init(ctx);
    frozen_func65_init(ctx);
    frozen_func72_init(ctx);
    frozen_func73_init(ctx);
    frozen_func75_init(ctx);
    frozen_func76_init(ctx);
    frozen_func77_init(ctx);
    frozen_func78_init(ctx);
    frozen_func79_init(ctx);
    frozen_func80_init(ctx);
    frozen_func81_init(ctx);
    frozen_func82_init(ctx);
    frozen_func83_init(ctx);
    frozen_func85_init(ctx);
    frozen_func86_init(ctx);
    frozen_func87_init(ctx);
    frozen_func88_init(ctx);
    frozen_func89_init(ctx);
    frozen_func109_init(ctx);
    frozen_func112_init(ctx);
    frozen_func113_init(ctx);
    frozen_func118_init(ctx);
    frozen_func119_init(ctx);
    frozen_func128_init(ctx);
    frozen_func129_init(ctx);
    frozen_func140_init(ctx);
    frozen_func145_init(ctx);
    frozen_func148_init(ctx);
    frozen_func151_init(ctx);
    frozen_func152_init(ctx);
    frozen_func155_init(ctx);
    frozen_func159_init(ctx);
    frozen_func167_init(ctx);
    frozen_func169_init(ctx);
    frozen_func171_init(ctx);
    frozen_func172_init(ctx);
    frozen_func173_init(ctx);
    frozen_func177_init(ctx);
    frozen_func179_init(ctx);
    frozen_func185_init(ctx);
    frozen_func186_init(ctx);
    frozen_func189_init(ctx);
    frozen_func191_init(ctx);
    frozen_func193_init(ctx);
    frozen_func195_init(ctx);
    frozen_func197_init(ctx);
    frozen_func198_init(ctx);
    frozen_func201_init(ctx);
    frozen_func205_init(ctx);
    frozen_func210_init(ctx);
    frozen_func218_init(ctx);
    frozen_func236_init(ctx);
    frozen_func240_init(ctx);
    frozen_func244_init(ctx);
    frozen_func245_init(ctx);
    frozen_func246_init(ctx);
    frozen_func261_init(ctx);
    frozen_func266_init(ctx);
    frozen_func268_init(ctx);
    frozen_func274_init(ctx);
    frozen_func275_init(ctx);
    frozen_func283_init(ctx);
    frozen_func288_init(ctx);
    frozen_func289_init(ctx);
    frozen_func294_init(ctx);
    frozen_func295_init(ctx);
    frozen_func296_init(ctx);
    frozen_func297_init(ctx);
    frozen_func298_init(ctx);
    frozen_func302_init(ctx);
    frozen_func311_init(ctx);
    frozen_func322_init(ctx);
    frozen_func332_init(ctx);
    frozen_func334_init(ctx);
    frozen_func335_init(ctx);
    frozen_func336_init(ctx);
    frozen_func337_init(ctx);
    frozen_func341_init(ctx);
    frozen_func343_init(ctx);
    frozen_func346_init(ctx);
    frozen_func347_init(ctx);
    frozen_func348_init(ctx);
    frozen_func349_init(ctx);
    frozen_func350_init(ctx);
    frozen_func351_init(ctx);
    frozen_func359_init(ctx);
    frozen_func360_init(ctx);
    frozen_func361_init(ctx);
    frozen_func362_init(ctx);
    frozen_func363_init(ctx);
    frozen_func364_init(ctx);
    frozen_func365_init(ctx);
    frozen_func366_init(ctx);
    frozen_func367_init(ctx);
    frozen_func369_init(ctx);
    frozen_func384_init(ctx);
    frozen_func385_init(ctx);
    frozen_func387_init(ctx);
    frozen_func392_init(ctx);
    frozen_func399_init(ctx);
    frozen_func400_init(ctx);
    frozen_func401_init(ctx);
    frozen_func404_init(ctx);
    frozen_func405_init(ctx);
    frozen_func407_init(ctx);
    frozen_func408_init(ctx);
    frozen_func409_init(ctx);
    frozen_func411_init(ctx);
    frozen_func412_init(ctx);
    frozen_func419_init(ctx);
    frozen_func423_init(ctx);
    frozen_func424_init(ctx);
    frozen_func427_init(ctx);
    frozen_func430_init(ctx);
    frozen_func435_init(ctx);
    frozen_func439_init(ctx);
    frozen_func442_init(ctx);
    frozen_func443_init(ctx);
    frozen_func447_init(ctx);
    frozen_func448_init(ctx);
    frozen_func450_init(ctx);
    frozen_func451_init(ctx);
    frozen_func453_init(ctx);
    frozen_func454_init(ctx);
    frozen_func455_init(ctx);
    frozen_func459_init(ctx);
    frozen_func466_init(ctx);
    frozen_func468_init(ctx);
    frozen_func471_init(ctx);
    frozen_func472_init(ctx);
    frozen_func474_init(ctx);
    frozen_func479_init(ctx);
    frozen_func481_init(ctx);
    frozen_func482_init(ctx);
    frozen_func485_init(ctx);
    frozen_func486_init(ctx);
    frozen_func488_init(ctx);
    frozen_func489_init(ctx);
    frozen_func490_init(ctx);
    frozen_func492_init(ctx);
    frozen_func493_init(ctx);
    frozen_func497_init(ctx);
    frozen_func499_init(ctx);
    frozen_func503_init(ctx);
    frozen_func504_init(ctx);
    frozen_func505_init(ctx);
    frozen_func506_init(ctx);
    frozen_func507_init(ctx);
    frozen_func508_init(ctx);
    frozen_func509_init(ctx);
    frozen_func510_init(ctx);
    frozen_func511_init(ctx);
    frozen_func513_init(ctx);
    frozen_func514_init(ctx);
    frozen_func515_init(ctx);
    frozen_func519_init(ctx);
    frozen_func520_init(ctx);
    frozen_func522_init(ctx);
    frozen_func528_init(ctx);
    frozen_func534_init(ctx);
    frozen_func535_init(ctx);
    frozen_func547_init(ctx);
    frozen_func548_init(ctx);
    frozen_func549_init(ctx);
    frozen_func551_init(ctx);
    frozen_func552_init(ctx);
    frozen_func560_init(ctx);
    frozen_func563_init(ctx);
    frozen_func575_init(ctx);
    frozen_func624_init(ctx);
    frozen_func625_init(ctx);
    frozen_func626_init(ctx);
    frozen_func629_init(ctx);
    frozen_func630_init(ctx);
    frozen_func631_init(ctx);
    frozen_func632_init(ctx);
    frozen_func634_init(ctx);
    frozen_func635_init(ctx);
    frozen_func640_init(ctx);
    frozen_func641_init(ctx);
    frozen_func643_init(ctx);
    frozen_func648_init(ctx);
    frozen_func649_init(ctx);
    frozen_func650_init(ctx);
    frozen_func651_init(ctx);
    frozen_func652_init(ctx);
    frozen_func653_init(ctx);
    frozen_func654_init(ctx);
    frozen_func655_init(ctx);
    frozen_func656_init(ctx);
    frozen_func657_init(ctx);
    frozen_func659_init(ctx);
    frozen_func662_init(ctx);
    frozen_func672_init(ctx);
    frozen_func677_init(ctx);
    frozen_func678_init(ctx);
    frozen_func679_init(ctx);
    frozen_func684_init(ctx);
    frozen_func685_init(ctx);
    frozen_func686_init(ctx);
    frozen_func688_init(ctx);
    frozen_func689_init(ctx);
    frozen_func695_init(ctx);
    frozen_func702_init(ctx);
    frozen_func704_init(ctx);
    frozen_func705_init(ctx);
    frozen_func707_init(ctx);
    frozen_func714_init(ctx);
    frozen_func717_init(ctx);
    frozen_func718_init(ctx);
    frozen_func719_init(ctx);
    frozen_func720_init(ctx);
    frozen_func721_init(ctx);
    frozen_func740_init(ctx);
    frozen_func741_init(ctx);
    frozen_func742_init(ctx);
    frozen_func743_init(ctx);
    frozen_func744_init(ctx);
    frozen_func745_init(ctx);
    frozen_func746_init(ctx);
    frozen_func747_init(ctx);
    frozen_func748_init(ctx);
    frozen_func749_init(ctx);
    frozen_func750_init(ctx);
    frozen_func751_init(ctx);
    frozen_func752_init(ctx);
    frozen_func753_init(ctx);
    frozen_func754_init(ctx);
    frozen_func757_init(ctx);
    frozen_func770_init(ctx);
    frozen_func771_init(ctx);
    frozen_func772_init(ctx);
    frozen_func774_init(ctx);
    frozen_func777_init(ctx);
    frozen_func778_init(ctx);
    frozen_func781_init(ctx);
    frozen_func787_init(ctx);
    frozen_func788_init(ctx);
    frozen_func797_init(ctx);
    frozen_func802_init(ctx);
    frozen_func804_init(ctx);
    frozen_func805_init(ctx);
    frozen_func806_init(ctx);
    frozen_func807_init(ctx);
    frozen_func808_init(ctx);
    frozen_func814_init(ctx);
    frozen_func815_init(ctx);
    frozen_func816_init(ctx);
    frozen_func817_init(ctx);
    frozen_func818_init(ctx);
    frozen_func819_init(ctx);
    frozen_func825_init(ctx);
    frozen_func826_init(ctx);
    frozen_func830_init(ctx);
    frozen_func831_init(ctx);
    frozen_func832_init(ctx);
    frozen_func835_init(ctx);
    frozen_func836_init(ctx);
    frozen_func844_init(ctx);
    frozen_func845_init(ctx);
    frozen_func846_init(ctx);
    frozen_func847_init(ctx);
    frozen_func853_init(ctx);
    frozen_func854_init(ctx);
    frozen_func857_init(ctx);
    frozen_func858_init(ctx);
    frozen_func860_init(ctx);
    frozen_func861_init(ctx);
    frozen_func863_init(ctx);
    frozen_func864_init(ctx);
    frozen_func866_init(ctx);
    frozen_func867_init(ctx);
    frozen_func869_init(ctx);
    frozen_func871_init(ctx);
    frozen_func872_init(ctx);
    frozen_func874_init(ctx);
    frozen_func875_init(ctx);
    frozen_func885_init(ctx);
    frozen_func886_init(ctx);
    frozen_func890_init(ctx);
    frozen_func892_init(ctx);
    frozen_func908_init(ctx);
    frozen_func909_init(ctx);
    frozen_func915_init(ctx);
    frozen_func918_init(ctx);
    frozen_func926_init(ctx);
    frozen_func930_init(ctx);
    frozen_func938_init(ctx);
    frozen_func939_init(ctx);
    frozen_func944_init(ctx);
    frozen_func945_init(ctx);
    frozen_func950_init(ctx);
    frozen_func952_init(ctx);
    frozen_func956_init(ctx);
    frozen_func966_init(ctx);
    frozen_func971_init(ctx);
    frozen_func974_init(ctx);
    frozen_func975_init(ctx);
    frozen_func977_init(ctx);
    frozen_func980_init(ctx);
    frozen_func982_init(ctx);
    frozen_func984_init(ctx);
    frozen_func986_init(ctx);
    frozen_func988_init(ctx);
    frozen_func990_init(ctx);
    frozen_func992_init(ctx);
    frozen_func994_init(ctx);
    frozen_func996_init(ctx);
    frozen_func998_init(ctx);
    frozen_func1000_init(ctx);
    frozen_func1006_init(ctx);
    frozen_func1009_init(ctx);
    frozen_func1015_init(ctx);
    frozen_func1016_init(ctx);
    frozen_func1018_init(ctx);
    frozen_func1028_init(ctx);
    frozen_func1032_init(ctx);
    frozen_func1036_init(ctx);
    frozen_func1037_init(ctx);
    frozen_func1038_init(ctx);
    frozen_func1039_init(ctx);
    frozen_func1040_init(ctx);
    frozen_func1041_init(ctx);
    frozen_func1044_init(ctx);
    frozen_func1046_init(ctx);
    frozen_func1058_init(ctx);
    frozen_func1063_init(ctx);
    frozen_func1068_init(ctx);
    frozen_func1069_init(ctx);
    frozen_func1070_init(ctx);
    frozen_func1071_init(ctx);
    frozen_func1076_init(ctx);
    frozen_func1077_init(ctx);
    frozen_func1078_init(ctx);
    frozen_func1079_init(ctx);
    frozen_func1080_init(ctx);
    frozen_func1082_init(ctx);
    frozen_func1088_init(ctx);
    frozen_func1090_init(ctx);
    frozen_func1095_init(ctx);
    frozen_func1096_init(ctx);
    frozen_func1097_init(ctx);
    frozen_func1108_init(ctx);
    frozen_func1110_init(ctx);
    frozen_func1111_init(ctx);
    frozen_func1116_init(ctx);
    frozen_func1117_init(ctx);
    frozen_func1120_init(ctx);
    frozen_func1121_init(ctx);
    frozen_func1138_init(ctx);
    frozen_func1142_init(ctx);
    frozen_func1143_init(ctx);
    frozen_func1146_init(ctx);
    frozen_func1148_init(ctx);
    frozen_func1150_init(ctx);
    frozen_func1155_init(ctx);
    frozen_func1156_init(ctx);
    frozen_func1157_init(ctx);
    frozen_func1158_init(ctx);
    frozen_func1159_init(ctx);
    frozen_func1160_init(ctx);
    frozen_func1161_init(ctx);
    frozen_func1164_init(ctx);
    frozen_func1166_init(ctx);
    frozen_func1168_init(ctx);
    frozen_func1186_init(ctx);
    frozen_func1192_init(ctx);
    frozen_func1197_init(ctx);
    frozen_func1203_init(ctx);
    frozen_func1207_init(ctx);
    frozen_func1208_init(ctx);
    frozen_func1209_init(ctx);
    frozen_func1234_init(ctx);
    frozen_func1236_init(ctx);
    return 0;
}
