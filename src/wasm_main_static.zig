/// EdgeBox Static WASM Entry Point
/// Executes pre-compiled bytecode from qjsc (embedded at build time)
///
/// Build pipeline:
///   1. qjsc -s -N bundle bundle.js > bundle_compiled.c
///   2. zig build wasm-static (compiles bundle_compiled.c with QuickJS)
///   3. wizer (pre-initializes runtime)
///   4. WAMR AOT compilation
///
/// This eliminates JS parsing entirely - bytecode is loaded directly.
const std = @import("std");
const builtin = @import("builtin");
const quickjs = @import("quickjs_core.zig");
const wasm_fetch = @import("wasm_fetch.zig");
const wasi_tty = @import("wasi_tty.zig");
const wasi_process = @import("wasi_process.zig");
const wizer_mod = @import("wizer_init.zig");

// Native polyfills - zero runtime cost, registered once at init
const path_polyfill = @import("polyfills/path.zig");
const process_polyfill = @import("polyfills/process.zig");
const console_polyfill = @import("polyfills/console.zig");
const buffer_polyfill = @import("polyfills/buffer.zig");
const url_polyfill = @import("polyfills/url.zig");
const querystring_polyfill = @import("polyfills/querystring.zig");
const util_polyfill = @import("polyfills/util.zig");
const encoding_polyfill = @import("polyfills/encoding.zig");
const crypto_polyfill = @import("polyfills/crypto.zig");
const require_polyfill = @import("polyfills/require.zig");
const native_shapes_polyfill = @import("polyfills/native_shapes.zig");
const native_shapes_registry = @import("freeze/native_shapes.zig"); // Zig registry exports

// Force export of native_shapes_registry functions (prevent tree-shaking)
comptime {
    _ = native_shapes_registry.native_registry_init;
    _ = native_shapes_registry.native_node_register;
    _ = native_shapes_registry.native_node_lookup;
}

const math_polyfill = @import("math_polyfill");
const array_polyfill = @import("polyfills/array.zig");
const compression_polyfill = @import("polyfills/compression.zig");

// Compile-time debug flag: disabled for ReleaseFast/ReleaseSmall
const debug_mode = builtin.mode == .Debug or builtin.mode == .ReleaseSafe;

// ============================================================================
// External bytecode from bundle_compiled.c (generated by qjsc)
// ============================================================================

// Import C symbols from bundle_compiled.c
// The C file declares: const uint32_t bundle_size; const uint8_t bundle[];
extern fn get_bundle_ptr() callconv(.c) [*]const u8;
extern fn get_bundle_size() callconv(.c) u32;

// Import frozen_module (generated Zig frozen functions)
// This hot-swaps slow interpreted JS functions with optimized native Zig functions
// No C fallback needed - Zig codegen handles everything
const frozen_module = @import("frozen_module");

// Wrapper for frozen_init
fn frozen_init(ctx: *qjs.JSContext) c_int {
    // Cast between opaque JSContext types (both represent same C struct)
    return frozen_module.frozen_init_c(@ptrCast(ctx));
}

// ============================================================================
// Host Bridge Dispatch Functions (6 imports instead of 50)
// ============================================================================

// Single dispatch function per module - reduces WASM link time
extern "edgebox_http" fn http_dispatch(opcode: u32, a1: u32, a2: u32, a3: u32, a4: u32, a5: u32, a6: u32, a7: u32, a8: u32) i32;
extern "edgebox_spawn" fn spawn_dispatch(opcode: u32, a1: u32, a2: u32, a3: u32, a4: u32) i32;
extern "edgebox_file" fn file_dispatch(opcode: u32, a1: u32, a2: u32, a3: u32, a4: u32) i32;
extern "edgebox_zlib" fn zlib_dispatch(opcode: u32, a1: u32, a2: u32) i32;
extern "edgebox_crypto" fn crypto_dispatch(opcode: u32, a1: u32, a2: u32, a3: u32, a4: u32, a5: u32, a6: u32) i32;
extern "edgebox_socket" fn socket_dispatch(opcode: u32, a1: u32, a2: u32, a3: u32) i32;
extern "edgebox_stdlib" fn stdlib_dispatch(opcode: u32, a1: u32, a2: u32, a3: u32, a4: u32) i32;
extern "edgebox_wasm_component" fn wasm_component_load(path_offset: u32, path_len: u32) i32;
extern "edgebox_wasm_component" fn wasm_component_export_count(component_id: i32) i32;
extern "edgebox_wasm_component" fn wasm_component_export_name(component_id: i32, index: i32, name_buf_offset: u32, name_buf_len: u32) i32;
extern "edgebox_wasm_component" fn wasm_component_call(component_id: i32, func_name_offset: u32, func_name_len: u32, args_offset: u32, args_count: u32) i32;
extern "edgebox_gpu" fn gpu_dispatch(opcode: u32, a1: u32, a2: u32, a3: u32, a4: u32, result_ptr: u32, result_len: u32) i32;

// HTTP opcodes
const HTTP_OP_REQUEST: u32 = 0;
const HTTP_OP_GET_RESPONSE_LEN: u32 = 1;
const HTTP_OP_GET_RESPONSE: u32 = 2;
const HTTP_OP_START_ASYNC: u32 = 3;
const HTTP_OP_POLL: u32 = 4;
const HTTP_OP_RESPONSE_LEN: u32 = 5;
const HTTP_OP_RESPONSE: u32 = 6;
const HTTP_OP_FREE: u32 = 7;

// Spawn opcodes
const SPAWN_OP_START: u32 = 0;
const SPAWN_OP_POLL: u32 = 1;
const SPAWN_OP_OUTPUT_LEN: u32 = 2;
const SPAWN_OP_OUTPUT: u32 = 3;
const SPAWN_OP_FREE: u32 = 4;

// File opcodes
const FILE_OP_READ_START: u32 = 0;
const FILE_OP_WRITE_START: u32 = 1;
const FILE_OP_POLL: u32 = 2;
const FILE_OP_RESULT_LEN: u32 = 3;
const FILE_OP_RESULT: u32 = 4;
const FILE_OP_FREE: u32 = 5;

// Zlib opcodes
const ZLIB_OP_GZIP: u32 = 0;
const ZLIB_OP_GUNZIP: u32 = 1;
const ZLIB_OP_DEFLATE: u32 = 2;
const ZLIB_OP_INFLATE: u32 = 3;
const ZLIB_OP_GET_RESULT: u32 = 4;

// Crypto opcodes
const CRYPTO_OP_AES_GCM_ENCRYPT: u32 = 0;
const CRYPTO_OP_AES_GCM_DECRYPT: u32 = 1;
const CRYPTO_OP_GET_RESULT: u32 = 2;
const CRYPTO_OP_RANDOM_BYTES: u32 = 3;

// Socket opcodes
const SOCKET_OP_CREATE: u32 = 0;
const SOCKET_OP_BIND: u32 = 1;
const SOCKET_OP_LISTEN: u32 = 2;
const SOCKET_OP_ACCEPT: u32 = 3;
const SOCKET_OP_CONNECT: u32 = 4;
const SOCKET_OP_WRITE: u32 = 5;
const SOCKET_OP_READ: u32 = 6;
const SOCKET_OP_GET_READ_DATA: u32 = 7;
const SOCKET_OP_CLOSE: u32 = 8;
const SOCKET_OP_STATE: u32 = 9;

// GPU opcodes
const GPU_OP_IS_AVAILABLE: u32 = 0;
const GPU_OP_GET_ERROR: u32 = 1;
const GPU_OP_REQUEST_ADAPTER: u32 = 10;
const GPU_OP_REQUEST_DEVICE: u32 = 11;
const GPU_OP_CREATE_BUFFER: u32 = 20;
const GPU_OP_DESTROY_BUFFER: u32 = 21;
const GPU_OP_WRITE_BUFFER: u32 = 22;
const GPU_OP_READ_BUFFER: u32 = 23;
const GPU_OP_CREATE_SHADER_MODULE: u32 = 30;
const GPU_OP_DESTROY_SHADER_MODULE: u32 = 31;
const GPU_OP_CREATE_COMPUTE_PIPELINE: u32 = 40;
const GPU_OP_CREATE_BIND_GROUP: u32 = 41;
const GPU_OP_DISPATCH_WORKGROUPS: u32 = 50;
const GPU_OP_QUEUE_SUBMIT: u32 = 51;

// Stdlib opcodes (Array: 0-9, Map: 10-19)
const STDLIB_OP_ARRAY_NEW: u32 = 0;
const STDLIB_OP_ARRAY_PUSH: u32 = 1;
const STDLIB_OP_ARRAY_POP: u32 = 2;
const STDLIB_OP_ARRAY_GET: u32 = 3;
const STDLIB_OP_ARRAY_SET: u32 = 4;
const STDLIB_OP_ARRAY_LEN: u32 = 5;
const STDLIB_OP_ARRAY_SORT: u32 = 6;
const STDLIB_OP_ARRAY_FREE: u32 = 7;
const STDLIB_OP_ARRAY_SORT_DESC: u32 = 8;
const STDLIB_OP_ARRAY_REVERSE: u32 = 9;
const STDLIB_OP_MAP_NEW: u32 = 10;
const STDLIB_OP_MAP_SET: u32 = 11;
const STDLIB_OP_MAP_GET: u32 = 12;
const STDLIB_OP_MAP_HAS: u32 = 13;
const STDLIB_OP_MAP_DELETE: u32 = 14;
const STDLIB_OP_MAP_LEN: u32 = 15;
const STDLIB_OP_MAP_FREE: u32 = 16;
const STDLIB_OP_MAP_CLEAR: u32 = 17;
const STDLIB_OP_ARRAY_CLEAR: u32 = 18;
const STDLIB_OP_ARRAY_INDEX_OF: u32 = 19;

// ============================================================================
// Wrapper functions that call dispatch (maintain existing API)
// ============================================================================

// HTTP wrappers
fn request(url_ptr: [*]const u8, url_len: u32, method_ptr: [*]const u8, method_len: u32, headers_ptr: [*]const u8, headers_len: u32, body_ptr: [*]const u8, body_len: u32) i32 {
    return http_dispatch(HTTP_OP_REQUEST, @intFromPtr(url_ptr), url_len, @intFromPtr(method_ptr), method_len, @intFromPtr(headers_ptr), headers_len, @intFromPtr(body_ptr), body_len);
}
fn get_response_len() i32 {
    return http_dispatch(HTTP_OP_GET_RESPONSE_LEN, 0, 0, 0, 0, 0, 0, 0, 0);
}
fn get_response(dest_ptr: [*]u8) i32 {
    return http_dispatch(HTTP_OP_GET_RESPONSE, @intFromPtr(dest_ptr), 0, 0, 0, 0, 0, 0, 0);
}
fn start_async(url_ptr: [*]const u8, url_len: u32, method_ptr: [*]const u8, method_len: u32, headers_ptr: [*]const u8, headers_len: u32, body_ptr: [*]const u8, body_len: u32) i32 {
    return http_dispatch(HTTP_OP_START_ASYNC, @intFromPtr(url_ptr), url_len, @intFromPtr(method_ptr), method_len, @intFromPtr(headers_ptr), headers_len, @intFromPtr(body_ptr), body_len);
}
fn http_poll(request_id: u32) i32 {
    return http_dispatch(HTTP_OP_POLL, request_id, 0, 0, 0, 0, 0, 0, 0);
}
fn http_response_len(request_id: u32) i32 {
    return http_dispatch(HTTP_OP_RESPONSE_LEN, request_id, 0, 0, 0, 0, 0, 0, 0);
}
fn http_response(request_id: u32, dest_ptr: [*]u8) i32 {
    return http_dispatch(HTTP_OP_RESPONSE, request_id, @intFromPtr(dest_ptr), 0, 0, 0, 0, 0, 0);
}
fn http_free(request_id: u32) i32 {
    return http_dispatch(HTTP_OP_FREE, request_id, 0, 0, 0, 0, 0, 0, 0);
}

// Spawn wrappers
fn spawn_start(cmd_ptr: [*]const u8, cmd_len: u32, args_ptr: [*]const u8, args_len: u32) i32 {
    return spawn_dispatch(SPAWN_OP_START, @intFromPtr(cmd_ptr), cmd_len, @intFromPtr(args_ptr), args_len);
}
fn spawn_poll(spawn_id: u32) i32 {
    return spawn_dispatch(SPAWN_OP_POLL, spawn_id, 0, 0, 0);
}
fn spawn_output_len(spawn_id: u32) i32 {
    return spawn_dispatch(SPAWN_OP_OUTPUT_LEN, spawn_id, 0, 0, 0);
}
fn spawn_output(spawn_id: u32, dest_ptr: [*]u8) i32 {
    return spawn_dispatch(SPAWN_OP_OUTPUT, spawn_id, @intFromPtr(dest_ptr), 0, 0);
}
fn spawn_free(spawn_id: u32) i32 {
    return spawn_dispatch(SPAWN_OP_FREE, spawn_id, 0, 0, 0);
}

// File wrappers
fn file_read_start(path_ptr: [*]const u8, path_len: u32) i32 {
    return file_dispatch(FILE_OP_READ_START, @intFromPtr(path_ptr), path_len, 0, 0);
}
fn file_write_start(path_ptr: [*]const u8, path_len: u32, data_ptr: [*]const u8, data_len: u32) i32 {
    return file_dispatch(FILE_OP_WRITE_START, @intFromPtr(path_ptr), path_len, @intFromPtr(data_ptr), data_len);
}
fn file_poll(request_id: u32) i32 {
    return file_dispatch(FILE_OP_POLL, request_id, 0, 0, 0);
}
fn file_result_len(request_id: u32) i32 {
    return file_dispatch(FILE_OP_RESULT_LEN, request_id, 0, 0, 0);
}
fn file_result(request_id: u32, dest_ptr: [*]u8) i32 {
    return file_dispatch(FILE_OP_RESULT, request_id, @intFromPtr(dest_ptr), 0, 0);
}
fn file_free(request_id: u32) i32 {
    return file_dispatch(FILE_OP_FREE, request_id, 0, 0, 0);
}

// Zlib wrappers
fn gzip(data_ptr: [*]const u8, data_len: u32) i32 {
    return zlib_dispatch(ZLIB_OP_GZIP, @intFromPtr(data_ptr), data_len);
}
fn gunzip(data_ptr: [*]const u8, data_len: u32) i32 {
    return zlib_dispatch(ZLIB_OP_GUNZIP, @intFromPtr(data_ptr), data_len);
}
fn deflate(data_ptr: [*]const u8, data_len: u32) i32 {
    return zlib_dispatch(ZLIB_OP_DEFLATE, @intFromPtr(data_ptr), data_len);
}
fn inflate(data_ptr: [*]const u8, data_len: u32) i32 {
    return zlib_dispatch(ZLIB_OP_INFLATE, @intFromPtr(data_ptr), data_len);
}
fn zlib_get_result(dest_ptr: [*]u8) i32 {
    return zlib_dispatch(ZLIB_OP_GET_RESULT, @intFromPtr(dest_ptr), 0);
}

// Crypto wrappers
fn aes_gcm_encrypt(key_ptr: [*]const u8, key_len: u32, iv_ptr: [*]const u8, iv_len: u32, data_ptr: [*]const u8, data_len: u32) i32 {
    return crypto_dispatch(CRYPTO_OP_AES_GCM_ENCRYPT, @intFromPtr(key_ptr), key_len, @intFromPtr(iv_ptr), iv_len, @intFromPtr(data_ptr), data_len);
}
fn aes_gcm_decrypt(key_ptr: [*]const u8, key_len: u32, iv_ptr: [*]const u8, iv_len: u32, data_ptr: [*]const u8, data_len: u32) i32 {
    return crypto_dispatch(CRYPTO_OP_AES_GCM_DECRYPT, @intFromPtr(key_ptr), key_len, @intFromPtr(iv_ptr), iv_len, @intFromPtr(data_ptr), data_len);
}
fn crypto_get_result(dest_ptr: [*]u8) i32 {
    return crypto_dispatch(CRYPTO_OP_GET_RESULT, @intFromPtr(dest_ptr), 0, 0, 0, 0, 0);
}
fn random_bytes(dest_ptr: [*]u8, size: u32) i32 {
    return crypto_dispatch(CRYPTO_OP_RANDOM_BYTES, @intFromPtr(dest_ptr), size, 0, 0, 0, 0);
}

// Socket wrappers
fn socket_create() i32 {
    return socket_dispatch(SOCKET_OP_CREATE, 0, 0, 0);
}
fn socket_bind(socket_id: u32, port: u32) i32 {
    return socket_dispatch(SOCKET_OP_BIND, socket_id, port, 0);
}
fn socket_listen(socket_id: u32, backlog: u32) i32 {
    return socket_dispatch(SOCKET_OP_LISTEN, socket_id, backlog, 0);
}
fn socket_accept(socket_id: u32) i32 {
    return socket_dispatch(SOCKET_OP_ACCEPT, socket_id, 0, 0);
}
fn socket_connect(socket_id: u32, port: u32) i32 {
    return socket_dispatch(SOCKET_OP_CONNECT, socket_id, port, 0);
}
fn socket_write(socket_id: u32, data_ptr: [*]const u8, data_len: u32) i32 {
    return socket_dispatch(SOCKET_OP_WRITE, socket_id, @intFromPtr(data_ptr), data_len);
}
fn socket_read(socket_id: u32, max_len: u32) i32 {
    return socket_dispatch(SOCKET_OP_READ, socket_id, max_len, 0);
}
fn socket_get_read_data(socket_id: u32, dest_ptr: [*]u8) i32 {
    return socket_dispatch(SOCKET_OP_GET_READ_DATA, socket_id, @intFromPtr(dest_ptr), 0);
}
fn socket_close(socket_id: u32) i32 {
    return socket_dispatch(SOCKET_OP_CLOSE, socket_id, 0, 0);
}
fn socket_state(socket_id: u32) i32 {
    return socket_dispatch(SOCKET_OP_STATE, socket_id, 0, 0);
}

// ============================================================================
// WASM Component Loader (called from frozen_runtime.c)
// ============================================================================

/// Load a WASM component and return JS namespace object with callable exports
/// Called when: import("./math.wasm")
export fn __edgebox_load_wasm_component(ctx: ?*qjs.JSContext, path_ptr: [*c]const u8, path_len: usize) qjs.JSValue {
    // Load WASM component via host function
    const component_id = wasm_component_load(@intFromPtr(path_ptr), @intCast(path_len));
    if (component_id == 0) {
        return qjs.JS_ThrowInternalError(ctx, "Failed to load WASM component");
    }

    // Get export count
    const export_count = wasm_component_export_count(component_id);
    if (export_count == 0) {
        return qjs.JS_ThrowInternalError(ctx, "WASM component has no exports");
    }

    // Create JS namespace object
    const namespace = qjs.JS_NewObject(ctx);

    // Store component_id on the namespace object for later calls
    _ = qjs.JS_DefinePropertyValueStr(ctx, namespace, "__component_id", qjs.JS_NewInt32(ctx, component_id), qjs.JS_PROP_CONFIGURABLE);

    // Enumerate exports and add callable properties
    var i: i32 = 0;
    while (i < export_count) : (i += 1) {
        var name_buf: [256]u8 = undefined;
        const name_len = wasm_component_export_name(
            component_id,
            i,
            @intFromPtr(&name_buf),
            name_buf.len,
        );

        if (name_len > 0 and name_len <= name_buf.len) {
            const export_name = name_buf[0..@as(usize, @intCast(name_len))];

            // Create a wrapper function for this export
            // Use JS_NewCFunctionData to pass component_id and export name
            var data_vals: [2]qjs.JSValue = undefined;
            data_vals[0] = qjs.JS_NewInt32(ctx, component_id); // component_id
            data_vals[1] = qjs.JS_NewString(ctx, export_name.ptr); // export_name

            const wrapper = qjs.JS_NewCFunctionData(
                ctx,
                wasmComponentCallWrapper,
                @intCast(export_name.len),
                0, // Variadic args
                2, // data_len
                &data_vals,
            );

            // Add to namespace
            _ = qjs.JS_DefinePropertyValueStr(ctx, namespace, export_name.ptr, wrapper, qjs.JS_PROP_WRITABLE | qjs.JS_PROP_CONFIGURABLE | qjs.JS_PROP_ENUMERABLE);
        }
    }

    return namespace;
}

/// Wrapper function for WASM component export calls
/// This is called when JS invokes: math.add(5, 3)
fn wasmComponentCallWrapper(ctx: ?*qjs.JSContext, this_val: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue, magic: c_int, data: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    _ = this_val;
    _ = magic;

    // Get component_id and export name from closure data
    if (data == null) {
        return qjs.JS_ThrowInternalError(ctx, "Missing closure data");
    }

    var component_id: i32 = 0;
    _ = qjs.JS_ToInt32(ctx, &component_id, data[0]);

    if (component_id == 0) {
        return qjs.JS_ThrowInternalError(ctx, "Invalid component ID");
    }

    const export_name_cstr = qjs.JS_ToCString(ctx, data[1]);
    if (export_name_cstr == null) {
        return qjs.JS_ThrowInternalError(ctx, "Failed to get export name");
    }
    defer qjs.JS_FreeCString(ctx, export_name_cstr);

    // Convert JS arguments to i32 array
    var args: [16]i32 = undefined;
    const arg_count = @min(@as(usize, @intCast(argc)), 16);

    var i: usize = 0;
    while (i < arg_count) : (i += 1) {
        var val: i32 = 0;
        _ = qjs.JS_ToInt32(ctx, &val, argv[i]);
        args[i] = val;
    }

    // Call WASM component export via host function
    const result = wasm_component_call(
        component_id,
        @intFromPtr(export_name_cstr),
        @intCast(std.mem.len(export_name_cstr)),
        @intFromPtr(&args),
        @intCast(arg_count),
    );

    return qjs.JS_NewInt32(ctx, result);
}

// We need to provide these C bridge functions since Zig can't directly import C arrays
// They'll be added to bundle_compiled.c by the build process

// ============================================================================
// Wizer Pre-initialization Export
// ============================================================================

export fn wizer_init() void {
    wizer_mod.wizer_init();
}

// ============================================================================
// Main Entry Point
// ============================================================================

// Global allocator for native bindings
var global_allocator: ?std.mem.Allocator = null;

// Startup timing for cold start measurement
var startup_time_ns: i128 = 0;

/// Get current time in nanoseconds (WASI clock)
fn getTimeNs() i128 {
    if (@import("builtin").target.os.tag == .wasi) {
        var ts: u64 = undefined;
        const rc = std.os.wasi.clock_time_get(.MONOTONIC, 1, &ts);
        if (rc == .SUCCESS) {
            return @as(i128, ts);
        }
    }
    return std.time.nanoTimestamp();
}

// Debug flag - check for EDGEBOX_DEBUG env var
var debug_enabled: bool = false;

// ============================================================================
// Serve Mode Globals
// ============================================================================
// When EDGEBOX_SERVE_MODE=1 is set (during template init), we initialize the
// runtime and load bytecode but DON'T evaluate it. The bytecode function and
// context are stored here for later execution via _edgebox_run().
var g_serve_mode: bool = false;
var g_serve_ctx: ?*qjs.JSContext = null;
var g_serve_bytecode: qjs.JSValue = qjs.JS_UNDEFINED;
var g_serve_runtime: ?*qjs.JSRuntime = null;

fn rawPrint(msg: []const u8) void {
    // Use WASI fd_write directly - std.posix.write doesn't work in WASI
    var nwritten: usize = 0;
    const iov = [_]std.os.wasi.ciovec_t{.{ .base = msg.ptr, .len = msg.len }};
    _ = std.os.wasi.fd_write(1, &iov, 1, &nwritten);
}

fn debugPrint(comptime fmt: []const u8, args: anytype) void {
    if (debug_mode or debug_enabled) {
        std.debug.print("[EDGEBOX DEBUG] " ++ fmt, args);
    }
}

// Conditional print for internal logging (disabled in ReleaseFast)
inline fn logPrint(comptime fmt: []const u8, args: anytype) void {
    if (debug_mode) {
        std.debug.print(fmt, args);
    }
}

pub fn main() !void {
    startup_time_ns = getTimeNs();
    // Debug message only in debug builds (removed rawPrint for benchmarks)

    // Check debug mode early via WASI environ
    if (@import("builtin").target.os.tag == .wasi) {
        var environ_count: usize = 0;
        var environ_buf_size: usize = 0;
        _ = std.os.wasi.environ_sizes_get(&environ_count, &environ_buf_size);
        // For simplicity, we'll enable debug if any arg is --debug
    }

    // Use page_allocator for WASM - GPA's invalid free detection causes issues
    // with large JS bundles that may have quirky memory patterns in QuickJS
    const allocator = std.heap.page_allocator;
    global_allocator = allocator;

    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    // Check for debug via env or args
    if (std.posix.getenv("EDGEBOX_DEBUG")) |_| {
        debug_enabled = true;
    }

    // Check for debug and benchmark/cold-start flags
    for (args) |arg| {
        if (std.mem.eql(u8, arg, "--debug")) {
            debug_enabled = true;
        }
        if (std.mem.eql(u8, arg, "--cold-start") or std.mem.eql(u8, arg, "--benchmark")) {
            const end_time = getTimeNs();
            const startup_ms = @as(f64, @floatFromInt(end_time - startup_time_ns)) / 1_000_000.0;
            const wizer_status = if (wizer_mod.isWizerInitialized()) " (Wizer+Static)" else " (Static)";
            std.debug.print("Cold start{s}: {d:.2}ms\n", .{ wizer_status, startup_ms });
            if (std.mem.eql(u8, arg, "--cold-start")) return;
            break;
        }
    }

    // SERVE MODE CHECK: Initialize runtime but don't evaluate bytecode
    // This is used by the daemon during template init to create a CoW snapshot
    // of the initialized runtime state, which can then be restored for fast execution.
    const serve_mode_env = std.posix.getenv("EDGEBOX_SERVE_MODE");
    if (serve_mode_env) |_| {
        try initServeMode(allocator, args);
        logPrint("[MAIN] SERVE MODE - runtime initialized, returning\n", .{});
        return; // Don't evaluate bytecode - wait for _edgebox_run
    }

    // WIZER FAST PATH: DISABLED
    // WAMR reapplies the data section during instantiation, which resets all global
    // variables including wizer_context/wizer_runtime pointers. These pointers become
    // stale (pointing to Wizer-build-time addresses), causing frozen_init_c() to fail
    // silently when it tries to register functions on an invalid context.
    // The slow path correctly creates a fresh QuickJS runtime each time.
    _ = wizer_mod.isWizerInitialized(); // suppress unused warning

    // Initialize QuickJS runtime and run bytecode
    var runtime = try quickjs.Runtime.init(allocator);
    defer runtime.deinit();

    // Set larger QuickJS stack limit for deep promise chains (default is only 1MB)
    qjs.JS_SetMaxStackSize(runtime.inner, 64 * 1024 * 1024); // 64MB

    // Set high GC threshold to prevent premature garbage collection of closures
    // The default is 256KB which triggers GC very frequently with large bundles
    // Setting to 512MB should effectively disable GC during normal operation
    qjs.JS_SetGCThreshold(runtime.inner, 512 * 1024 * 1024); // 512MB

    qjs.js_std_init_handlers(runtime.inner);
    qjs.JS_SetHostPromiseRejectionTracker(runtime.inner, silentPromiseRejectionTracker, null);

    var c_argv = try allocator.alloc([*c]u8, args.len);
    defer allocator.free(c_argv);
    for (args, 0..) |arg, i| {
        c_argv[i] = @constCast(@ptrCast(arg.ptr));
    }

    var context = try runtime.newStdContextWithArgs(@intCast(c_argv.len), c_argv.ptr);
    defer context.deinit();

    const ctx = context.inner;

    // NOTE: Using QuickJS's builtin print from js_std_add_helpers
    // Our printNative wasn't being called - testing if QuickJS print works
    // const global = qjs.JS_GetGlobalObject(ctx);
    // const print_func = qjs.JS_NewCFunction(ctx, printNative, "print", 1);
    // _ = qjs.JS_SetPropertyStr(ctx, global, "print", print_func);
    // _ = qjs.JS_SetPropertyStr(ctx, global, "_edgebox_print", print_func);
    // qjs.JS_FreeValue(ctx, global);

    registerWizerNativeBindings(ctx);

    // Register native require FIRST - JS polyfill will check and skip if present
    require_polyfill.register(ctx);

    // Register native polyfills (zero runtime cost)
    path_polyfill.register(ctx);
    process_polyfill.register(ctx);
    console_polyfill.register(ctx);
    buffer_polyfill.register(ctx); // Registers _modules._nativeBuffer (doesn't override globalThis.Buffer)
    url_polyfill.register(ctx);
    querystring_polyfill.register(ctx);
    util_polyfill.register(ctx);
    encoding_polyfill.register(ctx);
    crypto_polyfill.register(ctx);
    native_shapes_polyfill.register(ctx); // Register native shapes for AST node optimization
    math_polyfill.register(ctx); // Native Math with NaN-boxing support for WASM32
    array_polyfill.register(ctx); // Native Array methods (forEach, map, filter, etc.)
    compression_polyfill.register(ctx);

    // Import std/os modules to make _os.setTimeout available
    // This now works because JS_SetModuleLoaderFunc is called in newStdContextWithArgs
    importStdModules(&context) catch {
        // Continue anyway - polyfills have fallback implementations
    };

    try executeBytecode(&context);
}

// ============================================================================
// Wizer Fast Path
// ============================================================================

const qjs = quickjs.c;

fn runWithWizerRuntime(args: []const [:0]u8) !void {
    const ctx = wizer_mod.getContext() orelse return error.WizerNotInitialized;

    // Initialize std handlers for event loop
    const rt = qjs.JS_GetRuntime(ctx);
    qjs.js_std_init_handlers(rt);
    qjs.JS_SetHostPromiseRejectionTracker(rt, silentPromiseRejectionTracker, null);

    // Re-set module loader (Wizer snapshot may have stale function pointers)
    qjs.JS_SetModuleLoaderFunc(rt, null, qjs.js_module_loader, null);

    // CRITICAL: Initialize std/os modules to set can_js_os_poll = true
    // Without this, the event loop exits immediately without waiting for timers
    _ = qjs.js_init_module_std(ctx, "std");
    _ = qjs.js_init_module_os(ctx, "os");

    // Set high GC threshold to prevent premature garbage collection of closures
    qjs.JS_SetGCThreshold(rt, 512 * 1024 * 1024); // 512MB

    // Set scriptArgs for process.argv
    const global = qjs.JS_GetGlobalObject(ctx);
    defer qjs.JS_FreeValue(ctx, global);

    const script_args = qjs.JS_NewArray(ctx);
    var idx: u32 = 0;
    for (args) |arg| {
        const str = qjs.JS_NewStringLen(ctx, arg.ptr, arg.len);
        _ = qjs.JS_SetPropertyUint32(ctx, script_args, idx, str);
        idx += 1;
    }
    _ = qjs.JS_SetPropertyStr(ctx, global, "scriptArgs", script_args);

    // Register print function
    const print_func = qjs.JS_NewCFunction(ctx, printNative, "print", 1);
    _ = qjs.JS_SetPropertyStr(ctx, global, "print", print_func);

    // Rebind console to use new print (wizer print is stale)
    const console_init =
        \\globalThis.console = globalThis.console || {};
        \\globalThis.console.log = function() { print.apply(null, arguments); };
        \\globalThis.console.error = function() { print.apply(null, ['[ERROR]'].concat(Array.prototype.slice.call(arguments))); };
        \\globalThis.console.warn = function() { print.apply(null, ['[WARN]'].concat(Array.prototype.slice.call(arguments))); };
        \\globalThis.console.info = function() { print.apply(null, arguments); };
        \\globalThis.console.debug = function() { print.apply(null, arguments); };
        \\globalThis.console.trace = function() { print.apply(null, arguments); try { throw new Error(); } catch(e) { print(e.stack); } };
        \\globalThis.console.dir = function(obj) { print(JSON.stringify(obj, null, 2)); };
        \\globalThis.console.time = globalThis.console.time || function() {};
        \\globalThis.console.timeEnd = globalThis.console.timeEnd || function() {};
        \\globalThis.console.assert = function(cond, msg) { if (!cond) print('[ASSERT]', msg || 'Assertion failed'); };
    ;
    const console_result = qjs.JS_Eval(ctx, console_init.ptr, console_init.len, "<console>", qjs.JS_EVAL_TYPE_GLOBAL);
    qjs.JS_FreeValue(ctx, console_result);

    // Register native bindings and init polyfills
    registerWizerNativeBindings(ctx);

    // Register native require FIRST - JS polyfill will check and skip if present
    require_polyfill.register(ctx);

    // Register native polyfills (zero runtime cost)
    path_polyfill.register(ctx);
    process_polyfill.register(ctx);
    console_polyfill.register(ctx);
    buffer_polyfill.register(ctx); // Registers _modules._nativeBuffer (doesn't override globalThis.Buffer)
    url_polyfill.register(ctx);
    querystring_polyfill.register(ctx);
    util_polyfill.register(ctx);
    encoding_polyfill.register(ctx);
    crypto_polyfill.register(ctx);
    native_shapes_polyfill.register(ctx); // Register native shapes for AST node optimization
    math_polyfill.register(ctx); // Native Math with NaN-boxing support for WASM32
    array_polyfill.register(ctx); // Native Array methods (forEach, map, filter, etc.)
    compression_polyfill.register(ctx);

    importWizerStdModules(ctx);
    initWizerPolyfills(ctx);

    // Execute bytecode
    try executeBytecodeRaw(ctx);
}

// ============================================================================
// Serve Mode Functions
// ============================================================================
// These functions support the daemon's CoW optimization. During template init,
// initServeMode() sets up the QuickJS runtime and loads bytecode without
// evaluating it. The runtime state is then captured in a CoW snapshot.
// On each request, _edgebox_run() is called on the restored instance to
// actually evaluate the bytecode and run the user's code.

/// Initialize serve mode: set up runtime and load bytecode without evaluation
fn initServeMode(allocator: std.mem.Allocator, args: []const [:0]u8) !void {
    logPrint("[SERVE] Initializing QuickJS runtime\n", .{});

    // Create QuickJS runtime (stored globally for later use)
    const rt = qjs.JS_NewRuntime() orelse return error.RuntimeCreationFailed;
    g_serve_runtime = rt;

    // Set large stack limit for deep promise chains
    qjs.JS_SetMaxStackSize(rt, 64 * 1024 * 1024); // 64MB

    // Set high GC threshold to prevent premature garbage collection
    qjs.JS_SetGCThreshold(rt, 512 * 1024 * 1024); // 512MB

    // Initialize std handlers
    qjs.js_std_init_handlers(rt);
    qjs.JS_SetHostPromiseRejectionTracker(rt, silentPromiseRejectionTracker, null);

    // Create context
    const ctx = qjs.JS_NewContext(rt) orelse return error.ContextCreationFailed;
    g_serve_ctx = ctx;

    // Add std/os modules
    qjs.JS_SetModuleLoaderFunc(rt, null, qjs.js_module_loader, null);
    _ = qjs.js_init_module_std(ctx, "std");
    _ = qjs.js_init_module_os(ctx, "os");

    // Set up scriptArgs
    var c_argv = try allocator.alloc([*c]u8, args.len);
    defer allocator.free(c_argv);
    for (args, 0..) |arg, i| {
        c_argv[i] = @constCast(@ptrCast(arg.ptr));
    }
    qjs.js_std_set_worker_new_context_func(null);
    qjs.js_std_add_helpers(ctx, @intCast(c_argv.len), c_argv.ptr);

    logPrint("[SERVE] Registering native bindings\n", .{});

    // Register print function
    const global = qjs.JS_GetGlobalObject(ctx);
    const print_func = qjs.JS_NewCFunction(ctx, printNative, "print", 1);
    _ = qjs.JS_SetPropertyStr(ctx, global, "print", print_func);
    qjs.JS_FreeValue(ctx, global);

    // Register Wizer-style native bindings
    registerWizerNativeBindings(ctx);

    // Register native polyfills
    require_polyfill.register(ctx);
    path_polyfill.register(ctx);
    process_polyfill.register(ctx);
    console_polyfill.register(ctx);
    buffer_polyfill.register(ctx); // Registers _modules._nativeBuffer (doesn't override globalThis.Buffer)
    url_polyfill.register(ctx);
    querystring_polyfill.register(ctx);
    util_polyfill.register(ctx);
    encoding_polyfill.register(ctx);
    crypto_polyfill.register(ctx);
    native_shapes_polyfill.register(ctx); // Register native shapes for AST node optimization

    // Import std/os modules for event loop support
    importWizerStdModules(ctx);
    // NOTE: Do NOT call initWizerPolyfills here - it depends on _modules['fs']
    // which is created by the bytecode bundle. We'll call it after bytecode eval.

    logPrint("[SERVE] Loading bytecode (without evaluation)\n", .{});

    // Load bytecode object but DON'T evaluate it
    const bytecode_ptr = get_bundle_ptr();
    const bytecode_len = get_bundle_size();
    logPrint("[SERVE] Bytecode size: {d} bytes\n", .{bytecode_len});

    const func = qjs.JS_ReadObject(ctx, bytecode_ptr, bytecode_len, qjs.JS_READ_OBJ_BYTECODE);
    if (qjs.JS_IsException(func)) {
        std.debug.print("[SERVE] Failed to load bytecode\n", .{});
        return error.BytecodeLoadFailed;
    }

    // Store bytecode function for later execution
    g_serve_bytecode = func;
    g_serve_mode = true;

    // Register frozen functions (they'll be used when bytecode is evaluated)
    // NOTE: Must use the result to prevent optimizer from removing this call
    const frozen_count = frozen_init(ctx);
    if (frozen_count < 0) {
        std.debug.print("[SERVE] frozen_init_c failed\n", .{});
    }

    // Set __frozen_init_complete so hook injection redirects to frozen functions
    {
        const g = qjs.JS_GetGlobalObject(ctx);
        defer qjs.JS_FreeValue(ctx, g);
        _ = qjs.JS_SetPropertyStr(ctx, g, "__frozen_init_complete", quickjs.jsTrue());
    }

    logPrint("[SERVE] Serve mode initialized successfully\n", .{});
}

/// Execute bytecode in serve mode - called by _edgebox_run export
fn runServeModeBytecode() !void {
    const ctx = g_serve_ctx orelse return error.ServeContextNotInitialized;

    logPrint("[RUN] Evaluating stored bytecode\n", .{});

    // Evaluate the stored bytecode
    const result = qjs.JS_EvalFunction(ctx, g_serve_bytecode);
    if (qjs.JS_IsException(result)) {
        std.debug.print("[RUN] Bytecode execution failed\n", .{});
        printWizerException(ctx);
        return error.ExecutionFailed;
    }
    qjs.JS_FreeValue(ctx, result);

    // Now bind WASI functions to fs module (depends on _modules['fs'] from bytecode)
    logPrint("[RUN] Binding runtime polyfills\n", .{});
    initWizerPolyfills(ctx);

    logPrint("[RUN] Running event loop\n", .{});

    // Run event loop for timers and promises
    _ = qjs.js_std_loop(ctx);

    logPrint("[RUN] Execution complete\n", .{});
}

/// WASM export: Run the prepared bytecode in serve mode
/// Called by the daemon on CoW-restored instances
///
/// NOTE: This function does NOT check g_serve_mode because WAMR may apply
/// the data section after CoW restore, resetting static globals.
/// Instead, we directly use the restored g_serve_ctx and g_serve_bytecode.
export fn _edgebox_run() callconv(.c) i32 {
    logPrint("[EXPORT] _edgebox_run called\n", .{});

    // After CoW restore, the QuickJS context and bytecode should be in memory
    // even if g_serve_mode was reset by data section initialization
    if (g_serve_ctx == null) {
        // Context not available - this shouldn't happen with proper CoW restore
        std.debug.print("[ERROR] _edgebox_run: context not available (ctx=null)\n", .{});
        return 1;
    }

    runServeModeBytecode() catch |err| {
        std.debug.print("[ERROR] _edgebox_run failed: {}\n", .{err});
        return 1;
    };

    return 0;
}

/// Native print function (minimal, replaces js_std_add_helpers version)
fn printNative(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    var i: usize = 0;
    var nwritten: usize = 0;
    while (i < @as(usize, @intCast(argc))) : (i += 1) {
        if (i > 0) {
            const space_iov = [_]std.os.wasi.ciovec_t{.{ .base = " ", .len = 1 }};
            _ = std.os.wasi.fd_write(1, &space_iov, 1, &nwritten);
        }
        var len: usize = undefined;
        const str = qjs.JS_ToCStringLen(ctx, &len, argv[i]);
        if (str != null) {
            const str_iov = [_]std.os.wasi.ciovec_t{.{ .base = str, .len = len }};
            _ = std.os.wasi.fd_write(1, &str_iov, 1, &nwritten);
            qjs.JS_FreeCString(ctx, str);
        }
    }
    const nl_iov = [_]std.os.wasi.ciovec_t{.{ .base = "\n", .len = 1 }};
    _ = std.os.wasi.fd_write(1, &nl_iov, 1, &nwritten);
    return qjs.JS_UNDEFINED;
}

/// Execute bytecode using Context wrapper
fn executeBytecode(context: *quickjs.Context) !void {
    const ctx = context.inner;

    // Get bytecode pointer and size from C bridge functions
    const bytecode_ptr = get_bundle_ptr();
    const bytecode_len = get_bundle_size();

    // Re-register native bindings BEFORE executing bytecode
    registerNativeBindings(context);

    // Register frozen functions BEFORE executing bytecode
    // The bundle has hooks that check globalThis.__frozen_<name> and call the C version if present
    // This MUST happen before js_std_eval_binary so the hooks can find the frozen versions
    const frozen_count = frozen_init(ctx);
    if (frozen_count < 0) {
        return error.FrozenInitFailed;
    }

    // Set __frozen_init_complete so hook injection redirects to frozen functions
    {
        const global = qjs.JS_GetGlobalObject(ctx);
        defer qjs.JS_FreeValue(ctx, global);
        _ = qjs.JS_SetPropertyStr(ctx, global, "__frozen_init_complete", quickjs.jsTrue());
    }

    // Load bytecode
    const obj = qjs.JS_ReadObject(ctx, bytecode_ptr, bytecode_len, qjs.JS_READ_OBJ_BYTECODE);
    if (qjs.JS_IsException(obj)) {
        return error.BytecodeLoadFailed;
    }

    const tag = qjs.JS_VALUE_GET_TAG(obj);
    var result: qjs.JSValue = undefined;

    if (tag == -3) { // JS_TAG_MODULE
        if (qjs.JS_ResolveModule(ctx, obj) < 0) {
            qjs.JS_FreeValue(ctx, obj);
            return error.ModuleResolveFailed;
        }
        if (qjs.js_module_set_import_meta(ctx, obj, false, true) < 0) {
            return error.ModuleMetaFailed;
        }
        result = qjs.JS_EvalFunction(ctx, obj);

        // Run event loop to process module promises
        _ = qjs.js_std_loop(ctx);

        // Check for rejected promise
        const promise_state = qjs.JS_PromiseState(ctx, result);
        if (promise_state == 2) { // REJECTED
            const reason = qjs.JS_PromiseResult(ctx, result);
            defer qjs.JS_FreeValue(ctx, reason);
            qjs.JS_FreeValue(ctx, result);
            _ = qjs.JS_Throw(ctx, qjs.JS_DupValue(ctx, reason));
            return error.ExecutionFailed;
        }

        qjs.JS_FreeValue(ctx, result);
    } else {
        result = qjs.JS_EvalFunction(ctx, obj);
        if (qjs.JS_IsException(result)) {
            const exc = qjs.JS_GetException(ctx);
            defer qjs.JS_FreeValue(ctx, exc);
            var len: usize = undefined;
            const cstr = qjs.JS_ToCStringLen(ctx, &len, exc);
            if (cstr != null) {
                const msg = std.mem.span(cstr);
                qjs.JS_FreeCString(ctx, cstr);
                if (std.mem.indexOf(u8, msg, "proc exit") != null) {
                    return;
                }
            }
            return error.ExecutionFailed;
        }
        qjs.JS_FreeValue(ctx, result);
    }

    // Re-register native polyfills AFTER bytecode execution
    // This overrides any JS polyfills that may have been set during bytecode execution
    // Critical for modules like util.promisify which Bun bundler may overwrite
    util_polyfill.register(ctx);

    // Run event loop for timers and promises
    _ = qjs.js_std_loop(ctx);
}

/// Execute bytecode using raw JSContext (Wizer path)
fn executeBytecodeRaw(ctx: *qjs.JSContext) !void {
    debugPrint("executeBytecodeRaw: Getting bytecode pointer\n", .{});
    const bytecode_ptr = get_bundle_ptr();
    const bytecode_len = get_bundle_size();
    debugPrint("executeBytecodeRaw: Bytecode at {*}, size={d} bytes\n", .{ bytecode_ptr, bytecode_len });

    if (bytecode_len == 0) {
        std.debug.print("ERROR: Bytecode is empty (0 bytes)!\n", .{});
        return error.BytecodeLoadFailed;
    }

    debugPrint("executeBytecodeRaw: Loading bytecode object\n", .{});
    const func = qjs.JS_ReadObject(ctx, bytecode_ptr, bytecode_len, qjs.JS_READ_OBJ_BYTECODE);
    if (qjs.JS_IsException(func)) {
        std.debug.print("ERROR: Failed to load bytecode (JS_ReadObject returned exception)\n", .{});
        printWizerException(ctx);
        return error.BytecodeLoadFailed;
    }
    debugPrint("executeBytecodeRaw: Bytecode loaded successfully\n", .{});

    // Register frozen functions BEFORE executing bytecode
    rawPrint("[executeBytecodeRaw] Calling frozen_init...\n");
    const frozen_result2 = frozen_init(ctx);
    var frozen_buf2: [64]u8 = undefined;
    const frozen_msg2 = std.fmt.bufPrint(&frozen_buf2, "[executeBytecodeRaw] frozen_init returned: {d}\n", .{frozen_result2}) catch "[executeBytecodeRaw] frozen_init called\n";
    rawPrint(frozen_msg2);

    // Set __frozen_init_complete so hook injection redirects to frozen functions
    {
        const global = qjs.JS_GetGlobalObject(ctx);
        defer qjs.JS_FreeValue(ctx, global);
        _ = qjs.JS_SetPropertyStr(ctx, global, "__frozen_init_complete", quickjs.jsTrue());
    }

    debugPrint("executeBytecodeRaw: Executing bytecode via JS_EvalFunction\n", .{});
    const result = qjs.JS_EvalFunction(ctx, func);
    if (qjs.JS_IsException(result)) {
        std.debug.print("ERROR: Bytecode execution failed (JS_EvalFunction returned exception)\n", .{});
        printWizerException(ctx);
        return error.ExecutionFailed;
    }
    debugPrint("executeBytecodeRaw: Execution completed without exception\n", .{});
    qjs.JS_FreeValue(ctx, result);

    // Re-register native polyfills AFTER bytecode execution
    // This overrides any JS polyfills that may have been set during bytecode execution
    debugPrint("executeBytecodeRaw: Re-registering native polyfills\n", .{});
    util_polyfill.register(ctx);

    // Run pending Promise jobs (microtasks) first
    // This is critical because js_std_loop may return early if there are no timers/I/O
    {
        const rt = qjs.JS_GetRuntime(ctx);
        var pending_ctx: ?*qjs.JSContext = null;
        while (qjs.JS_ExecutePendingJob(rt, &pending_ctx) > 0) {}
    }

    // Run the standard event loop for async operations
    // This handles timers, promises, and I/O events
    // Note: js_std_init_handlers was already called in runWithWizerRuntime
    debugPrint("executeBytecodeRaw: Starting js_std_loop event loop\n", .{});
    const loop_result = qjs.js_std_loop(ctx);
    if (loop_result != 0) {
        debugPrint("executeBytecodeRaw: js_std_loop returned error: {d}\n", .{loop_result});
    }
    debugPrint("executeBytecodeRaw: Event loop completed\n", .{});
}

// ============================================================================
// Bindings and Polyfills
// ============================================================================

/// Bind dynamic state (process.argv, process.env)
fn bindDynamicState(ctx: *qjs.JSContext, args: []const [:0]u8) void {
    const dynamic_init =
        \\globalThis.process = globalThis.process || {};
        \\globalThis.process.version = 'v20.0.0';
        \\globalThis.process.versions = { node: '20.0.0' };
        \\globalThis.process.platform = 'wasi';
        \\globalThis.process.arch = 'wasm32';
        \\globalThis.process.exit = (code) => { if (typeof std !== 'undefined') std.exit(code || 0); };
        \\globalThis.process.cwd = () => std.getenv('PWD') || '/';
        \\globalThis.process.env = new Proxy({}, {
        \\    get(t, n) { return typeof n === 'symbol' ? undefined : std.getenv(String(n)); },
        \\    has(t, n) { return typeof n !== 'symbol' && std.getenv(String(n)) !== undefined; }
        \\});
        \\import * as std from 'std';
        \\globalThis.std = std;
    ;

    const val = qjs.JS_Eval(ctx, dynamic_init.ptr, dynamic_init.len, "<dynamic>", qjs.JS_EVAL_TYPE_MODULE);
    if (qjs.JS_IsException(val)) {
        std.debug.print("Dynamic init failed\n", .{});
        printWizerException(ctx);
    }
    qjs.JS_FreeValue(ctx, val);

    // Set process.argv
    const global = qjs.JS_GetGlobalObject(ctx);
    defer qjs.JS_FreeValue(ctx, global);

    const process = qjs.JS_GetPropertyStr(ctx, global, "process");
    defer qjs.JS_FreeValue(ctx, process);

    const argv_arr = qjs.JS_NewArray(ctx);
    var idx: u32 = 0;

    const node_str = qjs.JS_NewString(ctx, "node");
    _ = qjs.JS_SetPropertyUint32(ctx, argv_arr, idx, node_str);
    idx += 1;

    for (args[1..]) |arg| {
        const str = qjs.JS_NewStringLen(ctx, arg.ptr, arg.len);
        _ = qjs.JS_SetPropertyUint32(ctx, argv_arr, idx, str);
        idx += 1;
    }

    _ = qjs.JS_SetPropertyStr(ctx, process, "argv", argv_arr);
}

/// Register native bindings for Wizer context
fn registerWizerNativeBindings(ctx: *qjs.JSContext) void {
    const global = qjs.JS_GetGlobalObject(ctx);
    defer qjs.JS_FreeValue(ctx, global);

    inline for (.{
        .{ "__edgebox_fetch", nativeFetch, 4 },
        // Async HTTP bindings
        .{ "__edgebox_fetch_start", nativeFetchStart, 4 },
        .{ "__edgebox_fetch_poll", nativeFetchPoll, 1 },
        .{ "__edgebox_fetch_response", nativeFetchGetResponse, 1 },
        // Async Spawn bindings
        .{ "__edgebox_spawn_start", nativeSpawnStart, 1 },
        .{ "__edgebox_spawn_poll", nativeSpawnPoll, 1 },
        .{ "__edgebox_spawn_output", nativeSpawnGetOutput, 1 },
        // Async File I/O bindings
        .{ "__edgebox_file_read_start", nativeFileReadStart, 1 },
        .{ "__edgebox_file_write_start", nativeFileWriteStart, 2 },
        .{ "__edgebox_file_poll", nativeFilePoll, 1 },
        .{ "__edgebox_file_result", nativeFileGetResult, 1 },
        // Other bindings
        .{ "__edgebox_isatty", nativeIsatty, 1 },
        .{ "__edgebox_get_terminal_size", nativeGetTerminalSize, 0 },
        .{ "__edgebox_read_stdin", nativeReadStdin, 1 },
        .{ "__edgebox_stdin_ready", nativeStdinReady, 0 },
        .{ "__edgebox_spawn", nativeSpawn, 4 },
        // fs bindings
        .{ "__edgebox_fs_read", nativeFsRead, 1 },
        .{ "__edgebox_fs_write", nativeFsWrite, 2 },
        .{ "__edgebox_fs_append", nativeFsAppend, 2 },
        .{ "__edgebox_fs_exists", nativeFsExists, 1 },
        .{ "__edgebox_fs_stat", nativeFsStat, 1 },
        .{ "__edgebox_fs_readdir", nativeFsReaddir, 1 },
        .{ "__edgebox_fs_mkdir", nativeFsMkdir, 2 },
        .{ "__edgebox_fs_unlink", nativeFsUnlink, 1 },
        .{ "__edgebox_fs_rmdir", nativeFsRmdir, 2 },
        .{ "__edgebox_fs_rename", nativeFsRename, 2 },
        .{ "__edgebox_fs_copy", nativeFsCopy, 2 },
        .{ "__edgebox_cwd", nativeCwd, 0 },
        .{ "__edgebox_homedir", nativeHomedir, 0 },
        // crypto bindings
        .{ "__edgebox_hash", nativeHash, 2 },
        .{ "__edgebox_hmac", nativeHmac, 3 },
        // zlib bindings
        .{ "__edgebox_gzip", nativeGzip, 1 },
        .{ "__edgebox_gunzip", nativeGunzip, 1 },
        .{ "__edgebox_deflate", nativeDeflate, 1 },
        .{ "__edgebox_inflate", nativeInflate, 1 },
        // crypto AES bindings
        .{ "__edgebox_aes_gcm_encrypt", nativeAesGcmEncrypt, 3 },
        .{ "__edgebox_aes_gcm_decrypt", nativeAesGcmDecrypt, 3 },
        .{ "__edgebox_random_bytes", nativeRandomBytes, 1 },
        // socket bindings
        .{ "__edgebox_socket_create", nativeSocketCreate, 0 },
        .{ "__edgebox_socket_bind", nativeSocketBind, 2 },
        .{ "__edgebox_socket_listen", nativeSocketListen, 2 },
        .{ "__edgebox_socket_accept", nativeSocketAccept, 1 },
        .{ "__edgebox_socket_connect", nativeSocketConnect, 2 },
        .{ "__edgebox_socket_write", nativeSocketWrite, 2 },
        .{ "__edgebox_socket_read", nativeSocketRead, 2 },
        .{ "__edgebox_socket_close", nativeSocketClose, 1 },
        .{ "__edgebox_socket_state", nativeSocketState, 1 },
        // memory info bindings (dynamic via WASM intrinsics)
        .{ "__edgebox_totalmem", nativeTotalMem, 0 },
        .{ "__edgebox_freemem", nativeFreeMem, 0 },
        .{ "__edgebox_memusage", nativeMemUsage, 0 },
        // GPU bindings (WebGPU via sandboxed worker process)
        .{ "__edgebox_gpu_available", nativeGpuAvailable, 0 },
        .{ "__edgebox_gpu_create_buffer", nativeGpuCreateBuffer, 2 },
        .{ "__edgebox_gpu_write_buffer", nativeGpuWriteBuffer, 3 },
        .{ "__edgebox_gpu_read_buffer", nativeGpuReadBuffer, 3 },
        .{ "__edgebox_gpu_destroy_buffer", nativeGpuDestroyBuffer, 1 },
        .{ "__edgebox_gpu_create_shader", nativeGpuCreateShader, 1 },
        .{ "__edgebox_gpu_create_pipeline", nativeGpuCreatePipeline, 2 },
        .{ "__edgebox_gpu_dispatch", nativeGpuDispatch, 3 },
    }) |binding| {
        const func = qjs.JS_NewCFunction(ctx, binding[1], binding[0], binding[2]);
        _ = qjs.JS_SetPropertyStr(ctx, global, binding[0], func);
    }
}

/// Import std/os modules for Wizer path (raw JSContext)
/// CRITICAL: This must be called before bytecode execution so polyfills can use std/os
fn importWizerStdModules(ctx: *qjs.JSContext) void {
    const module_imports =
        \\import * as std from 'std';
        \\import * as os from 'os';
        \\globalThis.std = std;
        \\globalThis._os = os;
        \\print('[INIT] _os.setTimeout available: ' + (typeof globalThis._os?.setTimeout === 'function'));
    ;

    const result = qjs.JS_Eval(
        ctx,
        module_imports.ptr,
        module_imports.len,
        "<std-import>",
        qjs.JS_EVAL_TYPE_MODULE,
    );

    if (qjs.JS_IsException(result)) {
        debugPrint("importWizerStdModules: Failed to import std/os modules\n", .{});
        printWizerException(ctx);
    } else {
        qjs.JS_FreeValue(ctx, result);
        debugPrint("importWizerStdModules: std/os modules imported successfully\n", .{});
    }
}

/// Bind dynamic state to Wizer-snapshotted polyfills (runtime)
/// Most polyfills are pre-loaded by Wizer at build time. This only binds:
/// 1. process.argv/env (from WASI runtime)
/// 2. fs module (needs std.loadFile and _os.stat from QuickJS modules)
fn initWizerPolyfills(ctx: *qjs.JSContext) void {
    debugPrint("initWizerPolyfills: Binding dynamic state to Wizer polyfills\n", .{});

    // Minimal runtime bindings - bind WASI functions to pre-defined fs module
    const runtime_bindings =
        \\// === Bind dynamic process.env from WASI ===
        \\(function() {
        \\    var g = globalThis, p = g.process, m = g._modules;
        \\    if (typeof std !== 'undefined' && std.getenv) {
        \\        p.env.HOME = std.getenv('HOME') || '/';
        \\        p.env.PWD = std.getenv('PWD') || '/';
        \\        p.env.PATH = std.getenv('PATH') || '/usr/bin';
        \\        p.env.USER = std.getenv('USER') || 'root';
        \\    }
        \\    p.argv = ['node'].concat(g.scriptArgs || []);
        \\    // Bind WASI to pre-defined fs stub
        \\    var fs = m['fs'];
        \\    fs._std = std; fs._os = _os;
        \\    m['node:fs'] = fs;
        \\    m['fs/promises'] = fs.promises;
        \\    m['node:fs/promises'] = fs.promises;
        \\})();
    ;

    const result = qjs.JS_Eval(
        ctx,
        runtime_bindings.ptr,
        runtime_bindings.len,
        "<runtime-bindings>",
        qjs.JS_EVAL_TYPE_GLOBAL,
    );

    if (qjs.JS_IsException(result)) {
        debugPrint("initWizerPolyfills: Failed to bind runtime state\n", .{});
        printWizerException(ctx);
    } else {
        qjs.JS_FreeValue(ctx, result);
        debugPrint("initWizerPolyfills: Runtime bindings complete\n", .{});
    }
}

/// Simple test function that returns 42
fn nativeTestFunc(ctx: ?*qjs.JSContext, _: qjs.JSValue, _: c_int, _: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    return qjs.JS_NewInt32(ctx, 42);
}

/// Register native bindings using Context wrapper
fn registerNativeBindings(context: *quickjs.Context) void {
    // Register a simple test function first
    context.registerGlobalFunction("__edgebox_test42", nativeTestFunc, 0);
    context.registerGlobalFunction("__edgebox_fetch", nativeFetch, 4);
    // Async HTTP bindings
    context.registerGlobalFunction("__edgebox_fetch_start", nativeFetchStart, 4);
    context.registerGlobalFunction("__edgebox_fetch_poll", nativeFetchPoll, 1);
    context.registerGlobalFunction("__edgebox_fetch_response", nativeFetchGetResponse, 1);
    // Async Spawn bindings
    context.registerGlobalFunction("__edgebox_spawn_start", nativeSpawnStart, 1);
    context.registerGlobalFunction("__edgebox_spawn_poll", nativeSpawnPoll, 1);
    context.registerGlobalFunction("__edgebox_spawn_output", nativeSpawnGetOutput, 1);
    // Async File I/O bindings
    context.registerGlobalFunction("__edgebox_file_read_start", nativeFileReadStart, 1);
    context.registerGlobalFunction("__edgebox_file_write_start", nativeFileWriteStart, 2);
    context.registerGlobalFunction("__edgebox_file_poll", nativeFilePoll, 1);
    context.registerGlobalFunction("__edgebox_file_result", nativeFileGetResult, 1);
    // Other bindings
    context.registerGlobalFunction("__edgebox_isatty", nativeIsatty, 1);
    context.registerGlobalFunction("__edgebox_get_terminal_size", nativeGetTerminalSize, 0);
    context.registerGlobalFunction("__edgebox_read_stdin", nativeReadStdin, 1);
    context.registerGlobalFunction("__edgebox_stdin_ready", nativeStdinReady, 0);
    context.registerGlobalFunction("__edgebox_spawn", nativeSpawn, 4);
    // fs bindings
    context.registerGlobalFunction("__edgebox_fs_read", nativeFsRead, 1);
    context.registerGlobalFunction("__edgebox_fs_write", nativeFsWrite, 2);
    context.registerGlobalFunction("__edgebox_fs_append", nativeFsAppend, 2);
    context.registerGlobalFunction("__edgebox_fs_exists", nativeFsExists, 1);
    context.registerGlobalFunction("__edgebox_fs_stat", nativeFsStat, 1);
    context.registerGlobalFunction("__edgebox_fs_readdir", nativeFsReaddir, 1);
    context.registerGlobalFunction("__edgebox_fs_mkdir", nativeFsMkdir, 2);
    context.registerGlobalFunction("__edgebox_fs_unlink", nativeFsUnlink, 1);
    context.registerGlobalFunction("__edgebox_fs_rmdir", nativeFsRmdir, 2);
    context.registerGlobalFunction("__edgebox_fs_rename", nativeFsRename, 2);
    context.registerGlobalFunction("__edgebox_fs_copy", nativeFsCopy, 2);
    context.registerGlobalFunction("__edgebox_cwd", nativeCwd, 0);
    context.registerGlobalFunction("__edgebox_homedir", nativeHomedir, 0);
    // zlib bindings
    context.registerGlobalFunction("__edgebox_gzip", nativeGzip, 1);
    context.registerGlobalFunction("__edgebox_gunzip", nativeGunzip, 1);
    context.registerGlobalFunction("__edgebox_deflate", nativeDeflate, 1);
    context.registerGlobalFunction("__edgebox_inflate", nativeInflate, 1);
    // crypto AES bindings
    context.registerGlobalFunction("__edgebox_aes_gcm_encrypt", nativeAesGcmEncrypt, 3);
    context.registerGlobalFunction("__edgebox_aes_gcm_decrypt", nativeAesGcmDecrypt, 3);
    context.registerGlobalFunction("__edgebox_random_bytes", nativeRandomBytes, 1);
    // socket bindings
    context.registerGlobalFunction("__edgebox_socket_create", nativeSocketCreate, 0);
    context.registerGlobalFunction("__edgebox_socket_bind", nativeSocketBind, 2);
    context.registerGlobalFunction("__edgebox_socket_listen", nativeSocketListen, 2);
    context.registerGlobalFunction("__edgebox_socket_accept", nativeSocketAccept, 1);
    context.registerGlobalFunction("__edgebox_socket_connect", nativeSocketConnect, 2);
    context.registerGlobalFunction("__edgebox_socket_write", nativeSocketWrite, 2);
    context.registerGlobalFunction("__edgebox_socket_read", nativeSocketRead, 2);
    context.registerGlobalFunction("__edgebox_socket_close", nativeSocketClose, 1);
    context.registerGlobalFunction("__edgebox_socket_state", nativeSocketState, 1);
    // stdlib bindings (HostArray, HostMap)
    context.registerGlobalFunction("__edgebox_array_new", nativeArrayNew, 0);
    context.registerGlobalFunction("__edgebox_array_push", nativeArrayPush, 2);
    context.registerGlobalFunction("__edgebox_array_pop", nativeArrayPop, 1);
    context.registerGlobalFunction("__edgebox_array_get", nativeArrayGet, 2);
    context.registerGlobalFunction("__edgebox_array_set", nativeArraySet, 3);
    context.registerGlobalFunction("__edgebox_array_len", nativeArrayLen, 1);
    context.registerGlobalFunction("__edgebox_array_sort", nativeArraySort, 1);
    context.registerGlobalFunction("__edgebox_array_sort_desc", nativeArraySortDesc, 1);
    context.registerGlobalFunction("__edgebox_array_reverse", nativeArrayReverse, 1);
    context.registerGlobalFunction("__edgebox_array_clear", nativeArrayClear, 1);
    context.registerGlobalFunction("__edgebox_array_index_of", nativeArrayIndexOf, 2);
    context.registerGlobalFunction("__edgebox_array_free", nativeArrayFree, 1);
    context.registerGlobalFunction("__edgebox_map_new", nativeMapNew, 0);
    context.registerGlobalFunction("__edgebox_map_set", nativeMapSet, 3);
    context.registerGlobalFunction("__edgebox_map_get", nativeMapGet, 2);
    context.registerGlobalFunction("__edgebox_map_has", nativeMapHas, 2);
    context.registerGlobalFunction("__edgebox_map_delete", nativeMapDelete, 2);
    context.registerGlobalFunction("__edgebox_map_len", nativeMapLen, 1);
    context.registerGlobalFunction("__edgebox_map_clear", nativeMapClear, 1);
    context.registerGlobalFunction("__edgebox_map_free", nativeMapFree, 1);
}

/// Import std/os modules - NOTE: This doesn't work for pre-compiled bytecode
/// because the module scope is separate. The polyfills have fallback implementations.
fn importStdModules(context: *quickjs.Context) !void {
    // Import std/os modules to make _os.setTimeout available
    // This is CRITICAL for proper event loop integration
    const module_imports =
        \\import * as std from 'std';
        \\import * as os from 'os';
        \\globalThis.std = std;
        \\globalThis._os = os;
        \\// print('[std/os] _os.setTimeout type: ' + typeof globalThis._os.setTimeout);
    ;

    _ = context.evalModule(module_imports, "<std-modules>") catch |err| {
        logPrint("[importStdModules] Failed to import std/os: {}\n", .{err});
        return err;
    };
    logPrint("[importStdModules] std/os modules imported - _os.setTimeout available\n", .{});
}

/// Print exception (Wizer path) with full stack trace
fn printWizerException(ctx: *qjs.JSContext) void {
    const exc = qjs.JS_GetException(ctx);
    defer qjs.JS_FreeValue(ctx, exc);

    // Get exception message
    var len: usize = undefined;
    const cstr = qjs.JS_ToCStringLen(ctx, &len, exc);
    if (cstr != null) {
        std.debug.print("Exception: {s}\n", .{cstr[0..len]});
        qjs.JS_FreeCString(ctx, cstr);
    } else {
        std.debug.print("Exception: (unable to convert to string)\n", .{});
    }

    // Try to get stack trace
    const stack_prop = qjs.JS_GetPropertyStr(ctx, exc, "stack");
    defer qjs.JS_FreeValue(ctx, stack_prop);

    if (!qjs.JS_IsUndefined(stack_prop) and !qjs.JS_IsNull(stack_prop)) {
        var stack_len: usize = undefined;
        const stack_cstr = qjs.JS_ToCStringLen(ctx, &stack_len, stack_prop);
        if (stack_cstr != null) {
            std.debug.print("Stack trace:\n{s}\n", .{stack_cstr[0..stack_len]});
            qjs.JS_FreeCString(ctx, stack_cstr);
        }
    }

    // Try to get the exception name/type
    const name_prop = qjs.JS_GetPropertyStr(ctx, exc, "name");
    defer qjs.JS_FreeValue(ctx, name_prop);

    if (!qjs.JS_IsUndefined(name_prop) and !qjs.JS_IsNull(name_prop)) {
        var name_len: usize = undefined;
        const name_cstr = qjs.JS_ToCStringLen(ctx, &name_len, name_prop);
        if (name_cstr != null) {
            std.debug.print("Exception type: {s}\n", .{name_cstr[0..name_len]});
            qjs.JS_FreeCString(ctx, name_cstr);
        }
    }
}

// ============================================================================
// Promise Rejection Handler
// ============================================================================

/// Silent promise rejection tracker - prevents QuickJS from calling exit(1) on unhandled rejections
/// In WASM, exit() doesn't work properly, causing an infinite loop of "Possibly unhandled promise rejection"
fn silentPromiseRejectionTracker(
    ctx: ?*qjs.JSContext,
    _: qjs.JSValue, // promise
    reason: qjs.JSValue,
    is_handled: bool,
    _: ?*anyopaque, // opaque
) callconv(.c) void {
    // Only log if debug is enabled and the rejection is NOT handled
    if (debug_enabled and !is_handled) {
        var len: usize = undefined;
        const reason_str = qjs.JS_ToCStringLen(ctx, &len, reason);
        if (reason_str != null) {
            std.debug.print("[EDGEBOX] Unhandled promise rejection: {s}\n", .{reason_str[0..len]});
            qjs.JS_FreeCString(ctx, reason_str);
        }
    }
    // Do nothing - don't exit, don't add to rejected list
    // This prevents the infinite loop in js_std_promise_rejection_check
}

// ============================================================================
// Native Binding Implementations (same as wasm_main.zig)
// ============================================================================

inline fn jsBool(val: bool) qjs.JSValue {
    return if (val) quickjs.jsTrue() else quickjs.jsFalse();
}

fn getStringArg(ctx: ?*qjs.JSContext, val: qjs.JSValue) ?[]const u8 {
    var len: usize = undefined;
    const cstr = qjs.JS_ToCStringLen(ctx, &len, val);
    if (cstr == null) return null;
    return cstr[0..len];
}

fn freeStringArg(ctx: ?*qjs.JSContext, str: []const u8) void {
    qjs.JS_FreeCString(ctx, str.ptr);
}

// Cache for home directory (set on init)
var home_dir: ?[]const u8 = null;
var home_dir_buf: [256]u8 = undefined;

fn initHomeDir() void {
    if (home_dir != null) return;

    // In WASM, we need to use WASI's environ functions
    const alloc = global_allocator orelse return;

    var environ_count: usize = 0;
    var environ_buf_size: usize = 0;
    _ = std.os.wasi.environ_sizes_get(&environ_count, &environ_buf_size);
    if (environ_count == 0) return;

    const environ_ptrs = alloc.alloc([*:0]u8, environ_count) catch return;
    defer alloc.free(environ_ptrs);
    const environ_buf = alloc.alloc(u8, environ_buf_size) catch return;
    defer alloc.free(environ_buf);
    _ = std.os.wasi.environ_get(environ_ptrs.ptr, environ_buf.ptr);

    // Look for HOME=
    for (environ_ptrs) |env_ptr| {
        const env = std.mem.span(env_ptr);
        if (std.mem.startsWith(u8, env, "HOME=")) {
            const h = env[5..];
            if (h.len < home_dir_buf.len) {
                @memcpy(home_dir_buf[0..h.len], h);
                home_dir = home_dir_buf[0..h.len];
            }
            return;
        }
    }
}

// Translate /home/user paths to actual home directory
// Returns a static buffer - must be used before next call
var translated_path_buf: [4096]u8 = undefined;
fn translatePath(path: []const u8) []const u8 {
    initHomeDir();
    const home = home_dir orelse return path;

    // Check for /home/user prefix
    const prefix = "/home/user";
    if (std.mem.startsWith(u8, path, prefix)) {
        // Replace /home/user with actual home
        const suffix = path[prefix.len..];
        const total_len = home.len + suffix.len;
        if (total_len < translated_path_buf.len) {
            @memcpy(translated_path_buf[0..home.len], home);
            @memcpy(translated_path_buf[home.len..][0..suffix.len], suffix);
            return translated_path_buf[0..total_len];
        }
    }
    return path;
}

fn nativeFetch(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "fetch requires url argument");

    const url = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "url must be a string");
    defer freeStringArg(ctx, url);

    std.debug.print("[FETCH NATIVE] URL: {s}\n", .{url});

    const method = if (argc >= 2 and !qjs.JS_IsUndefined(argv[1]) and !qjs.JS_IsNull(argv[1]))
        getStringArg(ctx, argv[1]) orelse "GET"
    else
        "GET";
    const method_owned = argc >= 2 and !qjs.JS_IsUndefined(argv[1]) and !qjs.JS_IsNull(argv[1]) and getStringArg(ctx, argv[1]) != null;
    defer if (method_owned) freeStringArg(ctx, method);

    // Parse headers JSON (argv[2]) and convert to "Key: Value\r\n" format
    const headers_json_str = if (argc >= 3 and !qjs.JS_IsUndefined(argv[2]) and !qjs.JS_IsNull(argv[2]))
        getStringArg(ctx, argv[2])
    else
        null;
    defer if (headers_json_str) |h| freeStringArg(ctx, h);

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    // Convert JSON headers to HTTP format: "Key: Value\r\nKey2: Value2"
    var headers_buf = std.ArrayListUnmanaged(u8){};
    defer headers_buf.deinit(allocator);

    if (headers_json_str) |json_str| {
        std.debug.print("[FETCH NATIVE] Headers JSON: {s}\n", .{json_str});
        // Parse JSON object
        const parsed = std.json.parseFromSlice(std.json.Value, allocator, json_str, .{}) catch |err| blk: {
            std.debug.print("[FETCH NATIVE] JSON parse error: {}\n", .{err});
            break :blk null;
        };
        if (parsed) |p| {
            defer p.deinit();
            if (p.value == .object) {
                var iter = p.value.object.iterator();
                while (iter.next()) |entry| {
                    const key = entry.key_ptr.*;
                    if (entry.value_ptr.* == .string) {
                        const value = entry.value_ptr.string;
                        std.debug.print("[FETCH NATIVE] Header: {s} = {s}\n", .{ key, value });
                        headers_buf.appendSlice(allocator, key) catch {};
                        headers_buf.appendSlice(allocator, ": ") catch {};
                        headers_buf.appendSlice(allocator, value) catch {};
                        headers_buf.appendSlice(allocator, "\r\n") catch {};
                    }
                }
            }
        }
    }

    std.debug.print("[FETCH NATIVE] Converted headers ({d} bytes): {s}\n", .{ headers_buf.items.len, headers_buf.items });

    const body = if (argc >= 4 and !qjs.JS_IsUndefined(argv[3]) and !qjs.JS_IsNull(argv[3]))
        getStringArg(ctx, argv[3])
    else
        null;
    defer if (body) |b| freeStringArg(ctx, b);

    // Call host HTTP bridge with converted headers
    const status = request(
        url.ptr,
        @intCast(url.len),
        method.ptr,
        @intCast(method.len),
        headers_buf.items.ptr,
        @intCast(headers_buf.items.len),
        if (body) |b| b.ptr else "".ptr,
        if (body) |b| @intCast(b.len) else 0,
    );

    if (status < 0) {
        return switch (status) {
            -1 => qjs.JS_ThrowTypeError(ctx, "Invalid URL"),
            -2 => qjs.JS_ThrowInternalError(ctx, "HTTP request failed"),
            else => qjs.JS_ThrowInternalError(ctx, "Unknown HTTP error"),
        };
    }

    // Get response from host
    const response_len = get_response_len();
    if (response_len <= 0) {
        return qjs.JS_ThrowInternalError(ctx, "Empty response from host");
    }

    // Allocate buffer and copy response
    const response_buf = allocator.alloc(u8, @intCast(response_len)) catch {
        return qjs.JS_ThrowInternalError(ctx, "Out of memory");
    };
    defer allocator.free(response_buf);

    _ = get_response(response_buf.ptr);

    // Parse JSON response: {"status": N, "ok": bool, "body": "...", "headers": {...}}
    var parsed = std.json.parseFromSlice(std.json.Value, allocator, response_buf, .{}) catch {
        return qjs.JS_ThrowInternalError(ctx, "Failed to parse response JSON");
    };
    defer parsed.deinit();

    const obj = qjs.JS_NewObject(ctx);

    if (parsed.value == .object) {
        const map = &parsed.value.object;

        // Status
        if (map.get("status")) |s| {
            if (s == .integer) {
                _ = qjs.JS_SetPropertyStr(ctx, obj, "status", qjs.JS_NewInt32(ctx, @intCast(s.integer)));
            }
        }

        // Ok
        if (map.get("ok")) |o| {
            if (o == .bool) {
                _ = qjs.JS_SetPropertyStr(ctx, obj, "ok", jsBool(o.bool));
            }
        }

        // Body
        if (map.get("body")) |b| {
            if (b == .string) {
                _ = qjs.JS_SetPropertyStr(ctx, obj, "body", qjs.JS_NewStringLen(ctx, b.string.ptr, b.string.len));
            }
        }

        // Headers (empty object for now)
        _ = qjs.JS_SetPropertyStr(ctx, obj, "headers", qjs.JS_NewObject(ctx));
    }

    return obj;
}

// ============================================================================
// Async HTTP Native Bindings
// ============================================================================

/// Start an async HTTP request - returns request ID
fn nativeFetchStart(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "fetch requires url argument");

    const url = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "url must be a string");
    defer freeStringArg(ctx, url);

    const method = if (argc >= 2 and !qjs.JS_IsUndefined(argv[1]) and !qjs.JS_IsNull(argv[1]))
        getStringArg(ctx, argv[1]) orelse "GET"
    else
        "GET";
    const method_owned = argc >= 2 and !qjs.JS_IsUndefined(argv[1]) and !qjs.JS_IsNull(argv[1]) and getStringArg(ctx, argv[1]) != null;
    defer if (method_owned) freeStringArg(ctx, method);

    // Parse headers JSON (argv[2]) and convert to "Key: Value\r\n" format
    const headers_json_str = if (argc >= 3 and !qjs.JS_IsUndefined(argv[2]) and !qjs.JS_IsNull(argv[2]))
        getStringArg(ctx, argv[2])
    else
        null;
    defer if (headers_json_str) |h| freeStringArg(ctx, h);

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    // Convert JSON headers to HTTP format
    var headers_buf = std.ArrayListUnmanaged(u8){};
    defer headers_buf.deinit(allocator);

    if (headers_json_str) |json_str| {
        var parsed = std.json.parseFromSlice(std.json.Value, allocator, json_str, .{}) catch null;
        if (parsed) |*p| {
            defer p.deinit();
            if (p.value == .object) {
                var iter = p.value.object.iterator();
                while (iter.next()) |entry| {
                    const key = entry.key_ptr.*;
                    if (entry.value_ptr.* == .string) {
                        const value = entry.value_ptr.string;
                        headers_buf.appendSlice(allocator, key) catch {};
                        headers_buf.appendSlice(allocator, ": ") catch {};
                        headers_buf.appendSlice(allocator, value) catch {};
                        headers_buf.appendSlice(allocator, "\r\n") catch {};
                    }
                }
            }
        }
    }

    const body = if (argc >= 4 and !qjs.JS_IsUndefined(argv[3]) and !qjs.JS_IsNull(argv[3]))
        getStringArg(ctx, argv[3])
    else
        null;
    defer if (body) |b| freeStringArg(ctx, b);

    // Call host to start async request
    const request_id = start_async(
        url.ptr,
        @intCast(url.len),
        method.ptr,
        @intCast(method.len),
        headers_buf.items.ptr,
        @intCast(headers_buf.items.len),
        if (body) |b| b.ptr else "".ptr,
        if (body) |b| @intCast(b.len) else 0,
    );

    if (request_id < 0) {
        return switch (request_id) {
            -1 => qjs.JS_ThrowTypeError(ctx, "Invalid URL"),
            -3 => qjs.JS_ThrowInternalError(ctx, "Domain not allowed"),
            -4 => qjs.JS_ThrowInternalError(ctx, "Too many pending requests"),
            else => qjs.JS_ThrowInternalError(ctx, "Failed to start request"),
        };
    }

    return qjs.JS_NewInt32(ctx, request_id);
}

/// Poll an async HTTP request - returns 0=pending, 1=complete, <0=error
fn nativeFetchPoll(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_NewInt32(ctx, -1);

    var request_id: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &request_id, argv[0]) < 0) {
        return qjs.JS_NewInt32(ctx, -1);
    }

    const status = http_poll(@intCast(request_id));
    return qjs.JS_NewInt32(ctx, status);
}

/// Get response for a completed async request
fn nativeFetchGetResponse(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "request_id required");

    var request_id: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &request_id, argv[0]) < 0) {
        return qjs.JS_ThrowTypeError(ctx, "invalid request_id");
    }

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    // Get response length
    const response_len = http_response_len(@intCast(request_id));
    if (response_len <= 0) {
        return qjs.JS_ThrowInternalError(ctx, "No response available");
    }

    // Allocate buffer and copy response
    const response_buf = allocator.alloc(u8, @intCast(response_len)) catch {
        return qjs.JS_ThrowInternalError(ctx, "Out of memory");
    };
    defer allocator.free(response_buf);

    _ = http_response(@intCast(request_id), response_buf.ptr);

    // Parse JSON response
    var parsed = std.json.parseFromSlice(std.json.Value, allocator, response_buf, .{}) catch {
        return qjs.JS_ThrowInternalError(ctx, "Failed to parse response JSON");
    };
    defer parsed.deinit();

    const obj = qjs.JS_NewObject(ctx);

    if (parsed.value == .object) {
        const map = &parsed.value.object;

        if (map.get("status")) |s| {
            if (s == .integer) {
                _ = qjs.JS_SetPropertyStr(ctx, obj, "status", qjs.JS_NewInt32(ctx, @intCast(s.integer)));
            }
        }

        if (map.get("ok")) |o| {
            if (o == .bool) {
                _ = qjs.JS_SetPropertyStr(ctx, obj, "ok", jsBool(o.bool));
            }
        }

        if (map.get("body")) |b| {
            if (b == .string) {
                _ = qjs.JS_SetPropertyStr(ctx, obj, "body", qjs.JS_NewStringLen(ctx, b.string.ptr, b.string.len));
            }
        }

        _ = qjs.JS_SetPropertyStr(ctx, obj, "headers", qjs.JS_NewObject(ctx));
    }

    // Free the async request
    _ = http_free(@intCast(request_id));

    return obj;
}

// ============================================================================
// Async Spawn Native Bindings
// ============================================================================

/// Start an async spawn - returns spawn ID
fn nativeSpawnStart(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "spawn requires command argument");

    const command = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "command must be a string");
    defer freeStringArg(ctx, command);

    // Call host spawn_start
    const spawn_id = spawn_start(
        command.ptr,
        @intCast(command.len),
        "".ptr, // args (unused for now)
        0,
    );

    if (spawn_id < 0) {
        return switch (spawn_id) {
            -1 => qjs.JS_ThrowTypeError(ctx, "Invalid command"),
            -2 => qjs.JS_ThrowInternalError(ctx, "Empty command"),
            -3 => qjs.JS_ThrowInternalError(ctx, "Failed to spawn process"),
            -4 => qjs.JS_ThrowInternalError(ctx, "Too many pending spawns"),
            else => qjs.JS_ThrowInternalError(ctx, "Spawn failed"),
        };
    }

    return qjs.JS_NewInt32(ctx, spawn_id);
}

/// Poll an async spawn - returns 0=running, 1=done, <0=error
fn nativeSpawnPoll(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_NewInt32(ctx, -1);

    var spawn_id: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &spawn_id, argv[0]) < 0) {
        return qjs.JS_NewInt32(ctx, -1);
    }

    const status = spawn_poll(@intCast(spawn_id));
    return qjs.JS_NewInt32(ctx, status);
}

/// Get spawn output - returns {stdout, stderr, exitCode}
fn nativeSpawnGetOutput(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "spawn_id required");

    var spawn_id: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &spawn_id, argv[0]) < 0) {
        return qjs.JS_ThrowTypeError(ctx, "invalid spawn_id");
    }

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    // Get output length (this also builds the JSON)
    const output_len = spawn_output_len(@intCast(spawn_id));
    if (output_len <= 0) {
        return qjs.JS_ThrowInternalError(ctx, "No output available");
    }

    // Allocate buffer and copy output
    const output_buf = allocator.alloc(u8, @intCast(output_len)) catch {
        return qjs.JS_ThrowInternalError(ctx, "Out of memory");
    };
    defer allocator.free(output_buf);

    _ = spawn_output(@intCast(spawn_id), output_buf.ptr);

    // Parse JSON response: {"exitCode": N, "stdout": "...", "stderr": "..."}
    var parsed = std.json.parseFromSlice(std.json.Value, allocator, output_buf, .{}) catch {
        return qjs.JS_ThrowInternalError(ctx, "Failed to parse output JSON");
    };
    defer parsed.deinit();

    const obj = qjs.JS_NewObject(ctx);

    if (parsed.value == .object) {
        const map = &parsed.value.object;

        if (map.get("exitCode")) |e| {
            if (e == .integer) {
                _ = qjs.JS_SetPropertyStr(ctx, obj, "exitCode", qjs.JS_NewInt32(ctx, @intCast(e.integer)));
            }
        }

        if (map.get("stdout")) |s| {
            if (s == .string) {
                _ = qjs.JS_SetPropertyStr(ctx, obj, "stdout", qjs.JS_NewStringLen(ctx, s.string.ptr, s.string.len));
            }
        }

        if (map.get("stderr")) |s| {
            if (s == .string) {
                _ = qjs.JS_SetPropertyStr(ctx, obj, "stderr", qjs.JS_NewStringLen(ctx, s.string.ptr, s.string.len));
            }
        }
    }

    // Free the spawn request
    _ = spawn_free(@intCast(spawn_id));

    return obj;
}

// ============================================================================
// Async File I/O Native Bindings
// ============================================================================

/// Start an async file read - returns request ID
fn nativeFileReadStart(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "file read requires path argument");

    const path = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "path must be a string");
    defer freeStringArg(ctx, path);

    std.debug.print("[nativeFileReadStart] path={s} len={} ptr={}\n", .{ path, path.len, @intFromPtr(path.ptr) });

    // Call host to start async file read
    const request_id = file_read_start(path.ptr, @intCast(path.len));
    std.debug.print("[nativeFileReadStart] request_id={}\n", .{request_id});

    if (request_id < 0) {
        return switch (request_id) {
            -1 => qjs.JS_ThrowTypeError(ctx, "Invalid path"),
            -4 => qjs.JS_ThrowInternalError(ctx, "Too many pending file operations"),
            else => qjs.JS_ThrowInternalError(ctx, "Failed to start file read"),
        };
    }

    return qjs.JS_NewInt32(ctx, request_id);
}

/// Start an async file write - returns request ID
fn nativeFileWriteStart(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "file write requires path and data arguments");

    const path = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "path must be a string");
    defer freeStringArg(ctx, path);

    const data = getStringArg(ctx, argv[1]) orelse
        return qjs.JS_ThrowTypeError(ctx, "data must be a string");
    defer freeStringArg(ctx, data);

    // Call host to start async file write
    const request_id = file_write_start(path.ptr, @intCast(path.len), data.ptr, @intCast(data.len));

    if (request_id < 0) {
        return switch (request_id) {
            -1 => qjs.JS_ThrowTypeError(ctx, "Invalid path"),
            -2 => qjs.JS_ThrowTypeError(ctx, "Invalid data"),
            -4 => qjs.JS_ThrowInternalError(ctx, "Too many pending file operations"),
            else => qjs.JS_ThrowInternalError(ctx, "Failed to start file write"),
        };
    }

    return qjs.JS_NewInt32(ctx, request_id);
}

/// Poll an async file operation - returns 0=pending, 1=complete, <0=error
fn nativeFilePoll(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_NewInt32(ctx, -1);

    var request_id: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &request_id, argv[0]) < 0) {
        return qjs.JS_NewInt32(ctx, -1);
    }

    const status = file_poll(@intCast(request_id));
    std.debug.print("[nativeFilePoll] request_id={} status={}\n", .{ request_id, status });
    return qjs.JS_NewInt32(ctx, status);
}

/// Get result for a completed file operation
/// For reads: returns file content as string
/// For writes: returns bytes written as number
fn nativeFileGetResult(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "request_id required");

    var request_id: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &request_id, argv[0]) < 0) {
        return qjs.JS_ThrowTypeError(ctx, "invalid request_id");
    }

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    // Check poll status first
    const status = file_poll(@intCast(request_id));
    if (status == 0) {
        return qjs.JS_ThrowInternalError(ctx, "Operation still pending");
    }

    // Get result length
    const res_len = file_result_len(@intCast(request_id));

    if (res_len < 0) {
        // Error - res_len is negative of error message length
        const err_len: usize = @intCast(-res_len);
        const err_buf = allocator.alloc(u8, err_len) catch {
            _ = file_free(@intCast(request_id));
            return qjs.JS_ThrowInternalError(ctx, "Out of memory");
        };
        defer allocator.free(err_buf);

        _ = file_result(@intCast(request_id), err_buf.ptr);
        _ = file_free(@intCast(request_id));

        // Return error as exception
        return qjs.JS_ThrowInternalError(ctx, @ptrCast(err_buf.ptr));
    }

    if (res_len == 0) {
        // Write operation with 0 bytes or empty read
        _ = file_free(@intCast(request_id));
        return qjs.JS_NewInt32(ctx, 0);
    }

    // Allocate buffer and copy result
    const result_buf = allocator.alloc(u8, @intCast(res_len)) catch {
        _ = file_free(@intCast(request_id));
        return qjs.JS_ThrowInternalError(ctx, "Out of memory");
    };
    defer allocator.free(result_buf);

    const copied = file_result(@intCast(request_id), result_buf.ptr);
    _ = file_free(@intCast(request_id));

    if (copied < 0) {
        return qjs.JS_ThrowInternalError(ctx, "Failed to get result");
    }

    // Return as string (for read) or the string representation of data
    return qjs.JS_NewStringLen(ctx, result_buf.ptr, @intCast(copied));
}

// ============================================================================
// Zlib Native Bindings
// ============================================================================

/// Gzip compress - returns base64-encoded result
fn nativeGzip(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "gzip requires data argument");

    const data = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "data must be a string");
    defer freeStringArg(ctx, data);

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    // Call host gzip function
    const result_len = gzip(data.ptr, @intCast(data.len));
    if (result_len < 0) {
        return qjs.JS_ThrowInternalError(ctx, "Compression failed");
    }

    // Get compressed data
    const result_buf = allocator.alloc(u8, @intCast(result_len)) catch {
        return qjs.JS_ThrowInternalError(ctx, "Out of memory");
    };
    defer allocator.free(result_buf);

    _ = zlib_get_result(result_buf.ptr);

    // Return as binary string (each byte as char code)
    return qjs.JS_NewStringLen(ctx, result_buf.ptr, @intCast(result_len));
}

/// Gunzip decompress
fn nativeGunzip(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "gunzip requires data argument");

    const data = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "data must be a string");
    defer freeStringArg(ctx, data);

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    const result_len = gunzip(data.ptr, @intCast(data.len));
    if (result_len < 0) {
        return qjs.JS_ThrowInternalError(ctx, "Decompression failed");
    }

    const result_buf = allocator.alloc(u8, @intCast(result_len)) catch {
        return qjs.JS_ThrowInternalError(ctx, "Out of memory");
    };
    defer allocator.free(result_buf);

    _ = zlib_get_result(result_buf.ptr);
    return qjs.JS_NewStringLen(ctx, result_buf.ptr, @intCast(result_len));
}

/// Deflate compress (zlib format)
fn nativeDeflate(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "deflate requires data argument");

    const data = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "data must be a string");
    defer freeStringArg(ctx, data);

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    const result_len = deflate(data.ptr, @intCast(data.len));
    if (result_len < 0) {
        return qjs.JS_ThrowInternalError(ctx, "Compression failed");
    }

    const result_buf = allocator.alloc(u8, @intCast(result_len)) catch {
        return qjs.JS_ThrowInternalError(ctx, "Out of memory");
    };
    defer allocator.free(result_buf);

    _ = zlib_get_result(result_buf.ptr);
    return qjs.JS_NewStringLen(ctx, result_buf.ptr, @intCast(result_len));
}

/// Inflate decompress (zlib format)
fn nativeInflate(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "inflate requires data argument");

    const data = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "data must be a string");
    defer freeStringArg(ctx, data);

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    const result_len = inflate(data.ptr, @intCast(data.len));
    if (result_len < 0) {
        return qjs.JS_ThrowInternalError(ctx, "Decompression failed");
    }

    const result_buf = allocator.alloc(u8, @intCast(result_len)) catch {
        return qjs.JS_ThrowInternalError(ctx, "Out of memory");
    };
    defer allocator.free(result_buf);

    _ = zlib_get_result(result_buf.ptr);
    return qjs.JS_NewStringLen(ctx, result_buf.ptr, @intCast(result_len));
}

// ============================================================================
// Crypto AES Native Bindings
// ============================================================================

/// AES-GCM encrypt - takes key, iv, data (all binary strings)
fn nativeAesGcmEncrypt(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 3) return qjs.JS_ThrowTypeError(ctx, "aes_gcm_encrypt requires key, iv, data arguments");

    const key = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "key must be a string");
    defer freeStringArg(ctx, key);

    const iv = getStringArg(ctx, argv[1]) orelse
        return qjs.JS_ThrowTypeError(ctx, "iv must be a string");
    defer freeStringArg(ctx, iv);

    const data = getStringArg(ctx, argv[2]) orelse
        return qjs.JS_ThrowTypeError(ctx, "data must be a string");
    defer freeStringArg(ctx, data);

    if (key.len != 32) {
        return qjs.JS_ThrowTypeError(ctx, "AES-256-GCM requires 32-byte key");
    }
    if (iv.len != 12) {
        return qjs.JS_ThrowTypeError(ctx, "AES-GCM requires 12-byte IV");
    }

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    const result_len = aes_gcm_encrypt(key.ptr, @intCast(key.len), iv.ptr, @intCast(iv.len), data.ptr, @intCast(data.len));
    if (result_len < 0) {
        return qjs.JS_ThrowInternalError(ctx, "Encryption failed");
    }

    const result_buf = allocator.alloc(u8, @intCast(result_len)) catch {
        return qjs.JS_ThrowInternalError(ctx, "Out of memory");
    };
    defer allocator.free(result_buf);

    _ = crypto_get_result(result_buf.ptr);
    return qjs.JS_NewStringLen(ctx, result_buf.ptr, @intCast(result_len));
}

/// AES-GCM decrypt - takes key, iv, ciphertext+tag (all binary strings)
fn nativeAesGcmDecrypt(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 3) return qjs.JS_ThrowTypeError(ctx, "aes_gcm_decrypt requires key, iv, data arguments");

    const key = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "key must be a string");
    defer freeStringArg(ctx, key);

    const iv = getStringArg(ctx, argv[1]) orelse
        return qjs.JS_ThrowTypeError(ctx, "iv must be a string");
    defer freeStringArg(ctx, iv);

    const data = getStringArg(ctx, argv[2]) orelse
        return qjs.JS_ThrowTypeError(ctx, "data must be a string");
    defer freeStringArg(ctx, data);

    if (key.len != 32) {
        return qjs.JS_ThrowTypeError(ctx, "AES-256-GCM requires 32-byte key");
    }
    if (iv.len != 12) {
        return qjs.JS_ThrowTypeError(ctx, "AES-GCM requires 12-byte IV");
    }
    if (data.len < 16) {
        return qjs.JS_ThrowTypeError(ctx, "Ciphertext must include 16-byte auth tag");
    }

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    const result_len = aes_gcm_decrypt(key.ptr, @intCast(key.len), iv.ptr, @intCast(iv.len), data.ptr, @intCast(data.len));
    if (result_len < 0) {
        return qjs.JS_ThrowInternalError(ctx, "Decryption failed - authentication error");
    }

    const result_buf = allocator.alloc(u8, @intCast(result_len)) catch {
        return qjs.JS_ThrowInternalError(ctx, "Out of memory");
    };
    defer allocator.free(result_buf);

    _ = crypto_get_result(result_buf.ptr);
    return qjs.JS_NewStringLen(ctx, result_buf.ptr, @intCast(result_len));
}

/// Generate cryptographically secure random bytes
fn nativeRandomBytes(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "randomBytes requires size argument");

    var size: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &size, argv[0]) < 0 or size < 0 or size > 65536) {
        return qjs.JS_ThrowTypeError(ctx, "size must be 0-65536");
    }

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    const result_buf = allocator.alloc(u8, @intCast(size)) catch {
        return qjs.JS_ThrowInternalError(ctx, "Out of memory");
    };
    defer allocator.free(result_buf);

    const written = random_bytes(result_buf.ptr, @intCast(size));
    if (written < 0) {
        return qjs.JS_ThrowInternalError(ctx, "Failed to generate random bytes");
    }

    return qjs.JS_NewStringLen(ctx, result_buf.ptr, @intCast(written));
}

// ============================================================================
// Socket Native Bindings
// ============================================================================

/// Create a new socket - returns socket ID
fn nativeSocketCreate(ctx: ?*qjs.JSContext, _: qjs.JSValue, _: c_int, _: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    const result = socket_create();
    if (result < 0) {
        return qjs.JS_ThrowInternalError(ctx, "Failed to create socket");
    }
    return qjs.JS_NewInt32(ctx, result);
}

/// Bind socket to a port
fn nativeSocketBind(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "bind requires socket_id and port");

    var socket_id: i32 = 0;
    var port: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &socket_id, argv[0]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid socket_id");
    if (qjs.JS_ToInt32(ctx, &port, argv[1]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid port");

    const result = socket_bind(@intCast(socket_id), @intCast(port));
    return qjs.JS_NewInt32(ctx, result);
}

/// Listen on socket
fn nativeSocketListen(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "listen requires socket_id and backlog");

    var socket_id: i32 = 0;
    var backlog: i32 = 128;
    if (qjs.JS_ToInt32(ctx, &socket_id, argv[0]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid socket_id");
    if (argc >= 2) _ = qjs.JS_ToInt32(ctx, &backlog, argv[1]);

    const result = socket_listen(@intCast(socket_id), @intCast(backlog));
    return qjs.JS_NewInt32(ctx, result);
}

/// Accept connection - returns new socket ID or 0 if no pending connection
fn nativeSocketAccept(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "accept requires socket_id");

    var socket_id: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &socket_id, argv[0]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid socket_id");

    const result = socket_accept(@intCast(socket_id));
    return qjs.JS_NewInt32(ctx, result);
}

/// Connect to a port
fn nativeSocketConnect(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "connect requires socket_id and port");

    var socket_id: i32 = 0;
    var port: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &socket_id, argv[0]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid socket_id");
    if (qjs.JS_ToInt32(ctx, &port, argv[1]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid port");

    const result = socket_connect(@intCast(socket_id), @intCast(port));
    return qjs.JS_NewInt32(ctx, result);
}

/// Write data to socket
fn nativeSocketWrite(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "write requires socket_id and data");

    var socket_id: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &socket_id, argv[0]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid socket_id");

    const data = getStringArg(ctx, argv[1]) orelse return qjs.JS_ThrowTypeError(ctx, "data must be string");
    defer freeStringArg(ctx, data);

    const result = socket_write(@intCast(socket_id), data.ptr, @intCast(data.len));
    return qjs.JS_NewInt32(ctx, result);
}

/// Read from socket - returns data as string
fn nativeSocketRead(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "read requires socket_id");

    var socket_id: i32 = 0;
    var max_len: i32 = 8192;
    if (qjs.JS_ToInt32(ctx, &socket_id, argv[0]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid socket_id");
    if (argc >= 2) _ = qjs.JS_ToInt32(ctx, &max_len, argv[1]);

    const allocator = global_allocator orelse return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    const bytes_read = socket_read(@intCast(socket_id), @intCast(max_len));
    if (bytes_read < 0) {
        if (bytes_read == -4) {
            // Connection closed - return null
            return qjs.JS_NULL;
        }
        return qjs.JS_ThrowInternalError(ctx, "Read failed");
    }
    if (bytes_read == 0) {
        // No data available (non-blocking)
        return qjs.JS_NewStringLen(ctx, "", 0);
    }

    // Get the data
    const result_buf = allocator.alloc(u8, @intCast(bytes_read)) catch {
        return qjs.JS_ThrowInternalError(ctx, "Out of memory");
    };
    defer allocator.free(result_buf);

    _ = socket_get_read_data(@intCast(socket_id), result_buf.ptr);
    return qjs.JS_NewStringLen(ctx, result_buf.ptr, @intCast(bytes_read));
}

/// Close socket
fn nativeSocketClose(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "close requires socket_id");

    var socket_id: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &socket_id, argv[0]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid socket_id");

    const result = socket_close(@intCast(socket_id));
    return qjs.JS_NewInt32(ctx, result);
}

/// Get socket state
fn nativeSocketState(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "state requires socket_id");

    var socket_id: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &socket_id, argv[0]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid socket_id");

    const result = socket_state(@intCast(socket_id));
    return qjs.JS_NewInt32(ctx, result);
}

// ============================================================================
// Memory Info Native Bindings
// ============================================================================
// Returns actual WASM memory info via memory.size intrinsic

const WASM_PAGE_SIZE: u64 = 64 * 1024; // 64KB per WASM page
const WASM_MAX_PAGES: u64 = 65536; // 4GB max (65536 * 64KB)
const WASM_MAX_BYTES: u64 = WASM_MAX_PAGES * WASM_PAGE_SIZE; // 4GB

/// Returns total available WASM memory (max_memory from build.zig)
fn nativeTotalMem(ctx: ?*qjs.JSContext, _: qjs.JSValue, _: c_int, _: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    // Max memory is 4GB as set in build.zig
    return qjs.JS_NewFloat64(ctx, @floatFromInt(WASM_MAX_BYTES));
}

/// Returns free WASM memory (max - current used)
fn nativeFreeMem(ctx: ?*qjs.JSContext, _: qjs.JSValue, _: c_int, _: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    // Get current memory size in pages via WASM intrinsic
    const current_pages: u64 = @wasmMemorySize(0);
    const current_bytes: u64 = current_pages * WASM_PAGE_SIZE;
    const free_bytes: f64 = @floatFromInt(WASM_MAX_BYTES - current_bytes);
    return qjs.JS_NewFloat64(ctx, free_bytes);
}

/// Returns current WASM memory usage in bytes
fn nativeMemUsage(ctx: ?*qjs.JSContext, _: qjs.JSValue, _: c_int, _: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    const current_pages: u64 = @wasmMemorySize(0);
    const current_bytes: f64 = @floatFromInt(current_pages * WASM_PAGE_SIZE);
    return qjs.JS_NewFloat64(ctx, current_bytes);
}

// ============================================================================
// GPU Native Bindings (WebGPU via sandboxed worker process)
// ============================================================================
// These provide sandboxed GPU compute access. The GPU worker process runs in
// isolation and can be killed without affecting the main runtime.

/// Check if GPU is available
fn nativeGpuAvailable(ctx: ?*qjs.JSContext, _: qjs.JSValue, _: c_int, _: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    const result = gpu_dispatch(GPU_OP_IS_AVAILABLE, 0, 0, 0, 0, 0, 0);
    return qjs.JS_NewBool(ctx, result != 0);
}

/// Create a GPU buffer - returns handle
/// Args: size (number), usage (number)
fn nativeGpuCreateBuffer(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "createBuffer requires size and usage");

    var size: i32 = 0;
    var usage: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &size, argv[0]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid size");
    if (qjs.JS_ToInt32(ctx, &usage, argv[1]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid usage");

    const result = gpu_dispatch(GPU_OP_CREATE_BUFFER, @intCast(size), @intCast(usage), 0, 0, 0, 0);
    if (result < 0) return qjs.JS_ThrowInternalError(ctx, "GPU: Failed to create buffer");
    return qjs.JS_NewInt32(ctx, result);
}

/// Write data to GPU buffer
/// Args: handle (number), offset (number), data (ArrayBuffer)
fn nativeGpuWriteBuffer(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 3) return qjs.JS_ThrowTypeError(ctx, "writeBuffer requires handle, offset, data");

    var handle: i32 = 0;
    var offset: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &handle, argv[0]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid handle");
    if (qjs.JS_ToInt32(ctx, &offset, argv[1]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid offset");

    // Get ArrayBuffer data
    var data_len: usize = 0;
    const data_ptr = qjs.JS_GetArrayBuffer(ctx, &data_len, argv[2]);
    if (data_ptr == null) return qjs.JS_ThrowTypeError(ctx, "data must be ArrayBuffer");

    const result = gpu_dispatch(GPU_OP_WRITE_BUFFER, @intCast(handle), @intCast(offset),
        @intCast(@intFromPtr(data_ptr)), @intCast(data_len), 0, 0);
    if (result < 0) return qjs.JS_ThrowInternalError(ctx, "GPU: Failed to write buffer");
    return qjs.JS_UNDEFINED;
}

/// Read data from GPU buffer
/// Args: handle (number), offset (number), size (number)
fn nativeGpuReadBuffer(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 3) return qjs.JS_ThrowTypeError(ctx, "readBuffer requires handle, offset, size");

    var handle: i32 = 0;
    var offset: i32 = 0;
    var size: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &handle, argv[0]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid handle");
    if (qjs.JS_ToInt32(ctx, &offset, argv[1]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid offset");
    if (qjs.JS_ToInt32(ctx, &size, argv[2]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid size");

    // Allocate buffer for result
    const allocator = global_allocator orelse return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");
    const result_buf = allocator.alloc(u8, @intCast(size)) catch {
        return qjs.JS_ThrowInternalError(ctx, "Out of memory");
    };
    defer allocator.free(result_buf);

    const result = gpu_dispatch(GPU_OP_READ_BUFFER, @intCast(handle), @intCast(offset),
        @intCast(@intFromPtr(result_buf.ptr)), @intCast(size), 0, 0);
    if (result < 0) return qjs.JS_ThrowInternalError(ctx, "GPU: Failed to read buffer");

    // Return as ArrayBuffer
    return qjs.JS_NewArrayBufferCopy(ctx, result_buf.ptr, @intCast(size));
}

/// Destroy a GPU buffer
fn nativeGpuDestroyBuffer(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "destroyBuffer requires handle");

    var handle: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &handle, argv[0]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid handle");

    const result = gpu_dispatch(GPU_OP_DESTROY_BUFFER, @intCast(handle), 0, 0, 0, 0, 0);
    if (result < 0) return qjs.JS_ThrowInternalError(ctx, "GPU: Failed to destroy buffer");
    return qjs.JS_UNDEFINED;
}

/// Create a shader module from WGSL source
/// Args: wgsl (string)
fn nativeGpuCreateShader(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "createShader requires wgsl source");

    var wgsl_len: usize = 0;
    const wgsl_ptr = qjs.JS_ToCStringLen(ctx, &wgsl_len, argv[0]);
    if (wgsl_ptr == null) return qjs.JS_ThrowTypeError(ctx, "invalid wgsl source");
    defer qjs.JS_FreeCString(ctx, wgsl_ptr);

    const result = gpu_dispatch(GPU_OP_CREATE_SHADER_MODULE,
        @intCast(@intFromPtr(wgsl_ptr)), @intCast(wgsl_len), 0, 0, 0, 0);
    if (result < 0) return qjs.JS_ThrowInternalError(ctx, "GPU: Failed to create shader (validation failed?)");
    return qjs.JS_NewInt32(ctx, result);
}

/// Create a compute pipeline
/// Args: shader_handle (number), entry_point (string)
fn nativeGpuCreatePipeline(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "createPipeline requires shader_handle and entry_point");

    var shader_handle: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &shader_handle, argv[0]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid shader_handle");

    var entry_len: usize = 0;
    const entry_ptr = qjs.JS_ToCStringLen(ctx, &entry_len, argv[1]);
    if (entry_ptr == null) return qjs.JS_ThrowTypeError(ctx, "invalid entry_point");
    defer qjs.JS_FreeCString(ctx, entry_ptr);

    const result = gpu_dispatch(GPU_OP_CREATE_COMPUTE_PIPELINE,
        @intCast(shader_handle), @intCast(@intFromPtr(entry_ptr)), @intCast(entry_len), 0, 0, 0);
    if (result < 0) return qjs.JS_ThrowInternalError(ctx, "GPU: Failed to create pipeline");
    return qjs.JS_NewInt32(ctx, result);
}

/// Dispatch compute workgroups
/// Args: x (number), y (number), z (number)
fn nativeGpuDispatch(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 3) return qjs.JS_ThrowTypeError(ctx, "dispatch requires x, y, z workgroup counts");

    var x: i32 = 0;
    var y: i32 = 0;
    var z: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &x, argv[0]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid x");
    if (qjs.JS_ToInt32(ctx, &y, argv[1]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid y");
    if (qjs.JS_ToInt32(ctx, &z, argv[2]) < 0) return qjs.JS_ThrowTypeError(ctx, "invalid z");

    const result = gpu_dispatch(GPU_OP_DISPATCH_WORKGROUPS,
        @intCast(x), @intCast(y), @intCast(z), 0, 0, 0);
    if (result < 0) {
        if (result == -4) return qjs.JS_ThrowInternalError(ctx, "GPU: Dispatch limit exceeded");
        if (result == -5) return qjs.JS_ThrowInternalError(ctx, "GPU: Workgroup limit exceeded");
        return qjs.JS_ThrowInternalError(ctx, "GPU: Dispatch failed");
    }
    return qjs.JS_UNDEFINED;
}

// ============================================================================
// Stdlib Native Bindings (HostArray, HostMap)
// ============================================================================
// These provide ~10x faster data structure operations by using native Zig
// implementations instead of WASM. Values are i32 only (no JS objects).

/// Create a new native array, returns handle
fn nativeArrayNew(ctx: ?*qjs.JSContext, _: qjs.JSValue, _: c_int, _: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    const handle = stdlib_dispatch(STDLIB_OP_ARRAY_NEW, 0, 0, 0, 0);
    if (handle < 0) return qjs.JS_ThrowInternalError(ctx, "Failed to create array");
    return qjs.JS_NewInt32(ctx, handle);
}

/// Push value to array: __edgebox_array_push(handle, value)
fn nativeArrayPush(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "array_push requires handle and value");
    var handle: i32 = 0;
    var value: i32 = 0;
    _ = qjs.JS_ToInt32(ctx, &handle, argv[0]);
    _ = qjs.JS_ToInt32(ctx, &value, argv[1]);
    const result = stdlib_dispatch(STDLIB_OP_ARRAY_PUSH, @intCast(handle), @intCast(value), 0, 0);
    return qjs.JS_NewInt32(ctx, result);
}

/// Pop value from array: __edgebox_array_pop(handle)
fn nativeArrayPop(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "array_pop requires handle");
    var handle: i32 = 0;
    _ = qjs.JS_ToInt32(ctx, &handle, argv[0]);
    const result = stdlib_dispatch(STDLIB_OP_ARRAY_POP, @intCast(handle), 0, 0, 0);
    return qjs.JS_NewInt32(ctx, result);
}

/// Get value at index: __edgebox_array_get(handle, index)
fn nativeArrayGet(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "array_get requires handle and index");
    var handle: i32 = 0;
    var index: i32 = 0;
    _ = qjs.JS_ToInt32(ctx, &handle, argv[0]);
    _ = qjs.JS_ToInt32(ctx, &index, argv[1]);
    const result = stdlib_dispatch(STDLIB_OP_ARRAY_GET, @intCast(handle), @intCast(index), 0, 0);
    return qjs.JS_NewInt32(ctx, result);
}

/// Set value at index: __edgebox_array_set(handle, index, value)
fn nativeArraySet(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 3) return qjs.JS_ThrowTypeError(ctx, "array_set requires handle, index, and value");
    var handle: i32 = 0;
    var index: i32 = 0;
    var value: i32 = 0;
    _ = qjs.JS_ToInt32(ctx, &handle, argv[0]);
    _ = qjs.JS_ToInt32(ctx, &index, argv[1]);
    _ = qjs.JS_ToInt32(ctx, &value, argv[2]);
    const result = stdlib_dispatch(STDLIB_OP_ARRAY_SET, @intCast(handle), @intCast(index), @intCast(value), 0);
    return qjs.JS_NewInt32(ctx, result);
}

/// Get array length: __edgebox_array_len(handle)
fn nativeArrayLen(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "array_len requires handle");
    var handle: i32 = 0;
    _ = qjs.JS_ToInt32(ctx, &handle, argv[0]);
    const result = stdlib_dispatch(STDLIB_OP_ARRAY_LEN, @intCast(handle), 0, 0, 0);
    return qjs.JS_NewInt32(ctx, result);
}

/// Sort array ascending: __edgebox_array_sort(handle)
fn nativeArraySort(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "array_sort requires handle");
    var handle: i32 = 0;
    _ = qjs.JS_ToInt32(ctx, &handle, argv[0]);
    const result = stdlib_dispatch(STDLIB_OP_ARRAY_SORT, @intCast(handle), 0, 0, 0);
    return qjs.JS_NewInt32(ctx, result);
}

/// Sort array descending: __edgebox_array_sort_desc(handle)
fn nativeArraySortDesc(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "array_sort_desc requires handle");
    var handle: i32 = 0;
    _ = qjs.JS_ToInt32(ctx, &handle, argv[0]);
    const result = stdlib_dispatch(STDLIB_OP_ARRAY_SORT_DESC, @intCast(handle), 0, 0, 0);
    return qjs.JS_NewInt32(ctx, result);
}

/// Reverse array: __edgebox_array_reverse(handle)
fn nativeArrayReverse(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "array_reverse requires handle");
    var handle: i32 = 0;
    _ = qjs.JS_ToInt32(ctx, &handle, argv[0]);
    const result = stdlib_dispatch(STDLIB_OP_ARRAY_REVERSE, @intCast(handle), 0, 0, 0);
    return qjs.JS_NewInt32(ctx, result);
}

/// Clear array: __edgebox_array_clear(handle)
fn nativeArrayClear(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "array_clear requires handle");
    var handle: i32 = 0;
    _ = qjs.JS_ToInt32(ctx, &handle, argv[0]);
    const result = stdlib_dispatch(STDLIB_OP_ARRAY_CLEAR, @intCast(handle), 0, 0, 0);
    return qjs.JS_NewInt32(ctx, result);
}

/// Find index of value: __edgebox_array_index_of(handle, value)
fn nativeArrayIndexOf(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "array_index_of requires handle and value");
    var handle: i32 = 0;
    var value: i32 = 0;
    _ = qjs.JS_ToInt32(ctx, &handle, argv[0]);
    _ = qjs.JS_ToInt32(ctx, &value, argv[1]);
    const result = stdlib_dispatch(STDLIB_OP_ARRAY_INDEX_OF, @intCast(handle), @intCast(value), 0, 0);
    return qjs.JS_NewInt32(ctx, result);
}

/// Free array: __edgebox_array_free(handle)
fn nativeArrayFree(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "array_free requires handle");
    var handle: i32 = 0;
    _ = qjs.JS_ToInt32(ctx, &handle, argv[0]);
    const result = stdlib_dispatch(STDLIB_OP_ARRAY_FREE, @intCast(handle), 0, 0, 0);
    return qjs.JS_NewInt32(ctx, result);
}

/// Create a new native map, returns handle
fn nativeMapNew(ctx: ?*qjs.JSContext, _: qjs.JSValue, _: c_int, _: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    const handle = stdlib_dispatch(STDLIB_OP_MAP_NEW, 0, 0, 0, 0);
    if (handle < 0) return qjs.JS_ThrowInternalError(ctx, "Failed to create map");
    return qjs.JS_NewInt32(ctx, handle);
}

/// Set key-value in map: __edgebox_map_set(handle, key, value)
fn nativeMapSet(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 3) return qjs.JS_ThrowTypeError(ctx, "map_set requires handle, key, and value");
    var handle: i32 = 0;
    _ = qjs.JS_ToInt32(ctx, &handle, argv[0]);

    // Get string key
    var key_len: usize = 0;
    const key_ptr = qjs.JS_ToCStringLen(ctx, &key_len, argv[1]);
    if (key_ptr == null) return qjs.JS_ThrowTypeError(ctx, "key must be a string");
    defer qjs.JS_FreeCString(ctx, key_ptr);

    var value: i32 = 0;
    _ = qjs.JS_ToInt32(ctx, &value, argv[2]);

    // Pass string pointer and length to host
    const result = stdlib_dispatch(
        STDLIB_OP_MAP_SET,
        @intCast(handle),
        @intFromPtr(key_ptr),
        @intCast(key_len),
        @intCast(value),
    );
    return qjs.JS_NewInt32(ctx, result);
}

/// Get value for key: __edgebox_map_get(handle, key)
fn nativeMapGet(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "map_get requires handle and key");
    var handle: i32 = 0;
    _ = qjs.JS_ToInt32(ctx, &handle, argv[0]);

    // Get string key
    var key_len: usize = 0;
    const key_ptr = qjs.JS_ToCStringLen(ctx, &key_len, argv[1]);
    if (key_ptr == null) return qjs.JS_ThrowTypeError(ctx, "key must be a string");
    defer qjs.JS_FreeCString(ctx, key_ptr);

    const result = stdlib_dispatch(
        STDLIB_OP_MAP_GET,
        @intCast(handle),
        @intFromPtr(key_ptr),
        @intCast(key_len),
        0,
    );
    return qjs.JS_NewInt32(ctx, result);
}

/// Check if key exists: __edgebox_map_has(handle, key)
fn nativeMapHas(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "map_has requires handle and key");
    var handle: i32 = 0;
    _ = qjs.JS_ToInt32(ctx, &handle, argv[0]);

    // Get string key
    var key_len: usize = 0;
    const key_ptr = qjs.JS_ToCStringLen(ctx, &key_len, argv[1]);
    if (key_ptr == null) return qjs.JS_ThrowTypeError(ctx, "key must be a string");
    defer qjs.JS_FreeCString(ctx, key_ptr);

    const result = stdlib_dispatch(
        STDLIB_OP_MAP_HAS,
        @intCast(handle),
        @intFromPtr(key_ptr),
        @intCast(key_len),
        0,
    );
    return if (result == 1) quickjs.jsTrue() else quickjs.jsFalse();
}

/// Delete key from map: __edgebox_map_delete(handle, key)
fn nativeMapDelete(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "map_delete requires handle and key");
    var handle: i32 = 0;
    _ = qjs.JS_ToInt32(ctx, &handle, argv[0]);

    // Get string key
    var key_len: usize = 0;
    const key_ptr = qjs.JS_ToCStringLen(ctx, &key_len, argv[1]);
    if (key_ptr == null) return qjs.JS_ThrowTypeError(ctx, "key must be a string");
    defer qjs.JS_FreeCString(ctx, key_ptr);

    const result = stdlib_dispatch(
        STDLIB_OP_MAP_DELETE,
        @intCast(handle),
        @intFromPtr(key_ptr),
        @intCast(key_len),
        0,
    );
    return if (result == 1) quickjs.jsTrue() else quickjs.jsFalse();
}

/// Get map size: __edgebox_map_len(handle)
fn nativeMapLen(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "map_len requires handle");
    var handle: i32 = 0;
    _ = qjs.JS_ToInt32(ctx, &handle, argv[0]);
    const result = stdlib_dispatch(STDLIB_OP_MAP_LEN, @intCast(handle), 0, 0, 0);
    return qjs.JS_NewInt32(ctx, result);
}

/// Clear map: __edgebox_map_clear(handle)
fn nativeMapClear(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "map_clear requires handle");
    var handle: i32 = 0;
    _ = qjs.JS_ToInt32(ctx, &handle, argv[0]);
    const result = stdlib_dispatch(STDLIB_OP_MAP_CLEAR, @intCast(handle), 0, 0, 0);
    return qjs.JS_NewInt32(ctx, result);
}

/// Free map: __edgebox_map_free(handle)
fn nativeMapFree(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "map_free requires handle");
    var handle: i32 = 0;
    _ = qjs.JS_ToInt32(ctx, &handle, argv[0]);
    const result = stdlib_dispatch(STDLIB_OP_MAP_FREE, @intCast(handle), 0, 0, 0);
    return qjs.JS_NewInt32(ctx, result);
}

fn nativeIsatty(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return jsBool(false);

    var fd: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &fd, argv[0]) < 0) {
        return jsBool(false);
    }

    return jsBool(wasi_tty.isatty(fd));
}

fn nativeGetTerminalSize(ctx: ?*qjs.JSContext, _: qjs.JSValue, _: c_int, _: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    const size = wasi_tty.getTerminalSize() orelse {
        const obj = qjs.JS_NewObject(ctx);
        _ = qjs.JS_SetPropertyStr(ctx, obj, "rows", qjs.JS_NewInt32(ctx, 24));
        _ = qjs.JS_SetPropertyStr(ctx, obj, "cols", qjs.JS_NewInt32(ctx, 80));
        return obj;
    };

    const obj = qjs.JS_NewObject(ctx);
    _ = qjs.JS_SetPropertyStr(ctx, obj, "rows", qjs.JS_NewInt32(ctx, size.rows));
    _ = qjs.JS_SetPropertyStr(ctx, obj, "cols", qjs.JS_NewInt32(ctx, size.cols));
    return obj;
}

fn nativeReadStdin(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    std.debug.print("[nativeReadStdin] called\n", .{});

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    var max_size: i32 = 1024;
    if (argc >= 1) {
        _ = qjs.JS_ToInt32(ctx, &max_size, argv[0]);
    }
    if (max_size <= 0) max_size = 1024;

    std.debug.print("[nativeReadStdin] about to read (max_size={})\n", .{max_size});

    const line = wasi_tty.readLine(allocator, @intCast(max_size)) catch |err| {
        std.debug.print("[nativeReadStdin] read error\n", .{});
        return qjs.JS_ThrowInternalError(ctx, "read error: %d", @intFromError(err));
    } orelse {
        std.debug.print("[nativeReadStdin] got null\n", .{});
        return qjs.JS_NULL;
    };
    defer allocator.free(line);

    std.debug.print("[nativeReadStdin] got {} bytes\n", .{line.len});
    return qjs.JS_NewStringLen(ctx, line.ptr, line.len);
}

/// Check if stdin has data ready (non-blocking)
fn nativeStdinReady(_: ?*qjs.JSContext, _: qjs.JSValue, _: c_int, _: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    const ready = wasi_tty.stdinReady();
    return if (ready) quickjs.jsTrue() else quickjs.jsFalse();
}

fn nativeSpawn(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "spawn requires command argument");

    const command = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "command must be a string");
    defer freeStringArg(ctx, command);

    // Build full command string with args
    var full_cmd_buf: [4096]u8 = undefined;
    var full_cmd_len: usize = 0;

    // Start with command
    @memcpy(full_cmd_buf[0..command.len], command);
    full_cmd_len = command.len;

    // Add args if present
    if (argc >= 2 and qjs.JS_IsArray(argv[1])) {
        const arr_len_val = qjs.JS_GetPropertyStr(ctx, argv[1], "length");
        var arr_len: i32 = 0;
        _ = qjs.JS_ToInt32(ctx, &arr_len, arr_len_val);
        qjs.JS_FreeValue(ctx, arr_len_val);

        var i: u32 = 0;
        while (i < @as(u32, @intCast(arr_len))) : (i += 1) {
            const elem = qjs.JS_GetPropertyUint32(ctx, argv[1], i);
            defer qjs.JS_FreeValue(ctx, elem);
            if (getStringArg(ctx, elem)) |arg_str| {
                defer freeStringArg(ctx, arg_str);
                const remaining = full_cmd_buf.len - full_cmd_len - 1;
                if (remaining > arg_str.len + 1) {
                    full_cmd_buf[full_cmd_len] = ' ';
                    full_cmd_len += 1;
                    @memcpy(full_cmd_buf[full_cmd_len..][0..arg_str.len], arg_str);
                    full_cmd_len += arg_str.len;
                }
            }
        }
    }

    // Use the real spawn dispatch to execute the command
    const spawn_id = spawn_start(full_cmd_buf[0..full_cmd_len].ptr, @intCast(full_cmd_len), "".ptr, 0);
    if (spawn_id < 0) {
        const obj = qjs.JS_NewObject(ctx);
        _ = qjs.JS_SetPropertyStr(ctx, obj, "status", qjs.JS_NewInt32(ctx, 1));
        _ = qjs.JS_SetPropertyStr(ctx, obj, "stdout", qjs.JS_NewString(ctx, ""));
        _ = qjs.JS_SetPropertyStr(ctx, obj, "stderr", qjs.JS_NewString(ctx, "spawn failed"));
        return obj;
    }

    // Wait for completion (sync spawn - blocks until done)
    var status = spawn_poll(@intCast(spawn_id));
    while (status == 0) {
        status = spawn_poll(@intCast(spawn_id));
    }

    // Get output
    const allocator = global_allocator orelse {
        const obj = qjs.JS_NewObject(ctx);
        _ = qjs.JS_SetPropertyStr(ctx, obj, "status", qjs.JS_NewInt32(ctx, 1));
        _ = qjs.JS_SetPropertyStr(ctx, obj, "stdout", qjs.JS_NewString(ctx, ""));
        _ = qjs.JS_SetPropertyStr(ctx, obj, "stderr", qjs.JS_NewString(ctx, "allocator error"));
        return obj;
    };

    const output_len = spawn_output_len(@intCast(spawn_id));
    if (output_len <= 0) {
        const obj = qjs.JS_NewObject(ctx);
        _ = qjs.JS_SetPropertyStr(ctx, obj, "status", qjs.JS_NewInt32(ctx, 0));
        _ = qjs.JS_SetPropertyStr(ctx, obj, "stdout", qjs.JS_NewString(ctx, ""));
        _ = qjs.JS_SetPropertyStr(ctx, obj, "stderr", qjs.JS_NewString(ctx, ""));
        _ = spawn_free(@intCast(spawn_id));
        return obj;
    }

    const output_buf = allocator.alloc(u8, @intCast(output_len)) catch {
        const obj = qjs.JS_NewObject(ctx);
        _ = qjs.JS_SetPropertyStr(ctx, obj, "status", qjs.JS_NewInt32(ctx, 1));
        _ = qjs.JS_SetPropertyStr(ctx, obj, "stdout", qjs.JS_NewString(ctx, ""));
        _ = qjs.JS_SetPropertyStr(ctx, obj, "stderr", qjs.JS_NewString(ctx, "out of memory"));
        _ = spawn_free(@intCast(spawn_id));
        return obj;
    };
    defer allocator.free(output_buf);

    _ = spawn_output(@intCast(spawn_id), output_buf.ptr);
    _ = spawn_free(@intCast(spawn_id));

    // Parse JSON response: {"exitCode": N, "stdout": "...", "stderr": "..."}
    var parsed = std.json.parseFromSlice(std.json.Value, allocator, output_buf, .{}) catch {
        const obj = qjs.JS_NewObject(ctx);
        _ = qjs.JS_SetPropertyStr(ctx, obj, "status", qjs.JS_NewInt32(ctx, 1));
        _ = qjs.JS_SetPropertyStr(ctx, obj, "stdout", qjs.JS_NewString(ctx, ""));
        _ = qjs.JS_SetPropertyStr(ctx, obj, "stderr", qjs.JS_NewString(ctx, "json parse error"));
        return obj;
    };
    defer parsed.deinit();

    const obj = qjs.JS_NewObject(ctx);

    if (parsed.value == .object) {
        // exitCode -> status
        if (parsed.value.object.get("exitCode")) |exit_code| {
            if (exit_code == .integer) {
                _ = qjs.JS_SetPropertyStr(ctx, obj, "status", qjs.JS_NewInt32(ctx, @intCast(exit_code.integer)));
            }
        }

        // stdout
        if (parsed.value.object.get("stdout")) |stdout_val| {
            if (stdout_val == .string) {
                _ = qjs.JS_SetPropertyStr(ctx, obj, "stdout", qjs.JS_NewStringLen(ctx, stdout_val.string.ptr, stdout_val.string.len));
            }
        }

        // stderr
        if (parsed.value.object.get("stderr")) |stderr_val| {
            if (stderr_val == .string) {
                _ = qjs.JS_SetPropertyStr(ctx, obj, "stderr", qjs.JS_NewStringLen(ctx, stderr_val.string.ptr, stderr_val.string.len));
            }
        }
    }

    return obj;
}

// ============================================================================
// File System Native Bindings
// ============================================================================

/// Read file contents
fn nativeFsRead(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "fs.readFileSync requires path argument");

    const path_raw = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "path must be a string");
    defer freeStringArg(ctx, path_raw);

    const path = translatePath(path_raw);
    // std.debug.print("[nativeFsRead] {s}\n", .{path});

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    const file = std.fs.cwd().openFile(path, .{}) catch {
        return qjs.JS_ThrowInternalError(ctx, "ENOENT: no such file or directory");
    };
    defer file.close();

    const content = file.readToEndAlloc(allocator, 100 * 1024 * 1024) catch {
        return qjs.JS_ThrowInternalError(ctx, "failed to read file");
    };
    defer allocator.free(content);

    return qjs.JS_NewStringLen(ctx, content.ptr, content.len);
}

/// Write data to file
fn nativeFsWrite(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "fs.writeFileSync requires path and data arguments");

    const path_raw = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "path must be a string");
    defer freeStringArg(ctx, path_raw);

    const data = getStringArg(ctx, argv[1]) orelse
        return qjs.JS_ThrowTypeError(ctx, "data must be a string");
    defer freeStringArg(ctx, data);

    const path = translatePath(path_raw);

    // Try to create parent directories first
    if (std.mem.lastIndexOf(u8, path, "/")) |last_slash| {
        if (last_slash > 0) {
            const dir_path = path[0..last_slash];
            std.fs.cwd().makePath(dir_path) catch {};
        }
    }

    // In WASI, open the parent directory first, then create file within it
    if (std.mem.lastIndexOf(u8, path, "/")) |last_slash| {
        if (last_slash > 0) {
            const dir_path = path[0..last_slash];
            const file_name = path[last_slash + 1 ..];

            // Open parent directory via preopened dirs
            var dir = std.fs.cwd().openDir(dir_path, .{}) catch {
                return qjs.JS_ThrowInternalError(ctx, "ENOENT: cannot access directory");
            };
            defer dir.close();

            // Create file in that directory
            const file = dir.createFile(file_name, .{}) catch {
                return qjs.JS_ThrowInternalError(ctx, "ENOENT: cannot create file");
            };
            defer file.close();

            file.writeAll(data) catch {
                return qjs.JS_ThrowInternalError(ctx, "failed to write file data");
            };

            return qjs.JS_UNDEFINED;
        }
    }

    // No slash - create in cwd
    const file = std.fs.cwd().createFile(path, .{}) catch {
        return qjs.JS_ThrowInternalError(ctx, "ENOENT: cannot create file");
    };
    defer file.close();

    file.writeAll(data) catch {
        return qjs.JS_ThrowInternalError(ctx, "failed to write file data");
    };

    return qjs.JS_UNDEFINED;
}

/// Append data to file
fn nativeFsAppend(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "fs.appendFileSync requires path and data arguments");

    const path_raw = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "path must be a string");
    defer freeStringArg(ctx, path_raw);

    const data = getStringArg(ctx, argv[1]) orelse
        return qjs.JS_ThrowTypeError(ctx, "data must be a string");
    defer freeStringArg(ctx, data);

    const path = translatePath(path_raw);
    std.debug.print("[nativeFsAppend] path={s}\n", .{path});

    // Create parent directories if needed
    if (std.mem.lastIndexOf(u8, path, "/")) |last_slash| {
        if (last_slash > 0) {
            const dir_path = path[0..last_slash];
            std.debug.print("[nativeFsAppend] creating dir: {s}\n", .{dir_path});
            std.fs.cwd().makePath(dir_path) catch |err| {
                std.debug.print("[nativeFsAppend] makePath error: {}\n", .{err});
            };
        }
    }

    // In WASI, we must use cwd-relative operations which go through preopened directories
    const file = std.fs.cwd().openFile(path, .{ .mode = .write_only }) catch |err| blk: {
        std.debug.print("[nativeFsAppend] openFile error: {}\n", .{err});
        if (err == error.FileNotFound) {
            break :blk std.fs.cwd().createFile(path, .{}) catch |create_err| {
                std.debug.print("[nativeFsAppend] createFile error: {}\n", .{create_err});
                return qjs.JS_ThrowInternalError(ctx, "ENOENT: cannot create file");
            };
        }
        return qjs.JS_ThrowInternalError(ctx, "ENOENT: cannot open file");
    };
    defer file.close();

    file.seekFromEnd(0) catch {};
    file.writeAll(data) catch {
        return qjs.JS_ThrowInternalError(ctx, "failed to append file data");
    };

    return qjs.JS_UNDEFINED;
}

/// Check if file exists
fn nativeFsExists(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return jsBool(false);

    const path_raw = getStringArg(ctx, argv[0]) orelse return jsBool(false);
    defer freeStringArg(ctx, path_raw);

    const path = translatePath(path_raw);
    std.fs.cwd().access(path, .{}) catch return jsBool(false);
    return jsBool(true);
}

/// Get file stats
fn nativeFsStat(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "fs.statSync requires path argument");

    const path_raw = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "path must be a string");
    defer freeStringArg(ctx, path_raw);

    const path = translatePath(path_raw);
    const stat = std.fs.cwd().statFile(path) catch {
        return qjs.JS_ThrowInternalError(ctx, "ENOENT: no such file or directory");
    };

    const obj = qjs.JS_NewObject(ctx);
    _ = qjs.JS_SetPropertyStr(ctx, obj, "size", qjs.JS_NewInt64(ctx, @intCast(stat.size)));

    const is_dir = stat.kind == .directory;
    const mode: i32 = if (is_dir) 0o40755 else 0o100644;
    _ = qjs.JS_SetPropertyStr(ctx, obj, "mode", qjs.JS_NewInt32(ctx, mode));
    _ = qjs.JS_SetPropertyStr(ctx, obj, "_isDir", jsBool(is_dir));
    _ = qjs.JS_SetPropertyStr(ctx, obj, "_isFile", jsBool(!is_dir));

    // Add isFile/isDirectory methods via eval
    const methods_code =
        \\(function(obj) {
        \\    obj.isFile = function() { return this._isFile; };
        \\    obj.isDirectory = function() { return this._isDir; };
        \\    return obj;
        \\})
    ;
    const methods_fn = qjs.JS_Eval(ctx, methods_code.ptr, methods_code.len, "<stat>", qjs.JS_EVAL_TYPE_GLOBAL);
    if (!qjs.JS_IsException(methods_fn)) {
        var args = [_]qjs.JSValue{obj};
        const result = qjs.JS_Call(ctx, methods_fn, qjs.JS_UNDEFINED, 1, &args);
        qjs.JS_FreeValue(ctx, methods_fn);
        if (!qjs.JS_IsException(result)) {
            return result;
        }
        qjs.JS_FreeValue(ctx, result);
    } else {
        qjs.JS_FreeValue(ctx, methods_fn);
    }

    return obj;
}

/// Read directory entries
fn nativeFsReaddir(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "fs.readdirSync requires path argument");

    const path_raw = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "path must be a string");
    defer freeStringArg(ctx, path_raw);

    const path = translatePath(path_raw);
    var dir = std.fs.cwd().openDir(path, .{ .iterate = true }) catch {
        return qjs.JS_ThrowInternalError(ctx, "ENOENT: no such file or directory");
    };
    defer dir.close();

    const arr = qjs.JS_NewArray(ctx);
    var idx: u32 = 0;

    var iter = dir.iterate();
    while (iter.next() catch null) |entry| {
        const name_val = qjs.JS_NewStringLen(ctx, entry.name.ptr, entry.name.len);
        _ = qjs.JS_SetPropertyUint32(ctx, arr, idx, name_val);
        idx += 1;
    }

    return arr;
}

/// Create directory
fn nativeFsMkdir(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "fs.mkdirSync requires path argument");

    const path_raw = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "path must be a string");
    defer freeStringArg(ctx, path_raw);

    const path = translatePath(path_raw);
    const recursive = if (argc >= 2) qjs.JS_ToBool(ctx, argv[1]) != 0 else false;

    // std.debug.print("[mkdir] path={s} -> {s} recursive={}\n", .{ path_raw, path, recursive });

    if (recursive) {
        std.fs.cwd().makePath(path) catch {
            return qjs.JS_ThrowInternalError(ctx, "failed to create directory");
        };
    } else {
        std.fs.cwd().makeDir(path) catch {
            return qjs.JS_ThrowInternalError(ctx, "failed to create directory");
        };
    }

    return qjs.JS_UNDEFINED;
}

/// Delete file
fn nativeFsUnlink(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "fs.unlinkSync requires path argument");

    const path_raw = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "path must be a string");
    defer freeStringArg(ctx, path_raw);

    const path = translatePath(path_raw);
    std.fs.cwd().deleteFile(path) catch {
        return qjs.JS_ThrowInternalError(ctx, "ENOENT: no such file or directory");
    };

    return qjs.JS_UNDEFINED;
}

/// Delete directory
fn nativeFsRmdir(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "fs.rmdirSync requires path argument");

    const path_raw = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "path must be a string");
    defer freeStringArg(ctx, path_raw);

    const path = translatePath(path_raw);
    const recursive = if (argc >= 2) qjs.JS_ToBool(ctx, argv[1]) != 0 else false;

    if (recursive) {
        std.fs.cwd().deleteTree(path) catch {
            return qjs.JS_ThrowInternalError(ctx, "failed to delete directory");
        };
    } else {
        std.fs.cwd().deleteDir(path) catch {
            return qjs.JS_ThrowInternalError(ctx, "ENOTEMPTY: directory not empty");
        };
    }

    return qjs.JS_UNDEFINED;
}

/// Rename file/directory
fn nativeFsRename(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "fs.renameSync requires oldPath and newPath arguments");

    const old_path_raw = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "oldPath must be a string");
    defer freeStringArg(ctx, old_path_raw);

    // Translate old_path first and copy to temp buffer (since translatePath uses static buffer)
    var old_path_buf: [4096]u8 = undefined;
    const old_path_translated = translatePath(old_path_raw);
    @memcpy(old_path_buf[0..old_path_translated.len], old_path_translated);
    const old_path = old_path_buf[0..old_path_translated.len];

    const new_path_raw = getStringArg(ctx, argv[1]) orelse
        return qjs.JS_ThrowTypeError(ctx, "newPath must be a string");
    defer freeStringArg(ctx, new_path_raw);

    const new_path = translatePath(new_path_raw);

    std.fs.cwd().rename(old_path, new_path) catch {
        return qjs.JS_ThrowInternalError(ctx, "failed to rename");
    };

    return qjs.JS_UNDEFINED;
}

/// Copy file
fn nativeFsCopy(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "fs.copyFileSync requires src and dest arguments");

    const src_raw = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "src must be a string");
    defer freeStringArg(ctx, src_raw);

    // Translate src first and copy to temp buffer (since translatePath uses static buffer)
    var src_buf: [4096]u8 = undefined;
    const src_translated = translatePath(src_raw);
    @memcpy(src_buf[0..src_translated.len], src_translated);
    const src = src_buf[0..src_translated.len];

    const dest_raw = getStringArg(ctx, argv[1]) orelse
        return qjs.JS_ThrowTypeError(ctx, "dest must be a string");
    defer freeStringArg(ctx, dest_raw);

    const dest = translatePath(dest_raw);

    std.fs.cwd().copyFile(src, std.fs.cwd(), dest, .{}) catch {
        return qjs.JS_ThrowInternalError(ctx, "failed to copy file");
    };

    return qjs.JS_UNDEFINED;
}

/// Get current working directory
fn nativeCwd(ctx: ?*qjs.JSContext, _: qjs.JSValue, _: c_int, _: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    // Get PWD from environment via WASI
    const allocator = global_allocator orelse {
        return qjs.JS_NewString(ctx, "/");
    };

    // Get environ from WASI
    var environ_count: usize = 0;
    var environ_buf_size: usize = 0;
    _ = std.os.wasi.environ_sizes_get(&environ_count, &environ_buf_size);

    if (environ_count == 0) {
        return qjs.JS_NewString(ctx, "/");
    }

    const environ_ptrs = allocator.alloc([*:0]u8, environ_count) catch {
        return qjs.JS_NewString(ctx, "/");
    };
    defer allocator.free(environ_ptrs);

    const environ_buf = allocator.alloc(u8, environ_buf_size) catch {
        return qjs.JS_NewString(ctx, "/");
    };
    defer allocator.free(environ_buf);

    _ = std.os.wasi.environ_get(environ_ptrs.ptr, environ_buf.ptr);

    for (environ_ptrs) |env_ptr| {
        const env = std.mem.span(env_ptr);
        if (std.mem.startsWith(u8, env, "PWD=")) {
            const pwd = env[4..];
            return qjs.JS_NewStringLen(ctx, pwd.ptr, pwd.len);
        }
    }

    return qjs.JS_NewString(ctx, "/");
}

/// Get home directory
fn nativeHomedir(ctx: ?*qjs.JSContext, _: qjs.JSValue, _: c_int, _: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    const allocator = global_allocator orelse {
        return qjs.JS_NewString(ctx, "/home/user");
    };

    // Get environ from WASI
    var environ_count: usize = 0;
    var environ_buf_size: usize = 0;
    _ = std.os.wasi.environ_sizes_get(&environ_count, &environ_buf_size);

    if (environ_count == 0) {
        return qjs.JS_NewString(ctx, "/home/user");
    }

    const environ_ptrs = allocator.alloc([*:0]u8, environ_count) catch {
        return qjs.JS_NewString(ctx, "/home/user");
    };
    defer allocator.free(environ_ptrs);

    const environ_buf = allocator.alloc(u8, environ_buf_size) catch {
        return qjs.JS_NewString(ctx, "/home/user");
    };
    defer allocator.free(environ_buf);

    _ = std.os.wasi.environ_get(environ_ptrs.ptr, environ_buf.ptr);

    for (environ_ptrs) |env_ptr| {
        const env = std.mem.span(env_ptr);
        if (std.mem.startsWith(u8, env, "HOME=")) {
            const home = env[5..];
            return qjs.JS_NewStringLen(ctx, home.ptr, home.len);
        }
    }

    return qjs.JS_NewString(ctx, "/home/user");
}

// ============================================================================
// Crypto Native Functions
// ============================================================================

const crypto = std.crypto;

/// Native hash function: __edgebox_hash(algorithm, data) -> hex string
/// Supports: sha256, sha384, sha512, sha1, md5
fn nativeHash(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "hash requires algorithm and data arguments");

    const algorithm = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "algorithm must be a string");
    defer freeStringArg(ctx, algorithm);

    const data = getStringArg(ctx, argv[1]) orelse
        return qjs.JS_ThrowTypeError(ctx, "data must be a string");
    defer freeStringArg(ctx, data);

    // Hash based on algorithm
    if (std.mem.eql(u8, algorithm, "sha256")) {
        var hash: [32]u8 = undefined;
        crypto.hash.sha2.Sha256.hash(data, &hash, .{});
        return hexEncode(ctx, &hash);
    } else if (std.mem.eql(u8, algorithm, "sha384")) {
        var hash: [48]u8 = undefined;
        crypto.hash.sha2.Sha384.hash(data, &hash, .{});
        return hexEncode(ctx, &hash);
    } else if (std.mem.eql(u8, algorithm, "sha512")) {
        var hash: [64]u8 = undefined;
        crypto.hash.sha2.Sha512.hash(data, &hash, .{});
        return hexEncode(ctx, &hash);
    } else if (std.mem.eql(u8, algorithm, "sha1")) {
        var hash: [20]u8 = undefined;
        crypto.hash.Sha1.hash(data, &hash, .{});
        return hexEncode(ctx, &hash);
    } else if (std.mem.eql(u8, algorithm, "md5")) {
        var hash: [16]u8 = undefined;
        crypto.hash.Md5.hash(data, &hash, .{});
        return hexEncode(ctx, &hash);
    } else {
        return qjs.JS_ThrowTypeError(ctx, "unsupported algorithm: use sha256, sha384, sha512, sha1, or md5");
    }
}

/// Native HMAC function: __edgebox_hmac(algorithm, key, data) -> hex string
fn nativeHmac(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 3) return qjs.JS_ThrowTypeError(ctx, "hmac requires algorithm, key, and data arguments");

    const algorithm = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "algorithm must be a string");
    defer freeStringArg(ctx, algorithm);

    const key = getStringArg(ctx, argv[1]) orelse
        return qjs.JS_ThrowTypeError(ctx, "key must be a string");
    defer freeStringArg(ctx, key);

    const data = getStringArg(ctx, argv[2]) orelse
        return qjs.JS_ThrowTypeError(ctx, "data must be a string");
    defer freeStringArg(ctx, data);

    // HMAC based on algorithm
    if (std.mem.eql(u8, algorithm, "sha256")) {
        var out: [32]u8 = undefined;
        const key_ptr: *const [32]u8 = if (key.len >= 32) @ptrCast(key.ptr) else blk: {
            var padded: [32]u8 = undefined;
            @memset(&padded, 0);
            @memcpy(padded[0..key.len], key);
            break :blk &padded;
        };
        crypto.auth.hmac.sha2.HmacSha256.create(&out, data, key_ptr);
        return hexEncode(ctx, &out);
    } else if (std.mem.eql(u8, algorithm, "sha384")) {
        var out: [48]u8 = undefined;
        const key_ptr: *const [48]u8 = if (key.len >= 48) @ptrCast(key.ptr) else blk: {
            var padded: [48]u8 = undefined;
            @memset(&padded, 0);
            @memcpy(padded[0..key.len], key);
            break :blk &padded;
        };
        crypto.auth.hmac.sha2.HmacSha384.create(&out, data, key_ptr);
        return hexEncode(ctx, &out);
    } else if (std.mem.eql(u8, algorithm, "sha512")) {
        var out: [64]u8 = undefined;
        const key_ptr: *const [64]u8 = if (key.len >= 64) @ptrCast(key.ptr) else blk: {
            var padded: [64]u8 = undefined;
            @memset(&padded, 0);
            @memcpy(padded[0..key.len], key);
            break :blk &padded;
        };
        crypto.auth.hmac.sha2.HmacSha512.create(&out, data, key_ptr);
        return hexEncode(ctx, &out);
    } else {
        return qjs.JS_ThrowTypeError(ctx, "unsupported HMAC algorithm: use sha256, sha384, or sha512");
    }
}

// ============================================================================
// WASM Import Native Functions
// ============================================================================

/// Load a WASM module from file path
/// Args: path (string)
/// Returns: 1 on success, 0 on failure
/// Helper to convert bytes to hex string
fn hexEncode(ctx: ?*qjs.JSContext, bytes: []const u8) qjs.JSValue {
    const hex_chars = "0123456789abcdef";
    var hex_buf: [128]u8 = undefined; // Max 64 bytes * 2 = 128 hex chars
    const hex_len = bytes.len * 2;

    if (hex_len > hex_buf.len) {
        return qjs.JS_ThrowInternalError(ctx, "hash too long");
    }

    for (bytes, 0..) |byte, i| {
        hex_buf[i * 2] = hex_chars[byte >> 4];
        hex_buf[i * 2 + 1] = hex_chars[byte & 0x0f];
    }

    return qjs.JS_NewStringLen(ctx, &hex_buf, hex_len);
}
