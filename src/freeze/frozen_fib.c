/*
 * Frozen function: frozen_fib
 * Generated by edgebox-freeze (SSA codegen)
 *
 * Optimizations:
 * - Native int32 arithmetic (no JSValue boxing in hot path)
 * - Direct recursive calls (no runtime dispatch)
 * - No stack simulation
 */

#include "quickjs.h"
#include <stdint.h>

#ifndef likely
#define likely(x) __builtin_expect(!!(x), 1)
#endif
#ifndef unlikely
#define unlikely(x) __builtin_expect(!!(x), 0)
#endif

static JSValue frozen_fib(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv);

static JSValue frozen_fib(JSContext *ctx, JSValueConst this_val,
                   int argc, JSValueConst *argv)
{
    /* Arguments as native int32 */
    int32_t n0;

    if (likely(argc > 0 && JS_VALUE_GET_TAG(argv[0]) == JS_TAG_INT)) {
        n0 = JS_VALUE_GET_INT(argv[0]);
    } else {
        if (argc <= 0) return JS_UNDEFINED;
        if (JS_ToInt32(ctx, &n0, argv[0])) return JS_EXCEPTION;
    }

block_0:;
    if (n0 < 2) {
    } else goto block_2;
block_1:;
        return JS_NewInt32(ctx, n0);
block_2:;
    JSValue _arg0 = JS_NewInt32(ctx, n0 - 1);
    JSValue _res0 = frozen_fib(ctx, JS_UNDEFINED, 1, &_arg0);
    if (unlikely(JS_IsException(_res0))) return JS_EXCEPTION;
    int32_t r0 = JS_VALUE_GET_INT(_res0);
    JSValue _arg1 = JS_NewInt32(ctx, n0 - 2);
    JSValue _res1 = frozen_fib(ctx, JS_UNDEFINED, 1, &_arg1);
    if (unlikely(JS_IsException(_res1))) return JS_EXCEPTION;
    int32_t r1 = JS_VALUE_GET_INT(_res1);
        return JS_NewInt32(ctx, r0 + r1);
}

int frozen_fib_init(JSContext *ctx)
{
    JSValue global = JS_GetGlobalObject(ctx);
    JSValue func = JS_NewCFunction(ctx, frozen_fib, "frozen_fib", 1);
    JS_SetPropertyStr(ctx, global, "frozen_fib", func);
    JS_FreeValue(ctx, global);
    return 0;
}
