diff --git a/quickjs.c b/quickjs.c
index 62f4381..2fe28e7 100644
--- a/quickjs.c
+++ b/quickjs.c
@@ -1291,7 +1291,7 @@ static void js_free_module_def(JSContext *ctx, JSModuleDef *m);
 static void js_mark_module_def(JSRuntime *rt, JSModuleDef *m,
                                JS_MarkFunc *mark_func);
 static JSValue js_import_meta(JSContext *ctx);
-static JSValue js_dynamic_import(JSContext *ctx, JSValueConst specifier);
+JSValue js_dynamic_import(JSContext *ctx, JSValueConst specifier);
 static void free_var_ref(JSRuntime *rt, JSVarRef *var_ref);
 static JSValue js_new_promise_capability(JSContext *ctx,
                                          JSValue *resolving_funcs,
@@ -15134,6 +15134,12 @@ static JSValue js_build_arguments(JSContext *ctx, int argc, JSValueConst *argv)
     return val;
 }
 
+/* Public wrapper for frozen code to create proper arguments object */
+JSValue JS_NewArguments(JSContext *ctx, int argc, JSValueConst *argv)
+{
+    return js_build_arguments(ctx, argc, argv);
+}
+
 #define GLOBAL_VAR_OFFSET 0x40000000
 #define ARGUMENT_VAR_OFFSET 0x20000000
 
@@ -15598,6 +15604,158 @@ static __exception int js_for_of_next(JSContext *ctx, JSValue *sp, int offset)
     return 0;
 }
 
+/* ========================================================================
+ * Wrapper functions for frozen interpreter
+ * ======================================================================== */
+
+/* Iterator helpers */
+int js_frozen_for_in_start(JSContext *ctx, JSValue *sp)
+{
+    return js_for_in_start(ctx, sp);
+}
+
+int js_frozen_for_in_next(JSContext *ctx, JSValue *sp)
+{
+    return js_for_in_next(ctx, sp);
+}
+
+int js_frozen_for_of_start(JSContext *ctx, JSValue *sp, int is_async)
+{
+    return js_for_of_start(ctx, sp, is_async != 0);
+}
+
+int js_frozen_for_of_next(JSContext *ctx, JSValue *sp, int offset)
+{
+    return js_for_of_next(ctx, sp, offset);
+}
+
+/* Closure variable access wrappers */
+JSValue js_frozen_get_var_ref(JSContext *ctx, JSVarRef **var_refs, int idx)
+{
+    (void)ctx;
+    if (!var_refs || !var_refs[idx]) return JS_UNDEFINED;
+    return js_dup(*var_refs[idx]->pvalue);
+}
+
+void js_frozen_set_var_ref(JSContext *ctx, JSVarRef **var_refs, int idx, JSValue val)
+{
+    if (var_refs && var_refs[idx]) {
+        set_value(ctx, var_refs[idx]->pvalue, val);
+    }
+}
+
+/* Home object registry for frozen C functions */
+#define FROZEN_HOME_OBJECT_REGISTRY_SIZE 256
+static struct {
+    void *func_ptr;
+    JSValue home_object;
+} frozen_home_object_registry[FROZEN_HOME_OBJECT_REGISTRY_SIZE];
+static int frozen_home_object_count = 0;
+
+void JS_SetFrozenHomeObject(JSContext *ctx, void *func_ptr, JSValue home_object)
+{
+    (void)ctx;
+    for (int i = 0; i < frozen_home_object_count; i++) {
+        if (frozen_home_object_registry[i].func_ptr == func_ptr) {
+            frozen_home_object_registry[i].home_object = home_object;
+            return;
+        }
+    }
+    if (frozen_home_object_count < FROZEN_HOME_OBJECT_REGISTRY_SIZE) {
+        frozen_home_object_registry[frozen_home_object_count].func_ptr = func_ptr;
+        frozen_home_object_registry[frozen_home_object_count].home_object = home_object;
+        frozen_home_object_count++;
+    }
+}
+
+JSValue JS_GetFrozenHomeObject(JSContext *ctx, void *func_ptr)
+{
+    (void)ctx;
+    for (int i = 0; i < frozen_home_object_count; i++) {
+        if (frozen_home_object_registry[i].func_ptr == func_ptr) {
+            return frozen_home_object_registry[i].home_object;
+        }
+    }
+    return JS_UNDEFINED;
+}
+
+/* import.meta wrapper */
+JSValue JS_GetImportMetaCurrent(JSContext *ctx)
+{
+    return js_import_meta(ctx);
+}
+
+/* Mapped arguments (simplified version for frozen code) */
+JSValue JS_NewMappedArgumentsSimple(JSContext *ctx, int argc, JSValueConst *argv,
+                                    JSValue callee)
+{
+    JSValue args = js_build_arguments(ctx, argc, argv);
+    if (!JS_IsException(args)) {
+        JS_DefinePropertyValue(ctx, args, JS_ATOM_callee, js_dup(callee),
+                               JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE);
+    }
+    return args;
+}
+
+/* Private field wrappers */
+JSValue JS_NewPrivateSymbol(JSContext *ctx, JSAtom atom)
+{
+    return JS_NewSymbolFromAtom(ctx, atom, JS_ATOM_TYPE_PRIVATE);
+}
+
+int JS_FrozenCheckBrand(JSContext *ctx, JSValue obj, JSValue func)
+{
+    return JS_CheckBrand(ctx, obj, func);
+}
+
+int JS_FrozenAddBrand(JSContext *ctx, JSValue obj, JSValue func)
+{
+    return JS_AddBrand(ctx, obj, func);
+}
+
+int js_frozen_private_in(JSContext *ctx, JSValue *sp)
+{
+    return js_operator_private_in(ctx, sp);
+}
+
+/* Private field access wrappers for frozen interpreter */
+JSValue JS_FrozenGetPrivateField(JSContext *ctx, JSValueConst obj, JSValueConst name)
+{
+    return JS_GetPrivateField(ctx, obj, name);
+}
+
+int JS_FrozenSetPrivateField(JSContext *ctx, JSValueConst obj, JSValueConst name, JSValue val)
+{
+    return JS_SetPrivateField(ctx, obj, name, val);
+}
+
+int JS_FrozenDefinePrivateField(JSContext *ctx, JSValueConst obj, JSValue name, JSValue val)
+{
+    return JS_DefinePrivateField(ctx, obj, name, val);
+}
+
+/* Get constant pool from a bytecode function - for frozen interpreter */
+JSValue* JS_GetFunctionConstantPool(JSContext *ctx, JSValueConst func_obj, int *pcount)
+{
+    JSObject *p;
+    JSFunctionBytecode *b;
+
+    if (JS_VALUE_GET_TAG(func_obj) != JS_TAG_OBJECT)
+        return NULL;
+
+    p = JS_VALUE_GET_OBJ(func_obj);
+    if (!js_class_has_bytecode(p->class_id))
+        return NULL;
+
+    b = p->u.func.function_bytecode;
+    if (!b || !b->cpool)
+        return NULL;
+
+    if (pcount)
+        *pcount = b->cpool_count;
+    return b->cpool;
+}
+
 static JSValue JS_IteratorGetCompleteValue(JSContext *ctx, JSValue obj,
                                            int *pdone)
 {
@@ -29006,7 +29164,7 @@ JSValue JS_LoadModule(JSContext *ctx, const char *basename,
     return promise;
 }
 
-static JSValue js_dynamic_import_job(JSContext *ctx,
+JSValue js_dynamic_import_job(JSContext *ctx,
                                      int argc, JSValueConst *argv)
 {
     JSValueConst *resolving_funcs = argv;
@@ -29041,7 +29199,7 @@ static JSValue js_dynamic_import_job(JSContext *ctx,
     return JS_UNDEFINED;
 }
 
-static JSValue js_dynamic_import(JSContext *ctx, JSValueConst specifier)
+JSValue js_dynamic_import(JSContext *ctx, JSValueConst specifier)
 {
     JSAtom basename;
     JSValue promise, resolving_funcs[2], basename_val;
diff --git a/quickjs.h b/quickjs.h
index 3165256..b0cebc0 100644
--- a/quickjs.h
+++ b/quickjs.h
@@ -851,6 +851,7 @@ JS_EXTERN bool JS_IsWeakMap(JSValueConst val);
 JS_EXTERN bool JS_IsDataView(JSValueConst val);
 
 JS_EXTERN JSValue JS_NewArray(JSContext *ctx);
+JS_EXTERN JSValue JS_NewArguments(JSContext *ctx, int argc, JSValueConst *argv);
 // takes ownership of the values
 JS_EXTERN JSValue JS_NewArrayFrom(JSContext *ctx, int count,
                                   const JSValue *values);
@@ -1124,6 +1125,9 @@ JS_EXTERN JSAtom JS_GetScriptOrModuleName(JSContext *ctx, int n_stack_levels);
 /* only exported for os.Worker() */
 JS_EXTERN JSValue JS_LoadModule(JSContext *ctx, const char *basename,
                                 const char *filename);
+/* exported for frozen interpreter dynamic import support */
+JS_EXTERN JSValue js_dynamic_import(JSContext *ctx, JSValueConst specifier);
+JS_EXTERN JSValue js_dynamic_import_job(JSContext *ctx, int argc, JSValueConst *argv);
 
 /* C function definition */
 typedef enum JSCFunctionEnum {  /* XXX: should rename for namespace isolation */
@@ -1291,6 +1295,36 @@ JS_EXTERN const char* JS_GetVersion(void);
 /* Integration point for quickjs-libc.c, not for public use. */
 JS_EXTERN uintptr_t js_std_cmd(int cmd, ...);
 
+/* Frozen interpreter support - iterator helpers */
+JS_EXTERN int js_frozen_for_in_start(JSContext *ctx, JSValue *sp);
+JS_EXTERN int js_frozen_for_in_next(JSContext *ctx, JSValue *sp);
+JS_EXTERN int js_frozen_for_of_start(JSContext *ctx, JSValue *sp, int is_async);
+JS_EXTERN int js_frozen_for_of_next(JSContext *ctx, JSValue *sp, int offset);
+
+/* Frozen interpreter support - closure variable access */
+typedef struct JSVarRef JSVarRef;
+JS_EXTERN JSValue js_frozen_get_var_ref(JSContext *ctx, JSVarRef **var_refs, int idx);
+JS_EXTERN void js_frozen_set_var_ref(JSContext *ctx, JSVarRef **var_refs, int idx, JSValue val);
+
+/* Frozen interpreter support - special object types */
+JS_EXTERN void JS_SetFrozenHomeObject(JSContext *ctx, void *func_ptr, JSValue home_object);
+JS_EXTERN JSValue JS_GetFrozenHomeObject(JSContext *ctx, void *func_ptr);
+JS_EXTERN JSValue JS_GetImportMetaCurrent(JSContext *ctx);
+JS_EXTERN JSValue JS_NewMappedArgumentsSimple(JSContext *ctx, int argc, JSValueConst *argv,
+                                              JSValue callee);
+
+/* Frozen interpreter support - private fields */
+JS_EXTERN JSValue JS_NewPrivateSymbol(JSContext *ctx, JSAtom atom);
+JS_EXTERN int JS_FrozenCheckBrand(JSContext *ctx, JSValue obj, JSValue func);
+JS_EXTERN int JS_FrozenAddBrand(JSContext *ctx, JSValue obj, JSValue func);
+JS_EXTERN int js_frozen_private_in(JSContext *ctx, JSValue *sp);
+JS_EXTERN JSValue JS_FrozenGetPrivateField(JSContext *ctx, JSValueConst obj, JSValueConst name);
+JS_EXTERN int JS_FrozenSetPrivateField(JSContext *ctx, JSValueConst obj, JSValueConst name, JSValue val);
+JS_EXTERN int JS_FrozenDefinePrivateField(JSContext *ctx, JSValueConst obj, JSValue name, JSValue val);
+
+/* Frozen interpreter support - constant pool access */
+JS_EXTERN JSValue* JS_GetFunctionConstantPool(JSContext *ctx, JSValueConst func_obj, int *pcount);
+
 #undef JS_EXTERN
 #undef js_force_inline
 
