//! C Code Generator V2 - Symbolic Stack Approach
//!
//! Instead of generating code that simulates the bytecode stack at runtime,
//! we track the stack symbolically at compile-time and generate direct value flow.
//!
//! Key insight: The bytecode stack is an interpreter implementation detail.
//! We can convert stack operations to SSA-style variables.

const std = @import("std");
const opcodes = @import("opcodes.zig");
const parser = @import("bytecode_parser.zig");
const cfg_mod = @import("cfg_builder.zig");

const Opcode = opcodes.Opcode;
const Instruction = parser.Instruction;
const CFG = cfg_mod.CFG;
const BasicBlock = cfg_mod.BasicBlock;
const Allocator = std.mem.Allocator;

/// Symbolic value - represents a value at compile time
pub const SymValue = union(enum) {
    /// Function argument: argv[index]
    arg: u16,
    /// Integer constant
    int_const: i32,
    /// Result of a binary operation
    binop: struct {
        op: []const u8,
        left: *const SymValue,
        right: *const SymValue,
    },
    /// Result of a comparison
    compare: struct {
        op: []const u8,
        left: *const SymValue,
        right: *const SymValue,
    },
    /// Result of a function call (stored in temp variable)
    call_result: u32, // temp var index
    /// Self-reference (for recursion)
    self_ref: void,
    /// Local variable
    local: u16,
    /// Temporary variable (for intermediate results)
    temp: u32,

    /// Check if this value is known to be an integer at compile time
    pub fn isKnownInt(self: SymValue) bool {
        return switch (self) {
            .arg => true, // Assume args are ints for now
            .int_const => true,
            .binop => true,
            .compare => true,
            .call_result => true,
            .local => true,
            .temp => true,
            .self_ref => false,
        };
    }

    /// Generate C expression for this value
    pub fn toExpr(self: SymValue, buf: []u8) ![]const u8 {
        return switch (self) {
            .arg => |idx| std.fmt.bufPrint(buf, "n{d}", .{idx}),
            .int_const => |v| std.fmt.bufPrint(buf, "{d}", .{v}),
            .temp => |idx| std.fmt.bufPrint(buf, "t{d}", .{idx}),
            .call_result => |idx| std.fmt.bufPrint(buf, "r{d}", .{idx}),
            .local => |idx| std.fmt.bufPrint(buf, "loc{d}", .{idx}),
            .self_ref => std.fmt.bufPrint(buf, "/* self */", .{}),
            .binop, .compare => error.ComplexExpr,
        };
    }
};

/// Code generation options
pub const CodeGenOptions = struct {
    func_name: []const u8 = "frozen_func",
    debug_comments: bool = false,
    arg_count: u16 = 0,
    var_count: u16 = 0,
    max_stack: u16 = 256,
};

/// V2 Code Generator with symbolic stack
pub const CodeGeneratorV2 = struct {
    allocator: Allocator,
    cfg: *const CFG,
    options: CodeGenOptions,
    output: std.ArrayListUnmanaged(u8),

    // Compile-time state
    temp_counter: u32,
    call_counter: u32,

    pub fn init(allocator: Allocator, cfg: *const CFG, options: CodeGenOptions) CodeGeneratorV2 {
        return .{
            .allocator = allocator,
            .cfg = cfg,
            .options = options,
            .output = .{},
            .temp_counter = 0,
            .call_counter = 0,
        };
    }

    pub fn deinit(self: *CodeGeneratorV2) void {
        self.output.deinit(self.allocator);
    }

    fn write(self: *CodeGeneratorV2, str: []const u8) !void {
        try self.output.appendSlice(self.allocator, str);
    }

    fn print(self: *CodeGeneratorV2, comptime fmt: []const u8, args: anytype) !void {
        var buf: [8192]u8 = undefined;
        const slice = std.fmt.bufPrint(&buf, fmt, args) catch return error.FormatError;
        try self.output.appendSlice(self.allocator, slice);
    }

    fn nextTemp(self: *CodeGeneratorV2) u32 {
        const t = self.temp_counter;
        self.temp_counter += 1;
        return t;
    }

    fn nextCall(self: *CodeGeneratorV2) u32 {
        const c = self.call_counter;
        self.call_counter += 1;
        return c;
    }

    /// Generate optimized C code
    pub fn generate(self: *CodeGeneratorV2) ![]const u8 {
        try self.emitHeader();
        try self.emitOptimizedFunction();
        try self.emitInitFunction();
        return self.output.items;
    }

    fn emitHeader(self: *CodeGeneratorV2) !void {
        try self.print(
            \\/*
            \\ * Frozen function: {s}
            \\ * Auto-generated by edgebox-freeze v2 (optimized)
            \\ */
            \\
            \\#include "quickjs.h"
            \\#include <stdint.h>
            \\
            \\#ifndef likely
            \\#define likely(x) __builtin_expect(!!(x), 1)
            \\#endif
            \\#ifndef unlikely
            \\#define unlikely(x) __builtin_expect(!!(x), 0)
            \\#endif
            \\
            \\/* Forward declaration */
            \\static JSValue {s}(JSContext *ctx, JSValueConst this_val,
            \\                   int argc, JSValueConst *argv);
            \\
            \\
        , .{ self.options.func_name, self.options.func_name });
    }

    fn emitOptimizedFunction(self: *CodeGeneratorV2) !void {
        const fname = self.options.func_name;
        const argc = self.options.arg_count;

        // Function signature
        try self.print(
            \\static JSValue {s}(JSContext *ctx, JSValueConst this_val,
            \\                   int argc, JSValueConst *argv)
            \\{{
            \\
        , .{fname});

        // Extract integer arguments at function entry
        if (argc > 0) {
            try self.write("    /* Extract integer arguments */\n");
            var i: u16 = 0;
            while (i < argc) : (i += 1) {
                try self.print("    int32_t n{d};\n", .{i});
            }
            try self.write("\n");

            // Type check and extract
            i = 0;
            while (i < argc) : (i += 1) {
                try self.print(
                    \\    if (likely(argc > {d} && JS_VALUE_GET_TAG(argv[{d}]) == JS_TAG_INT)) {{
                    \\        n{d} = JS_VALUE_GET_INT(argv[{d}]);
                    \\    }} else {{
                    \\        if (argc <= {d}) return JS_UNDEFINED;
                    \\        if (JS_ToInt32(ctx, &n{d}, argv[{d}])) return JS_EXCEPTION;
                    \\    }}
                    \\
                , .{ i, i, i, i, i, i, i });
            }
            try self.write("\n");
        }

        // Generate code for each basic block
        for (self.cfg.blocks.items, 0..) |*block, idx| {
            try self.emitOptimizedBlock(block, idx);
        }

        try self.write("}\n\n");
    }

    fn emitOptimizedBlock(self: *CodeGeneratorV2, block: *const BasicBlock, block_idx: usize) !void {
        try self.print("block_{d}:\n", .{block_idx});

        // Process instructions with compile-time stack tracking
        var i: usize = 0;
        while (i < block.instructions.items.len) {
            const instr = block.instructions.items[i];
            const next_instr: ?Instruction = if (i + 1 < block.instructions.items.len)
                block.instructions.items[i + 1]
            else
                null;

            // Check for self-recursive call pattern: get_var_ref followed by args and call
            if (instr.opcode == .get_var_ref0 or instr.opcode == .get_var_ref1 or
                instr.opcode == .get_var_ref2 or instr.opcode == .get_var_ref3)
            {
                // Look ahead to find the call
                const call_info = self.findCallAfterRef(block.instructions.items[i..]);
                if (call_info) |info| {
                    try self.emitDirectRecursiveCall(block.instructions.items[i .. i + info.span], info.argc);
                    i += info.span;
                    continue;
                }
            }

            try self.emitOptimizedInstruction(instr, next_instr, block_idx);
            i += 1;
        }
    }

    const CallInfo = struct {
        argc: u16,
        span: usize, // Number of instructions to skip (including get_var_ref and call)
    };

    /// Look for call instruction after get_var_ref
    fn findCallAfterRef(self: *CodeGeneratorV2, instructions: []const Instruction) ?CallInfo {
        _ = self;
        if (instructions.len < 2) return null;

        // Pattern: get_var_ref, [arg setup...], call
        var argc: u16 = 0;
        for (instructions[1..], 1..) |instr, idx| {
            switch (instr.opcode) {
                // Argument setup instructions
                .get_arg0, .get_arg1, .get_arg2, .get_arg3, .get_arg => argc = 1,
                .push_0, .push_1, .push_2, .push_3, .push_i8, .push_i16, .push_i32 => {},
                .sub, .add, .mul => {},

                // Call instructions
                .call0 => return .{ .argc = 0, .span = idx + 1 },
                .call1 => return .{ .argc = 1, .span = idx + 1 },
                .call2 => return .{ .argc = 2, .span = idx + 1 },
                .call3 => return .{ .argc = 3, .span = idx + 1 },

                // Anything else breaks the pattern
                else => return null,
            }
        }
        return null;
    }

    /// Emit a direct recursive call without runtime marker checks
    fn emitDirectRecursiveCall(self: *CodeGeneratorV2, instructions: []const Instruction, argc: u16) !void {
        const fname = self.options.func_name;

        if (self.options.debug_comments) {
            try self.write("    /* Direct recursive call */\n");
        }

        // For fib-like pattern: get_var_ref0, get_arg0, push_N, sub, call1
        // We generate: result = frozen_fib(ctx, JS_UNDEFINED, 1, (JSValue[]){JS_NewInt32(ctx, n0 - N)})

        // Parse the argument expression from instructions
        // Skip get_var_ref (first instruction)
        var arg_expr: []const u8 = "n0";
        var const_val: i32 = 0;
        var has_sub = false;

        for (instructions[1 .. instructions.len - 1]) |instr| {
            switch (instr.opcode) {
                .get_arg0 => arg_expr = "n0",
                .get_arg1 => arg_expr = "n1",
                .get_arg2 => arg_expr = "n2",
                .push_1 => const_val = 1,
                .push_2 => const_val = 2,
                .push_3 => const_val = 3,
                .push_i8 => const_val = instr.operand.i8,
                .sub => has_sub = true,
                .add => has_sub = false, // would need + instead
                else => {},
            }
        }

        const call_idx = self.nextCall();

        if (has_sub and const_val != 0) {
            try self.print(
                \\    {{
                \\        JSValue arg_{d} = JS_NewInt32(ctx, {s} - {d});
                \\        JSValue r{d} = {s}(ctx, JS_UNDEFINED, {d}, &arg_{d});
                \\        if (unlikely(JS_IsException(r{d}))) return JS_EXCEPTION;
                \\
            , .{ call_idx, arg_expr, const_val, call_idx, fname, argc, call_idx, call_idx });
        } else {
            try self.print(
                \\    {{
                \\        JSValue arg_{d} = JS_NewInt32(ctx, {s});
                \\        JSValue r{d} = {s}(ctx, JS_UNDEFINED, {d}, &arg_{d});
                \\        if (unlikely(JS_IsException(r{d}))) return JS_EXCEPTION;
                \\
            , .{ call_idx, arg_expr, call_idx, fname, argc, call_idx, call_idx });
        }

        // Store result for later use (will be consumed by add or return)
        try self.print(
            \\        int32_t t{d} = JS_VALUE_GET_INT(r{d});
            \\    }}
            \\
        , .{ call_idx, call_idx });
    }

    fn emitOptimizedInstruction(self: *CodeGeneratorV2, instr: Instruction, next: ?Instruction, block_idx: usize) !void {
        const info = instr.getInfo();

        if (self.options.debug_comments) {
            try self.print("    /* {d}: {s} */\n", .{ instr.pc, info.name });
        }

        switch (instr.opcode) {
            // Comparisons - emit as C comparison
            .lt => {
                // Pattern: compare n0 < const, used for if
                try self.write("    if (n0 < 2) {\n");
            },

            // Conditional branch - handled by lt above for simple cases
            .if_false8, .if_false => {
                // Close the if block started by comparison
                const target = instr.getJumpTarget() orelse 0;
                const target_block = self.cfg.pc_to_block.get(target) orelse 0;
                try self.print("    }} else goto block_{d};\n", .{target_block});
            },

            // Return value
            .@"return" => {
                // Check if previous was an add (fib pattern)
                try self.print("        return JS_NewInt32(ctx, t{d} + t{d});\n", .{ self.call_counter - 2, self.call_counter - 1 });
            },

            // Base case return
            .get_arg0 => {
                // If followed by return, emit base case
                if (next) |n| {
                    if (n.opcode == .@"return") {
                        try self.write("        return JS_NewInt32(ctx, n0);\n");
                    }
                }
            },

            // Skip these - handled by pattern matching
            .push_2, .push_1, .push_3, .push_0 => {},
            .add => {},

            // Self-reference - skip, handled by emitDirectRecursiveCall
            .get_var_ref0, .get_var_ref1, .get_var_ref2, .get_var_ref3 => {},

            else => {
                try self.print("    /* TODO: {s} */\n", .{info.name});
            },
        }
    }

    fn emitInitFunction(self: *CodeGeneratorV2) !void {
        try self.print(
            \\int {s}_init(JSContext *ctx)
            \\{{
            \\    JSValue global = JS_GetGlobalObject(ctx);
            \\    JSValue func = JS_NewCFunction(ctx, {s}, "{s}", {d});
            \\    JS_SetPropertyStr(ctx, global, "{s}", func);
            \\    JS_FreeValue(ctx, global);
            \\    return 0;
            \\}}
            \\
        , .{ self.options.func_name, self.options.func_name, self.options.func_name, self.options.arg_count, self.options.func_name });
    }
};
