/// EdgeBox Static WASM Entry Point
/// Executes pre-compiled bytecode from qjsc (embedded at build time)
///
/// Build pipeline:
///   1. qjsc -s -N bundle bundle.js > bundle_compiled.c
///   2. zig build wasm-static (compiles bundle_compiled.c with QuickJS)
///   3. wizer (pre-initializes runtime)
///   4. wasmedge --compile (AOT)
///
/// This eliminates JS parsing entirely - bytecode is loaded directly.
const std = @import("std");
const quickjs = @import("quickjs_core.zig");
const wasm_fetch = @import("wasm_fetch.zig");
const wasi_tty = @import("wasi_tty.zig");
const wasi_process = @import("wasi_process.zig");
const node_polyfills = @import("node_polyfills.zig");
const wizer_mod = @import("wizer_init.zig");

// ============================================================================
// External bytecode from bundle_compiled.c (generated by qjsc)
// ============================================================================

// Import C symbols from bundle_compiled.c
// The C file declares: const uint32_t bundle_size; const uint8_t bundle[];
extern fn get_bundle_ptr() callconv(.c) [*]const u8;
extern fn get_bundle_size() callconv(.c) u32;

// We need to provide these C bridge functions since Zig can't directly import C arrays
// They'll be added to bundle_compiled.c by the build process

// ============================================================================
// Wizer Pre-initialization Export
// ============================================================================

export fn wizer_init() void {
    wizer_mod.wizer_init();
}

// ============================================================================
// Main Entry Point
// ============================================================================

// Global allocator for native bindings
var global_allocator: ?std.mem.Allocator = null;

// Startup timing for cold start measurement
var startup_time_ns: i128 = 0;

/// Get current time in nanoseconds (WASI clock)
fn getTimeNs() i128 {
    if (@import("builtin").target.os.tag == .wasi) {
        var ts: u64 = undefined;
        const rc = std.os.wasi.clock_time_get(.MONOTONIC, 1, &ts);
        if (rc == .SUCCESS) {
            return @as(i128, ts);
        }
    }
    return std.time.nanoTimestamp();
}

pub fn main() !void {
    startup_time_ns = getTimeNs();

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();
    global_allocator = allocator;

    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    // Check for benchmark/cold-start flags
    for (args) |arg| {
        if (std.mem.eql(u8, arg, "--cold-start") or std.mem.eql(u8, arg, "--benchmark")) {
            const end_time = getTimeNs();
            const startup_ms = @as(f64, @floatFromInt(end_time - startup_time_ns)) / 1_000_000.0;
            const wizer_status = if (wizer_mod.isWizerInitialized()) " (Wizer+Static)" else " (Static)";
            std.debug.print("Cold start{s}: {d:.2}ms\n", .{ wizer_status, startup_ms });
            if (std.mem.eql(u8, arg, "--cold-start")) return;
            break;
        }
    }

    // WIZER FAST PATH: Use pre-initialized runtime
    if (wizer_mod.isWizerInitialized()) {
        runWithWizerRuntime(args) catch |err| {
            std.debug.print("Static runtime error: {}\n", .{err});
            std.process.exit(1);
        };
        std.process.exit(0);
    }

    // SLOW PATH: Initialize runtime and run bytecode
    var runtime = try quickjs.Runtime.init(allocator);
    defer runtime.deinit();

    // Convert args to C-style for js_std_add_helpers
    var c_argv = try allocator.alloc([*c]u8, args.len);
    defer allocator.free(c_argv);
    for (args, 0..) |arg, i| {
        c_argv[i] = @constCast(@ptrCast(arg.ptr));
    }

    var context = try runtime.newStdContextWithArgs(@intCast(c_argv.len), c_argv.ptr);
    defer context.deinit();

    // Register native bindings and polyfills
    registerNativeBindings(&context);
    importStdModules(&context) catch {};

    // Execute pre-compiled bytecode
    try executeBytecode(&context);
}

// ============================================================================
// Wizer Fast Path
// ============================================================================

const qjs = quickjs.c;

fn runWithWizerRuntime(args: []const [:0]u8) !void {
    const ctx = wizer_mod.getContext() orelse return error.WizerNotInitialized;

    // FAST PATH: Skip js_std_add_helpers and use minimal setup
    // js_std_add_helpers is slow because it does a lot of internal setup
    // We only need: scriptArgs for process.argv

    // Set scriptArgs for QuickJS (used by process.argv)
    const global = qjs.JS_GetGlobalObject(ctx);
    defer qjs.JS_FreeValue(ctx, global);

    const script_args = qjs.JS_NewArray(ctx);
    var idx: u32 = 0;
    for (args) |arg| {
        const str = qjs.JS_NewStringLen(ctx, arg.ptr, arg.len);
        _ = qjs.JS_SetPropertyUint32(ctx, script_args, idx, str);
        idx += 1;
    }
    _ = qjs.JS_SetPropertyStr(ctx, global, "scriptArgs", script_args);

    // Minimal print function (required for console.log)
    const print_func = qjs.JS_NewCFunction(ctx, printNative, "print", 1);
    _ = qjs.JS_SetPropertyStr(ctx, global, "print", print_func);

    // Register native bindings
    registerWizerNativeBindings(ctx);

    // Execute pre-compiled bytecode
    try executeBytecodeRaw(ctx);
}

/// Native print function (minimal, replaces js_std_add_helpers version)
fn printNative(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    var i: usize = 0;
    var nwritten: usize = 0;
    while (i < @as(usize, @intCast(argc))) : (i += 1) {
        if (i > 0) {
            const space_iov = [_]std.os.wasi.ciovec_t{.{ .base = " ", .len = 1 }};
            _ = std.os.wasi.fd_write(1, &space_iov, 1, &nwritten);
        }
        var len: usize = undefined;
        const str = qjs.JS_ToCStringLen(ctx, &len, argv[i]);
        if (str != null) {
            const str_iov = [_]std.os.wasi.ciovec_t{.{ .base = str, .len = len }};
            _ = std.os.wasi.fd_write(1, &str_iov, 1, &nwritten);
            qjs.JS_FreeCString(ctx, str);
        }
    }
    const nl_iov = [_]std.os.wasi.ciovec_t{.{ .base = "\n", .len = 1 }};
    _ = std.os.wasi.fd_write(1, &nl_iov, 1, &nwritten);
    return qjs.JS_UNDEFINED;
}

/// Execute bytecode using Context wrapper
fn executeBytecode(context: *quickjs.Context) !void {
    const ctx = context.inner;

    // Get bytecode pointer and size from C bridge functions
    const bytecode_ptr = get_bundle_ptr();
    const bytecode_len = get_bundle_size();

    // Load bytecode object
    const func = qjs.JS_ReadObject(ctx, bytecode_ptr, bytecode_len, qjs.JS_READ_OBJ_BYTECODE);
    if (qjs.JS_IsException(func)) {
        std.debug.print("Failed to load bytecode\n", .{});
        if (context.getException()) |exc| {
            defer exc.free();
            if (exc.toStringSlice()) |msg| {
                std.debug.print("Exception: {s}\n", .{msg});
            }
        }
        return error.BytecodeLoadFailed;
    }

    // Execute the bytecode
    const result = qjs.JS_EvalFunction(ctx, func);
    if (qjs.JS_IsException(result)) {
        std.debug.print("Bytecode execution failed\n", .{});
        if (context.getException()) |exc| {
            defer exc.free();
            if (exc.toStringSlice()) |msg| {
                std.debug.print("Exception: {s}\n", .{msg});
            }
        }
        return error.ExecutionFailed;
    }
    qjs.JS_FreeValue(ctx, result);
}

/// Execute bytecode using raw JSContext (Wizer path)
fn executeBytecodeRaw(ctx: *qjs.JSContext) !void {
    const bytecode_ptr = get_bundle_ptr();
    const bytecode_len = get_bundle_size();

    const func = qjs.JS_ReadObject(ctx, bytecode_ptr, bytecode_len, qjs.JS_READ_OBJ_BYTECODE);
    if (qjs.JS_IsException(func)) {
        printWizerException(ctx);
        return error.BytecodeLoadFailed;
    }

    const result = qjs.JS_EvalFunction(ctx, func);
    if (qjs.JS_IsException(result)) {
        printWizerException(ctx);
        return error.ExecutionFailed;
    }
    qjs.JS_FreeValue(ctx, result);
}

// ============================================================================
// Bindings and Polyfills
// ============================================================================

/// Bind dynamic state (process.argv, process.env)
fn bindDynamicState(ctx: *qjs.JSContext, args: []const [:0]u8) void {
    const dynamic_init =
        \\globalThis.process = globalThis.process || {};
        \\globalThis.process.version = 'v20.0.0';
        \\globalThis.process.versions = { node: '20.0.0' };
        \\globalThis.process.platform = 'wasi';
        \\globalThis.process.arch = 'wasm32';
        \\globalThis.process.exit = (code) => { if (typeof std !== 'undefined') std.exit(code || 0); };
        \\globalThis.process.cwd = () => std.getenv('PWD') || '/';
        \\globalThis.process.env = new Proxy({}, {
        \\    get(t, n) { return typeof n === 'symbol' ? undefined : std.getenv(String(n)); },
        \\    has(t, n) { return typeof n !== 'symbol' && std.getenv(String(n)) !== undefined; }
        \\});
        \\import * as std from 'std';
        \\globalThis.std = std;
    ;

    const val = qjs.JS_Eval(ctx, dynamic_init.ptr, dynamic_init.len, "<dynamic>", qjs.JS_EVAL_TYPE_MODULE);
    if (qjs.JS_IsException(val)) {
        std.debug.print("Dynamic init failed\n", .{});
        printWizerException(ctx);
    }
    qjs.JS_FreeValue(ctx, val);

    // Set process.argv
    const global = qjs.JS_GetGlobalObject(ctx);
    defer qjs.JS_FreeValue(ctx, global);

    const process = qjs.JS_GetPropertyStr(ctx, global, "process");
    defer qjs.JS_FreeValue(ctx, process);

    const argv_arr = qjs.JS_NewArray(ctx);
    var idx: u32 = 0;

    const node_str = qjs.JS_NewString(ctx, "node");
    _ = qjs.JS_SetPropertyUint32(ctx, argv_arr, idx, node_str);
    idx += 1;

    for (args[1..]) |arg| {
        const str = qjs.JS_NewStringLen(ctx, arg.ptr, arg.len);
        _ = qjs.JS_SetPropertyUint32(ctx, argv_arr, idx, str);
        idx += 1;
    }

    _ = qjs.JS_SetPropertyStr(ctx, process, "argv", argv_arr);
}

/// Register native bindings for Wizer context
fn registerWizerNativeBindings(ctx: *qjs.JSContext) void {
    const global = qjs.JS_GetGlobalObject(ctx);
    defer qjs.JS_FreeValue(ctx, global);

    inline for (.{
        .{ "__edgebox_fetch", nativeFetch, 4 },
        .{ "__edgebox_isatty", nativeIsatty, 1 },
        .{ "__edgebox_get_terminal_size", nativeGetTerminalSize, 0 },
        .{ "__edgebox_read_stdin", nativeReadStdin, 1 },
        .{ "__edgebox_spawn", nativeSpawn, 4 },
    }) |binding| {
        const func = qjs.JS_NewCFunction(ctx, binding[1], binding[0], binding[2]);
        _ = qjs.JS_SetPropertyStr(ctx, global, binding[0], func);
    }
}

/// Register native bindings using Context wrapper
fn registerNativeBindings(context: *quickjs.Context) void {
    context.registerGlobalFunction("__edgebox_fetch", nativeFetch, 4);
    context.registerGlobalFunction("__edgebox_isatty", nativeIsatty, 1);
    context.registerGlobalFunction("__edgebox_get_terminal_size", nativeGetTerminalSize, 0);
    context.registerGlobalFunction("__edgebox_read_stdin", nativeReadStdin, 1);
    context.registerGlobalFunction("__edgebox_spawn", nativeSpawn, 4);
}

/// Import std/os modules
fn importStdModules(context: *quickjs.Context) !void {
    const module_imports =
        \\import * as std from 'std';
        \\import * as os from 'os';
        \\globalThis.std = std;
        \\globalThis._os = os;
    ;

    _ = context.evalModule(module_imports, "<imports>") catch |err| {
        std.debug.print("Failed to import modules: {}\n", .{err});
        return err;
    };
}

/// Print exception (Wizer path)
fn printWizerException(ctx: *qjs.JSContext) void {
    const exc = qjs.JS_GetException(ctx);
    defer qjs.JS_FreeValue(ctx, exc);

    var len: usize = undefined;
    const cstr = qjs.JS_ToCStringLen(ctx, &len, exc);
    if (cstr != null) {
        std.debug.print("Exception: {s}\n", .{cstr[0..len]});
        qjs.JS_FreeCString(ctx, cstr);
    }
}

// ============================================================================
// Native Binding Implementations (same as wasm_main.zig)
// ============================================================================

inline fn jsBool(val: bool) qjs.JSValue {
    return if (val) qjs.JS_TRUE else qjs.JS_FALSE;
}

fn getStringArg(ctx: ?*qjs.JSContext, val: qjs.JSValue) ?[]const u8 {
    var len: usize = undefined;
    const cstr = qjs.JS_ToCStringLen(ctx, &len, val);
    if (cstr == null) return null;
    return cstr[0..len];
}

fn freeStringArg(ctx: ?*qjs.JSContext, str: []const u8) void {
    qjs.JS_FreeCString(ctx, str.ptr);
}

fn nativeFetch(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "fetch requires url argument");

    const url = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "url must be a string");
    defer freeStringArg(ctx, url);

    const method = if (argc >= 2) getStringArg(ctx, argv[1]) orelse "GET" else "GET";
    const method_owned = argc >= 2 and getStringArg(ctx, argv[1]) != null;
    defer if (method_owned) freeStringArg(ctx, method);

    const body = if (argc >= 4 and !qjs.JS_IsUndefined(argv[3]) and !qjs.JS_IsNull(argv[3]))
        getStringArg(ctx, argv[3])
    else
        null;
    defer if (body) |b| freeStringArg(ctx, b);

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    var response = wasm_fetch.jsFetch(allocator, url, method, null, body) catch |err| {
        return switch (err) {
            wasm_fetch.FetchError.InvalidUrl => qjs.JS_ThrowTypeError(ctx, "Invalid URL"),
            wasm_fetch.FetchError.ConnectionFailed => qjs.JS_ThrowInternalError(ctx, "Connection failed"),
            wasm_fetch.FetchError.HostNotFound => qjs.JS_ThrowInternalError(ctx, "Host not found"),
            wasm_fetch.FetchError.Timeout => qjs.JS_ThrowInternalError(ctx, "Request timed out"),
            wasm_fetch.FetchError.InvalidResponse => qjs.JS_ThrowInternalError(ctx, "Invalid HTTP response"),
            wasm_fetch.FetchError.OutOfMemory => qjs.JS_ThrowInternalError(ctx, "Out of memory"),
            wasm_fetch.FetchError.TlsNotSupported => qjs.JS_ThrowInternalError(ctx, "HTTPS not supported"),
        };
    };
    defer response.deinit();

    const obj = qjs.JS_NewObject(ctx);
    _ = qjs.JS_SetPropertyStr(ctx, obj, "status", qjs.JS_NewInt32(ctx, @intCast(response.status)));
    _ = qjs.JS_SetPropertyStr(ctx, obj, "ok", jsBool(response.status >= 200 and response.status < 300));
    _ = qjs.JS_SetPropertyStr(ctx, obj, "body", qjs.JS_NewStringLen(ctx, response.body.ptr, response.body.len));

    const headers_obj = qjs.JS_NewObject(ctx);
    for (response.headers.items) |h| {
        var key_buf: [256]u8 = undefined;
        if (h.name.len < key_buf.len) {
            @memcpy(key_buf[0..h.name.len], h.name);
            key_buf[h.name.len] = 0;
            _ = qjs.JS_SetPropertyStr(ctx, headers_obj, &key_buf, qjs.JS_NewStringLen(ctx, h.value.ptr, h.value.len));
        }
    }
    _ = qjs.JS_SetPropertyStr(ctx, obj, "headers", headers_obj);

    return obj;
}

fn nativeIsatty(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return jsBool(false);

    var fd: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &fd, argv[0]) < 0) {
        return jsBool(false);
    }

    return jsBool(wasi_tty.isatty(fd));
}

fn nativeGetTerminalSize(ctx: ?*qjs.JSContext, _: qjs.JSValue, _: c_int, _: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    const size = wasi_tty.getTerminalSize() orelse {
        const obj = qjs.JS_NewObject(ctx);
        _ = qjs.JS_SetPropertyStr(ctx, obj, "rows", qjs.JS_NewInt32(ctx, 24));
        _ = qjs.JS_SetPropertyStr(ctx, obj, "cols", qjs.JS_NewInt32(ctx, 80));
        return obj;
    };

    const obj = qjs.JS_NewObject(ctx);
    _ = qjs.JS_SetPropertyStr(ctx, obj, "rows", qjs.JS_NewInt32(ctx, size.rows));
    _ = qjs.JS_SetPropertyStr(ctx, obj, "cols", qjs.JS_NewInt32(ctx, size.cols));
    return obj;
}

fn nativeReadStdin(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    var max_size: i32 = 1024;
    if (argc >= 1) {
        _ = qjs.JS_ToInt32(ctx, &max_size, argv[0]);
    }
    if (max_size <= 0) max_size = 1024;

    const line = wasi_tty.readLine(allocator, @intCast(max_size)) catch |err| {
        return qjs.JS_ThrowInternalError(ctx, "read error: %d", @intFromError(err));
    } orelse {
        return qjs.JS_NULL;
    };
    defer allocator.free(line);

    return qjs.JS_NewStringLen(ctx, line.ptr, line.len);
}

fn nativeSpawn(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "spawn requires command argument");

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    const command = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "command must be a string");
    defer freeStringArg(ctx, command);

    var cmd = wasi_process.Command.init(allocator, command);
    defer cmd.deinit();

    // Parse args array
    if (argc >= 2 and qjs.JS_IsArray(argv[1])) {
        const arr_len_val = qjs.JS_GetPropertyStr(ctx, argv[1], "length");
        var arr_len: i32 = 0;
        _ = qjs.JS_ToInt32(ctx, &arr_len, arr_len_val);
        qjs.JS_FreeValue(ctx, arr_len_val);

        var i: u32 = 0;
        while (i < @as(u32, @intCast(arr_len))) : (i += 1) {
            const elem = qjs.JS_GetPropertyUint32(ctx, argv[1], i);
            defer qjs.JS_FreeValue(ctx, elem);

            if (getStringArg(ctx, elem)) |arg_str| {
                const arg_copy = allocator.dupe(u8, arg_str) catch {
                    return qjs.JS_ThrowInternalError(ctx, "out of memory");
                };
                freeStringArg(ctx, arg_str);
                _ = cmd.arg(arg_copy) catch {
                    allocator.free(arg_copy);
                    return qjs.JS_ThrowInternalError(ctx, "out of memory");
                };
            }
        }
    }

    // Set stdin
    if (argc >= 3 and !qjs.JS_IsNull(argv[2]) and !qjs.JS_IsUndefined(argv[2])) {
        if (getStringArg(ctx, argv[2])) |stdin_data| {
            _ = cmd.setStdin(stdin_data);
        }
    }

    // Set timeout
    if (argc >= 4) {
        var timeout: i32 = 30000;
        _ = qjs.JS_ToInt32(ctx, &timeout, argv[3]);
        if (timeout > 0) {
            _ = cmd.setTimeout(@intCast(timeout));
        }
    }

    var result = cmd.output() catch |err| {
        return switch (err) {
            wasi_process.ProcessError.CommandFailed => qjs.JS_ThrowInternalError(ctx, "Command failed"),
            wasi_process.ProcessError.TimedOut => qjs.JS_ThrowInternalError(ctx, "Command timed out"),
            wasi_process.ProcessError.OutOfMemory => qjs.JS_ThrowInternalError(ctx, "Out of memory"),
            wasi_process.ProcessError.InvalidCommand => qjs.JS_ThrowTypeError(ctx, "Invalid command"),
            wasi_process.ProcessError.PermissionDenied => qjs.JS_ThrowTypeError(ctx, "Permission denied: command not in allowed list"),
        };
    };
    defer result.deinit();

    const obj = qjs.JS_NewObject(ctx);
    _ = qjs.JS_SetPropertyStr(ctx, obj, "exitCode", qjs.JS_NewInt32(ctx, result.exit_code));

    if (result.stdout.len > 0) {
        _ = qjs.JS_SetPropertyStr(ctx, obj, "stdout", qjs.JS_NewStringLen(ctx, result.stdout.ptr, result.stdout.len));
    } else {
        _ = qjs.JS_SetPropertyStr(ctx, obj, "stdout", qjs.JS_NewString(ctx, ""));
    }

    if (result.stderr.len > 0) {
        _ = qjs.JS_SetPropertyStr(ctx, obj, "stderr", qjs.JS_NewStringLen(ctx, result.stderr.ptr, result.stderr.len));
    } else {
        _ = qjs.JS_SetPropertyStr(ctx, obj, "stderr", qjs.JS_NewString(ctx, ""));
    }

    return obj;
}
