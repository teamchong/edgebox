/// EdgeBox Static WASM Entry Point
/// Executes pre-compiled bytecode from qjsc (embedded at build time)
///
/// Build pipeline:
///   1. qjsc -s -N bundle bundle.js > bundle_compiled.c
///   2. zig build wasm-static (compiles bundle_compiled.c with QuickJS)
///   3. wizer (pre-initializes runtime)
///   4. wasmedge --compile (AOT)
///
/// This eliminates JS parsing entirely - bytecode is loaded directly.
const std = @import("std");
const quickjs = @import("quickjs_core.zig");
const wasm_fetch = @import("wasm_fetch.zig");
const wasi_tty = @import("wasi_tty.zig");
const wasi_process = @import("wasi_process.zig");
const node_polyfills = @import("node_polyfills.zig");
const wizer_mod = @import("wizer_init.zig");

// ============================================================================
// External bytecode from bundle_compiled.c (generated by qjsc)
// ============================================================================

// Import C symbols from bundle_compiled.c
// The C file declares: const uint32_t bundle_size; const uint8_t bundle[];
extern fn get_bundle_ptr() callconv(.c) [*]const u8;
extern fn get_bundle_size() callconv(.c) u32;

// We need to provide these C bridge functions since Zig can't directly import C arrays
// They'll be added to bundle_compiled.c by the build process

// ============================================================================
// Wizer Pre-initialization Export
// ============================================================================

export fn wizer_init() void {
    wizer_mod.wizer_init();
}

// ============================================================================
// Main Entry Point
// ============================================================================

// Global allocator for native bindings
var global_allocator: ?std.mem.Allocator = null;

// Startup timing for cold start measurement
var startup_time_ns: i128 = 0;

/// Get current time in nanoseconds (WASI clock)
fn getTimeNs() i128 {
    if (@import("builtin").target.os.tag == .wasi) {
        var ts: u64 = undefined;
        const rc = std.os.wasi.clock_time_get(.MONOTONIC, 1, &ts);
        if (rc == .SUCCESS) {
            return @as(i128, ts);
        }
    }
    return std.time.nanoTimestamp();
}

// Debug flag - check for EDGEBOX_DEBUG env var
var debug_enabled: bool = false;

fn debugPrint(comptime fmt: []const u8, args: anytype) void {
    if (debug_enabled) {
        std.debug.print("[EDGEBOX DEBUG] " ++ fmt, args);
    }
}

pub fn main() !void {
    startup_time_ns = getTimeNs();

    // Check debug mode early via WASI environ
    if (@import("builtin").target.os.tag == .wasi) {
        var environ_count: usize = 0;
        var environ_buf_size: usize = 0;
        _ = std.os.wasi.environ_sizes_get(&environ_count, &environ_buf_size);
        // For simplicity, we'll enable debug if any arg is --debug
    }

    // Use page_allocator for WASM - GPA's invalid free detection causes issues
    // with large JS bundles that may have quirky memory patterns in QuickJS
    const allocator = std.heap.page_allocator;
    global_allocator = allocator;

    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    // Check for debug and benchmark/cold-start flags
    for (args) |arg| {
        if (std.mem.eql(u8, arg, "--debug")) {
            debug_enabled = true;
        }
        if (std.mem.eql(u8, arg, "--cold-start") or std.mem.eql(u8, arg, "--benchmark")) {
            const end_time = getTimeNs();
            const startup_ms = @as(f64, @floatFromInt(end_time - startup_time_ns)) / 1_000_000.0;
            const wizer_status = if (wizer_mod.isWizerInitialized()) " (Wizer+Static)" else " (Static)";
            std.debug.print("Cold start{s}: {d:.2}ms\n", .{ wizer_status, startup_ms });
            if (std.mem.eql(u8, arg, "--cold-start")) return;
            break;
        }
    }

    debugPrint("Starting EdgeBox Static WASM\n", .{});
    debugPrint("Args count: {d}\n", .{args.len});
    for (args, 0..) |arg, i| {
        debugPrint("  arg[{d}]: {s}\n", .{ i, arg });
    }

    // WIZER FAST PATH: Use pre-initialized runtime
    const wizer_initialized = wizer_mod.isWizerInitialized();
    debugPrint("Wizer initialized: {}\n", .{wizer_initialized});

    if (wizer_initialized) {
        debugPrint("Using Wizer fast path\n", .{});
        runWithWizerRuntime(args) catch |err| {
            std.debug.print("Static runtime error: {}\n", .{err});
            std.process.exit(1);
        };
        debugPrint("Wizer execution completed successfully\n", .{});
        std.process.exit(0);
    }

    // SLOW PATH: Initialize runtime and run bytecode
    var runtime = try quickjs.Runtime.init(allocator);
    defer runtime.deinit();

    // Convert args to C-style for js_std_add_helpers
    var c_argv = try allocator.alloc([*c]u8, args.len);
    defer allocator.free(c_argv);
    for (args, 0..) |arg, i| {
        c_argv[i] = @constCast(@ptrCast(arg.ptr));
    }

    var context = try runtime.newStdContextWithArgs(@intCast(c_argv.len), c_argv.ptr);
    defer context.deinit();

    // Register native bindings and polyfills
    registerNativeBindings(&context);
    importStdModules(&context) catch {};

    // Execute pre-compiled bytecode
    try executeBytecode(&context);
}

// ============================================================================
// Wizer Fast Path
// ============================================================================

const qjs = quickjs.c;

fn runWithWizerRuntime(args: []const [:0]u8) !void {
    debugPrint("runWithWizerRuntime: Getting Wizer context\n", .{});
    const ctx = wizer_mod.getContext() orelse {
        debugPrint("runWithWizerRuntime: Wizer context is null!\n", .{});
        return error.WizerNotInitialized;
    };
    debugPrint("runWithWizerRuntime: Got context at {*}\n", .{ctx});

    // CRITICAL: Initialize std handlers FIRST, before any JS code runs
    // This sets up the event loop handlers needed for os.setTimeout
    const rt = qjs.JS_GetRuntime(ctx);
    debugPrint("runWithWizerRuntime: Initializing std handlers for event loop\n", .{});
    qjs.js_std_init_handlers(rt);

    // FAST PATH: Skip js_std_add_helpers and use minimal setup
    // js_std_add_helpers is slow because it does a lot of internal setup
    // We only need: scriptArgs for process.argv

    // Set scriptArgs for QuickJS (used by process.argv)
    debugPrint("runWithWizerRuntime: Setting up scriptArgs\n", .{});
    const global = qjs.JS_GetGlobalObject(ctx);
    defer qjs.JS_FreeValue(ctx, global);

    const script_args = qjs.JS_NewArray(ctx);
    var idx: u32 = 0;
    for (args) |arg| {
        const str = qjs.JS_NewStringLen(ctx, arg.ptr, arg.len);
        _ = qjs.JS_SetPropertyUint32(ctx, script_args, idx, str);
        idx += 1;
    }
    _ = qjs.JS_SetPropertyStr(ctx, global, "scriptArgs", script_args);
    debugPrint("runWithWizerRuntime: scriptArgs set with {d} args\n", .{idx});

    // Minimal print function (required for console.log)
    debugPrint("runWithWizerRuntime: Registering print function\n", .{});
    const print_func = qjs.JS_NewCFunction(ctx, printNative, "print", 1);
    _ = qjs.JS_SetPropertyStr(ctx, global, "print", print_func);

    // Register native bindings
    debugPrint("runWithWizerRuntime: Registering native bindings\n", .{});
    registerWizerNativeBindings(ctx);

    // Import std/os modules - CRITICAL for polyfills to work
    // The polyfills use std.loadFile, std.open, std.getenv, _os.stat etc.
    debugPrint("runWithWizerRuntime: Importing std/os modules\n", .{});
    importWizerStdModules(ctx);

    // Initialize Node.js polyfills (fs, process, os, path, etc.)
    // CRITICAL: This must be called before bytecode so require("fs") works
    debugPrint("runWithWizerRuntime: Initializing Node.js polyfills\n", .{});
    initWizerPolyfills(ctx);

    // Execute pre-compiled bytecode
    debugPrint("runWithWizerRuntime: Executing bytecode\n", .{});
    try executeBytecodeRaw(ctx);
    debugPrint("runWithWizerRuntime: Bytecode execution completed\n", .{});
}

/// Native print function (minimal, replaces js_std_add_helpers version)
fn printNative(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    var i: usize = 0;
    var nwritten: usize = 0;
    while (i < @as(usize, @intCast(argc))) : (i += 1) {
        if (i > 0) {
            const space_iov = [_]std.os.wasi.ciovec_t{.{ .base = " ", .len = 1 }};
            _ = std.os.wasi.fd_write(1, &space_iov, 1, &nwritten);
        }
        var len: usize = undefined;
        const str = qjs.JS_ToCStringLen(ctx, &len, argv[i]);
        if (str != null) {
            const str_iov = [_]std.os.wasi.ciovec_t{.{ .base = str, .len = len }};
            _ = std.os.wasi.fd_write(1, &str_iov, 1, &nwritten);
            qjs.JS_FreeCString(ctx, str);
        }
    }
    const nl_iov = [_]std.os.wasi.ciovec_t{.{ .base = "\n", .len = 1 }};
    _ = std.os.wasi.fd_write(1, &nl_iov, 1, &nwritten);
    return qjs.JS_UNDEFINED;
}

/// Execute bytecode using Context wrapper
fn executeBytecode(context: *quickjs.Context) !void {
    const ctx = context.inner;

    // Get bytecode pointer and size from C bridge functions
    const bytecode_ptr = get_bundle_ptr();
    const bytecode_len = get_bundle_size();

    // Load bytecode object
    const func = qjs.JS_ReadObject(ctx, bytecode_ptr, bytecode_len, qjs.JS_READ_OBJ_BYTECODE);
    if (qjs.JS_IsException(func)) {
        std.debug.print("Failed to load bytecode\n", .{});
        if (context.getException()) |exc| {
            defer exc.free();
            if (exc.toStringSlice()) |msg| {
                std.debug.print("Exception: {s}\n", .{msg});
            }
        }
        return error.BytecodeLoadFailed;
    }

    // Execute the bytecode
    const result = qjs.JS_EvalFunction(ctx, func);
    if (qjs.JS_IsException(result)) {
        std.debug.print("Bytecode execution failed\n", .{});
        if (context.getException()) |exc| {
            defer exc.free();
            if (exc.toStringSlice()) |msg| {
                std.debug.print("Exception: {s}\n", .{msg});
            }
        }
        return error.ExecutionFailed;
    }
    qjs.JS_FreeValue(ctx, result);
}

/// Execute bytecode using raw JSContext (Wizer path)
fn executeBytecodeRaw(ctx: *qjs.JSContext) !void {
    debugPrint("executeBytecodeRaw: Getting bytecode pointer\n", .{});
    const bytecode_ptr = get_bundle_ptr();
    const bytecode_len = get_bundle_size();
    debugPrint("executeBytecodeRaw: Bytecode at {*}, size={d} bytes\n", .{ bytecode_ptr, bytecode_len });

    if (bytecode_len == 0) {
        std.debug.print("ERROR: Bytecode is empty (0 bytes)!\n", .{});
        return error.BytecodeLoadFailed;
    }

    debugPrint("executeBytecodeRaw: Loading bytecode object\n", .{});
    const func = qjs.JS_ReadObject(ctx, bytecode_ptr, bytecode_len, qjs.JS_READ_OBJ_BYTECODE);
    if (qjs.JS_IsException(func)) {
        std.debug.print("ERROR: Failed to load bytecode (JS_ReadObject returned exception)\n", .{});
        printWizerException(ctx);
        return error.BytecodeLoadFailed;
    }
    debugPrint("executeBytecodeRaw: Bytecode loaded successfully\n", .{});

    debugPrint("executeBytecodeRaw: Executing bytecode via JS_EvalFunction\n", .{});
    const result = qjs.JS_EvalFunction(ctx, func);
    if (qjs.JS_IsException(result)) {
        std.debug.print("ERROR: Bytecode execution failed (JS_EvalFunction returned exception)\n", .{});
        printWizerException(ctx);
        return error.ExecutionFailed;
    }
    debugPrint("executeBytecodeRaw: Execution completed without exception\n", .{});
    qjs.JS_FreeValue(ctx, result);

    // Run pending Promise jobs (microtasks) first
    // This is critical because js_std_loop may return early if there are no timers/I/O
    {
        const rt = qjs.JS_GetRuntime(ctx);
        var pending_ctx: ?*qjs.JSContext = null;
        while (qjs.JS_ExecutePendingJob(rt, &pending_ctx) > 0) {}
    }

    // Run the standard event loop for async operations
    // This handles timers, promises, and I/O events
    // Note: js_std_init_handlers was already called in runWithWizerRuntime
    debugPrint("executeBytecodeRaw: Starting js_std_loop event loop\n", .{});
    const loop_result = qjs.js_std_loop(ctx);
    if (loop_result != 0) {
        debugPrint("executeBytecodeRaw: js_std_loop returned error: {d}\n", .{loop_result});
    }
    debugPrint("executeBytecodeRaw: Event loop completed\n", .{});
}

// ============================================================================
// Bindings and Polyfills
// ============================================================================

/// Bind dynamic state (process.argv, process.env)
fn bindDynamicState(ctx: *qjs.JSContext, args: []const [:0]u8) void {
    const dynamic_init =
        \\globalThis.process = globalThis.process || {};
        \\globalThis.process.version = 'v20.0.0';
        \\globalThis.process.versions = { node: '20.0.0' };
        \\globalThis.process.platform = 'wasi';
        \\globalThis.process.arch = 'wasm32';
        \\globalThis.process.exit = (code) => { if (typeof std !== 'undefined') std.exit(code || 0); };
        \\globalThis.process.cwd = () => std.getenv('PWD') || '/';
        \\globalThis.process.env = new Proxy({}, {
        \\    get(t, n) { return typeof n === 'symbol' ? undefined : std.getenv(String(n)); },
        \\    has(t, n) { return typeof n !== 'symbol' && std.getenv(String(n)) !== undefined; }
        \\});
        \\import * as std from 'std';
        \\globalThis.std = std;
    ;

    const val = qjs.JS_Eval(ctx, dynamic_init.ptr, dynamic_init.len, "<dynamic>", qjs.JS_EVAL_TYPE_MODULE);
    if (qjs.JS_IsException(val)) {
        std.debug.print("Dynamic init failed\n", .{});
        printWizerException(ctx);
    }
    qjs.JS_FreeValue(ctx, val);

    // Set process.argv
    const global = qjs.JS_GetGlobalObject(ctx);
    defer qjs.JS_FreeValue(ctx, global);

    const process = qjs.JS_GetPropertyStr(ctx, global, "process");
    defer qjs.JS_FreeValue(ctx, process);

    const argv_arr = qjs.JS_NewArray(ctx);
    var idx: u32 = 0;

    const node_str = qjs.JS_NewString(ctx, "node");
    _ = qjs.JS_SetPropertyUint32(ctx, argv_arr, idx, node_str);
    idx += 1;

    for (args[1..]) |arg| {
        const str = qjs.JS_NewStringLen(ctx, arg.ptr, arg.len);
        _ = qjs.JS_SetPropertyUint32(ctx, argv_arr, idx, str);
        idx += 1;
    }

    _ = qjs.JS_SetPropertyStr(ctx, process, "argv", argv_arr);
}

/// Register native bindings for Wizer context
fn registerWizerNativeBindings(ctx: *qjs.JSContext) void {
    const global = qjs.JS_GetGlobalObject(ctx);
    defer qjs.JS_FreeValue(ctx, global);

    inline for (.{
        .{ "__edgebox_fetch", nativeFetch, 4 },
        .{ "__edgebox_isatty", nativeIsatty, 1 },
        .{ "__edgebox_get_terminal_size", nativeGetTerminalSize, 0 },
        .{ "__edgebox_read_stdin", nativeReadStdin, 1 },
        .{ "__edgebox_spawn", nativeSpawn, 4 },
        // fs bindings
        .{ "__edgebox_fs_read", nativeFsRead, 1 },
        .{ "__edgebox_fs_write", nativeFsWrite, 2 },
        .{ "__edgebox_fs_exists", nativeFsExists, 1 },
        .{ "__edgebox_fs_stat", nativeFsStat, 1 },
        .{ "__edgebox_fs_readdir", nativeFsReaddir, 1 },
        .{ "__edgebox_fs_mkdir", nativeFsMkdir, 2 },
        .{ "__edgebox_fs_unlink", nativeFsUnlink, 1 },
        .{ "__edgebox_fs_rmdir", nativeFsRmdir, 2 },
        .{ "__edgebox_fs_rename", nativeFsRename, 2 },
        .{ "__edgebox_fs_copy", nativeFsCopy, 2 },
        .{ "__edgebox_cwd", nativeCwd, 0 },
        .{ "__edgebox_homedir", nativeHomedir, 0 },
        // crypto bindings
        .{ "__edgebox_hash", nativeHash, 2 },
        .{ "__edgebox_hmac", nativeHmac, 3 },
    }) |binding| {
        const func = qjs.JS_NewCFunction(ctx, binding[1], binding[0], binding[2]);
        _ = qjs.JS_SetPropertyStr(ctx, global, binding[0], func);
    }
}

/// Import std/os modules for Wizer path (raw JSContext)
/// CRITICAL: This must be called before bytecode execution so polyfills can use std/os
fn importWizerStdModules(ctx: *qjs.JSContext) void {
    const module_imports =
        \\import * as std from 'std';
        \\import * as os from 'os';
        \\globalThis.std = std;
        \\globalThis._os = os;
    ;

    const result = qjs.JS_Eval(
        ctx,
        module_imports.ptr,
        module_imports.len,
        "<std-import>",
        qjs.JS_EVAL_TYPE_MODULE,
    );

    if (qjs.JS_IsException(result)) {
        debugPrint("importWizerStdModules: Failed to import std/os modules\n", .{});
        printWizerException(ctx);
    } else {
        qjs.JS_FreeValue(ctx, result);
        debugPrint("importWizerStdModules: std/os modules imported successfully\n", .{});
    }
}

/// Bind dynamic state to Wizer-snapshotted polyfills (runtime)
/// Most polyfills are pre-loaded by Wizer at build time. This only binds:
/// 1. process.argv/env (from WASI runtime)
/// 2. fs module (needs std.loadFile and _os.stat from QuickJS modules)
fn initWizerPolyfills(ctx: *qjs.JSContext) void {
    debugPrint("initWizerPolyfills: Binding dynamic state to Wizer polyfills\n", .{});

    // Minimal runtime bindings - bind WASI functions to pre-defined fs module
    const runtime_bindings =
        \\// === Bind dynamic process.env from WASI ===
        \\(function() {
        \\    var g = globalThis, p = g.process, m = g._modules;
        \\    if (typeof std !== 'undefined' && std.getenv) {
        \\        p.env.HOME = std.getenv('HOME') || '/';
        \\        p.env.PWD = std.getenv('PWD') || '/';
        \\        p.env.PATH = std.getenv('PATH') || '/usr/bin';
        \\        p.env.USER = std.getenv('USER') || 'root';
        \\    }
        \\    p.argv = ['node'].concat(g.scriptArgs || []);
        \\    // Bind WASI to pre-defined fs stub
        \\    var fs = m['fs'];
        \\    fs._std = std; fs._os = _os;
        \\    m['node:fs'] = fs;
        \\    m['fs/promises'] = fs.promises;
        \\    m['node:fs/promises'] = fs.promises;
        \\})();
    ;

    const result = qjs.JS_Eval(
        ctx,
        runtime_bindings.ptr,
        runtime_bindings.len,
        "<runtime-bindings>",
        qjs.JS_EVAL_TYPE_GLOBAL,
    );

    if (qjs.JS_IsException(result)) {
        debugPrint("initWizerPolyfills: Failed to bind runtime state\n", .{});
        printWizerException(ctx);
    } else {
        qjs.JS_FreeValue(ctx, result);
        debugPrint("initWizerPolyfills: Runtime bindings complete\n", .{});
    }
}

/// Register native bindings using Context wrapper
fn registerNativeBindings(context: *quickjs.Context) void {
    context.registerGlobalFunction("__edgebox_fetch", nativeFetch, 4);
    context.registerGlobalFunction("__edgebox_isatty", nativeIsatty, 1);
    context.registerGlobalFunction("__edgebox_get_terminal_size", nativeGetTerminalSize, 0);
    context.registerGlobalFunction("__edgebox_read_stdin", nativeReadStdin, 1);
    context.registerGlobalFunction("__edgebox_spawn", nativeSpawn, 4);
    // fs bindings
    context.registerGlobalFunction("__edgebox_fs_read", nativeFsRead, 1);
    context.registerGlobalFunction("__edgebox_fs_write", nativeFsWrite, 2);
    context.registerGlobalFunction("__edgebox_fs_exists", nativeFsExists, 1);
    context.registerGlobalFunction("__edgebox_fs_stat", nativeFsStat, 1);
    context.registerGlobalFunction("__edgebox_fs_readdir", nativeFsReaddir, 1);
    context.registerGlobalFunction("__edgebox_fs_mkdir", nativeFsMkdir, 2);
    context.registerGlobalFunction("__edgebox_fs_unlink", nativeFsUnlink, 1);
    context.registerGlobalFunction("__edgebox_fs_rmdir", nativeFsRmdir, 2);
    context.registerGlobalFunction("__edgebox_fs_rename", nativeFsRename, 2);
    context.registerGlobalFunction("__edgebox_fs_copy", nativeFsCopy, 2);
    context.registerGlobalFunction("__edgebox_cwd", nativeCwd, 0);
    context.registerGlobalFunction("__edgebox_homedir", nativeHomedir, 0);
}

/// Import std/os modules
fn importStdModules(context: *quickjs.Context) !void {
    const module_imports =
        \\import * as std from 'std';
        \\import * as os from 'os';
        \\globalThis.std = std;
        \\globalThis._os = os;
    ;

    _ = context.evalModule(module_imports, "<imports>") catch |err| {
        std.debug.print("Failed to import modules: {}\n", .{err});
        return err;
    };
}

/// Print exception (Wizer path) with full stack trace
fn printWizerException(ctx: *qjs.JSContext) void {
    const exc = qjs.JS_GetException(ctx);
    defer qjs.JS_FreeValue(ctx, exc);

    // Get exception message
    var len: usize = undefined;
    const cstr = qjs.JS_ToCStringLen(ctx, &len, exc);
    if (cstr != null) {
        std.debug.print("Exception: {s}\n", .{cstr[0..len]});
        qjs.JS_FreeCString(ctx, cstr);
    } else {
        std.debug.print("Exception: (unable to convert to string)\n", .{});
    }

    // Try to get stack trace
    const stack_prop = qjs.JS_GetPropertyStr(ctx, exc, "stack");
    defer qjs.JS_FreeValue(ctx, stack_prop);

    if (!qjs.JS_IsUndefined(stack_prop) and !qjs.JS_IsNull(stack_prop)) {
        var stack_len: usize = undefined;
        const stack_cstr = qjs.JS_ToCStringLen(ctx, &stack_len, stack_prop);
        if (stack_cstr != null) {
            std.debug.print("Stack trace:\n{s}\n", .{stack_cstr[0..stack_len]});
            qjs.JS_FreeCString(ctx, stack_cstr);
        }
    }

    // Try to get the exception name/type
    const name_prop = qjs.JS_GetPropertyStr(ctx, exc, "name");
    defer qjs.JS_FreeValue(ctx, name_prop);

    if (!qjs.JS_IsUndefined(name_prop) and !qjs.JS_IsNull(name_prop)) {
        var name_len: usize = undefined;
        const name_cstr = qjs.JS_ToCStringLen(ctx, &name_len, name_prop);
        if (name_cstr != null) {
            std.debug.print("Exception type: {s}\n", .{name_cstr[0..name_len]});
            qjs.JS_FreeCString(ctx, name_cstr);
        }
    }
}

// ============================================================================
// Native Binding Implementations (same as wasm_main.zig)
// ============================================================================

inline fn jsBool(val: bool) qjs.JSValue {
    return if (val) qjs.JS_TRUE else qjs.JS_FALSE;
}

fn getStringArg(ctx: ?*qjs.JSContext, val: qjs.JSValue) ?[]const u8 {
    var len: usize = undefined;
    const cstr = qjs.JS_ToCStringLen(ctx, &len, val);
    if (cstr == null) return null;
    return cstr[0..len];
}

fn freeStringArg(ctx: ?*qjs.JSContext, str: []const u8) void {
    qjs.JS_FreeCString(ctx, str.ptr);
}

fn nativeFetch(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "fetch requires url argument");

    const url = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "url must be a string");
    defer freeStringArg(ctx, url);

    const method = if (argc >= 2) getStringArg(ctx, argv[1]) orelse "GET" else "GET";
    const method_owned = argc >= 2 and getStringArg(ctx, argv[1]) != null;
    defer if (method_owned) freeStringArg(ctx, method);

    const body = if (argc >= 4 and !qjs.JS_IsUndefined(argv[3]) and !qjs.JS_IsNull(argv[3]))
        getStringArg(ctx, argv[3])
    else
        null;
    defer if (body) |b| freeStringArg(ctx, b);

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    var response = wasm_fetch.jsFetch(allocator, url, method, null, body) catch |err| {
        return switch (err) {
            wasm_fetch.FetchError.InvalidUrl => qjs.JS_ThrowTypeError(ctx, "Invalid URL"),
            wasm_fetch.FetchError.ConnectionFailed => qjs.JS_ThrowInternalError(ctx, "Connection failed"),
            wasm_fetch.FetchError.HostNotFound => qjs.JS_ThrowInternalError(ctx, "Host not found"),
            wasm_fetch.FetchError.Timeout => qjs.JS_ThrowInternalError(ctx, "Request timed out"),
            wasm_fetch.FetchError.InvalidResponse => qjs.JS_ThrowInternalError(ctx, "Invalid HTTP response"),
            wasm_fetch.FetchError.OutOfMemory => qjs.JS_ThrowInternalError(ctx, "Out of memory"),
            wasm_fetch.FetchError.TlsNotSupported => qjs.JS_ThrowInternalError(ctx, "HTTPS not supported"),
        };
    };
    defer response.deinit();

    const obj = qjs.JS_NewObject(ctx);
    _ = qjs.JS_SetPropertyStr(ctx, obj, "status", qjs.JS_NewInt32(ctx, @intCast(response.status)));
    _ = qjs.JS_SetPropertyStr(ctx, obj, "ok", jsBool(response.status >= 200 and response.status < 300));
    _ = qjs.JS_SetPropertyStr(ctx, obj, "body", qjs.JS_NewStringLen(ctx, response.body.ptr, response.body.len));

    const headers_obj = qjs.JS_NewObject(ctx);
    for (response.headers.items) |h| {
        var key_buf: [256]u8 = undefined;
        if (h.name.len < key_buf.len) {
            @memcpy(key_buf[0..h.name.len], h.name);
            key_buf[h.name.len] = 0;
            _ = qjs.JS_SetPropertyStr(ctx, headers_obj, &key_buf, qjs.JS_NewStringLen(ctx, h.value.ptr, h.value.len));
        }
    }
    _ = qjs.JS_SetPropertyStr(ctx, obj, "headers", headers_obj);

    return obj;
}

fn nativeIsatty(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return jsBool(false);

    var fd: i32 = 0;
    if (qjs.JS_ToInt32(ctx, &fd, argv[0]) < 0) {
        return jsBool(false);
    }

    return jsBool(wasi_tty.isatty(fd));
}

fn nativeGetTerminalSize(ctx: ?*qjs.JSContext, _: qjs.JSValue, _: c_int, _: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    const size = wasi_tty.getTerminalSize() orelse {
        const obj = qjs.JS_NewObject(ctx);
        _ = qjs.JS_SetPropertyStr(ctx, obj, "rows", qjs.JS_NewInt32(ctx, 24));
        _ = qjs.JS_SetPropertyStr(ctx, obj, "cols", qjs.JS_NewInt32(ctx, 80));
        return obj;
    };

    const obj = qjs.JS_NewObject(ctx);
    _ = qjs.JS_SetPropertyStr(ctx, obj, "rows", qjs.JS_NewInt32(ctx, size.rows));
    _ = qjs.JS_SetPropertyStr(ctx, obj, "cols", qjs.JS_NewInt32(ctx, size.cols));
    return obj;
}

fn nativeReadStdin(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    var max_size: i32 = 1024;
    if (argc >= 1) {
        _ = qjs.JS_ToInt32(ctx, &max_size, argv[0]);
    }
    if (max_size <= 0) max_size = 1024;

    const line = wasi_tty.readLine(allocator, @intCast(max_size)) catch |err| {
        return qjs.JS_ThrowInternalError(ctx, "read error: %d", @intFromError(err));
    } orelse {
        return qjs.JS_NULL;
    };
    defer allocator.free(line);

    return qjs.JS_NewStringLen(ctx, line.ptr, line.len);
}

fn nativeSpawn(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "spawn requires command argument");

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    const command = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "command must be a string");
    defer freeStringArg(ctx, command);

    var cmd = wasi_process.Command.init(allocator, command);
    defer cmd.deinit();

    // Parse args array
    if (argc >= 2 and qjs.JS_IsArray(argv[1])) {
        const arr_len_val = qjs.JS_GetPropertyStr(ctx, argv[1], "length");
        var arr_len: i32 = 0;
        _ = qjs.JS_ToInt32(ctx, &arr_len, arr_len_val);
        qjs.JS_FreeValue(ctx, arr_len_val);

        var i: u32 = 0;
        while (i < @as(u32, @intCast(arr_len))) : (i += 1) {
            const elem = qjs.JS_GetPropertyUint32(ctx, argv[1], i);
            defer qjs.JS_FreeValue(ctx, elem);

            if (getStringArg(ctx, elem)) |arg_str| {
                const arg_copy = allocator.dupe(u8, arg_str) catch {
                    return qjs.JS_ThrowInternalError(ctx, "out of memory");
                };
                freeStringArg(ctx, arg_str);
                _ = cmd.arg(arg_copy) catch {
                    allocator.free(arg_copy);
                    return qjs.JS_ThrowInternalError(ctx, "out of memory");
                };
            }
        }
    }

    // Set stdin
    if (argc >= 3 and !qjs.JS_IsNull(argv[2]) and !qjs.JS_IsUndefined(argv[2])) {
        if (getStringArg(ctx, argv[2])) |stdin_data| {
            _ = cmd.setStdin(stdin_data);
        }
    }

    // Set timeout
    if (argc >= 4) {
        var timeout: i32 = 30000;
        _ = qjs.JS_ToInt32(ctx, &timeout, argv[3]);
        if (timeout > 0) {
            _ = cmd.setTimeout(@intCast(timeout));
        }
    }

    var result = cmd.output() catch |err| {
        return switch (err) {
            wasi_process.ProcessError.CommandFailed => qjs.JS_ThrowInternalError(ctx, "Command failed"),
            wasi_process.ProcessError.TimedOut => qjs.JS_ThrowInternalError(ctx, "Command timed out"),
            wasi_process.ProcessError.OutOfMemory => qjs.JS_ThrowInternalError(ctx, "Out of memory"),
            wasi_process.ProcessError.InvalidCommand => qjs.JS_ThrowTypeError(ctx, "Invalid command"),
            wasi_process.ProcessError.PermissionDenied => qjs.JS_ThrowTypeError(ctx, "Permission denied: command not in allowed list"),
        };
    };
    defer result.deinit();

    const obj = qjs.JS_NewObject(ctx);
    _ = qjs.JS_SetPropertyStr(ctx, obj, "exitCode", qjs.JS_NewInt32(ctx, result.exit_code));

    if (result.stdout.len > 0) {
        _ = qjs.JS_SetPropertyStr(ctx, obj, "stdout", qjs.JS_NewStringLen(ctx, result.stdout.ptr, result.stdout.len));
    } else {
        _ = qjs.JS_SetPropertyStr(ctx, obj, "stdout", qjs.JS_NewString(ctx, ""));
    }

    if (result.stderr.len > 0) {
        _ = qjs.JS_SetPropertyStr(ctx, obj, "stderr", qjs.JS_NewStringLen(ctx, result.stderr.ptr, result.stderr.len));
    } else {
        _ = qjs.JS_SetPropertyStr(ctx, obj, "stderr", qjs.JS_NewString(ctx, ""));
    }

    return obj;
}

// ============================================================================
// File System Native Bindings
// ============================================================================

/// Read file contents
fn nativeFsRead(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "fs.readFileSync requires path argument");

    const path = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "path must be a string");
    defer freeStringArg(ctx, path);

    const allocator = global_allocator orelse
        return qjs.JS_ThrowInternalError(ctx, "allocator not initialized");

    const file = std.fs.cwd().openFile(path, .{}) catch {
        return qjs.JS_ThrowInternalError(ctx, "ENOENT: no such file or directory");
    };
    defer file.close();

    const content = file.readToEndAlloc(allocator, 100 * 1024 * 1024) catch {
        return qjs.JS_ThrowInternalError(ctx, "failed to read file");
    };
    defer allocator.free(content);

    return qjs.JS_NewStringLen(ctx, content.ptr, content.len);
}

/// Write data to file
fn nativeFsWrite(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "fs.writeFileSync requires path and data arguments");

    const path = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "path must be a string");
    defer freeStringArg(ctx, path);

    const data = getStringArg(ctx, argv[1]) orelse
        return qjs.JS_ThrowTypeError(ctx, "data must be a string");
    defer freeStringArg(ctx, data);

    const file = std.fs.cwd().createFile(path, .{}) catch {
        return qjs.JS_ThrowInternalError(ctx, "failed to create file");
    };
    defer file.close();

    file.writeAll(data) catch {
        return qjs.JS_ThrowInternalError(ctx, "failed to write file");
    };

    return qjs.JS_UNDEFINED;
}

/// Check if file exists
fn nativeFsExists(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return jsBool(false);

    const path = getStringArg(ctx, argv[0]) orelse return jsBool(false);
    defer freeStringArg(ctx, path);

    std.fs.cwd().access(path, .{}) catch return jsBool(false);
    return jsBool(true);
}

/// Get file stats
fn nativeFsStat(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "fs.statSync requires path argument");

    const path = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "path must be a string");
    defer freeStringArg(ctx, path);

    const stat = std.fs.cwd().statFile(path) catch {
        return qjs.JS_ThrowInternalError(ctx, "ENOENT: no such file or directory");
    };

    const obj = qjs.JS_NewObject(ctx);
    _ = qjs.JS_SetPropertyStr(ctx, obj, "size", qjs.JS_NewInt64(ctx, @intCast(stat.size)));

    const is_dir = stat.kind == .directory;
    const mode: i32 = if (is_dir) 0o40755 else 0o100644;
    _ = qjs.JS_SetPropertyStr(ctx, obj, "mode", qjs.JS_NewInt32(ctx, mode));
    _ = qjs.JS_SetPropertyStr(ctx, obj, "_isDir", jsBool(is_dir));
    _ = qjs.JS_SetPropertyStr(ctx, obj, "_isFile", jsBool(!is_dir));

    // Add isFile/isDirectory methods via eval
    const methods_code =
        \\(function(obj) {
        \\    obj.isFile = function() { return this._isFile; };
        \\    obj.isDirectory = function() { return this._isDir; };
        \\    return obj;
        \\})
    ;
    const methods_fn = qjs.JS_Eval(ctx, methods_code.ptr, methods_code.len, "<stat>", qjs.JS_EVAL_TYPE_GLOBAL);
    if (!qjs.JS_IsException(methods_fn)) {
        var args = [_]qjs.JSValue{obj};
        const result = qjs.JS_Call(ctx, methods_fn, qjs.JS_UNDEFINED, 1, &args);
        qjs.JS_FreeValue(ctx, methods_fn);
        if (!qjs.JS_IsException(result)) {
            return result;
        }
        qjs.JS_FreeValue(ctx, result);
    } else {
        qjs.JS_FreeValue(ctx, methods_fn);
    }

    return obj;
}

/// Read directory entries
fn nativeFsReaddir(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "fs.readdirSync requires path argument");

    const path = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "path must be a string");
    defer freeStringArg(ctx, path);

    var dir = std.fs.cwd().openDir(path, .{ .iterate = true }) catch {
        return qjs.JS_ThrowInternalError(ctx, "ENOENT: no such file or directory");
    };
    defer dir.close();

    const arr = qjs.JS_NewArray(ctx);
    var idx: u32 = 0;

    var iter = dir.iterate();
    while (iter.next() catch null) |entry| {
        const name_val = qjs.JS_NewStringLen(ctx, entry.name.ptr, entry.name.len);
        _ = qjs.JS_SetPropertyUint32(ctx, arr, idx, name_val);
        idx += 1;
    }

    return arr;
}

/// Create directory
fn nativeFsMkdir(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "fs.mkdirSync requires path argument");

    const path = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "path must be a string");
    defer freeStringArg(ctx, path);

    const recursive = if (argc >= 2) qjs.JS_ToBool(ctx, argv[1]) != 0 else false;

    if (recursive) {
        std.fs.cwd().makePath(path) catch {
            return qjs.JS_ThrowInternalError(ctx, "failed to create directory");
        };
    } else {
        std.fs.cwd().makeDir(path) catch {
            return qjs.JS_ThrowInternalError(ctx, "failed to create directory");
        };
    }

    return qjs.JS_UNDEFINED;
}

/// Delete file
fn nativeFsUnlink(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "fs.unlinkSync requires path argument");

    const path = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "path must be a string");
    defer freeStringArg(ctx, path);

    std.fs.cwd().deleteFile(path) catch {
        return qjs.JS_ThrowInternalError(ctx, "ENOENT: no such file or directory");
    };

    return qjs.JS_UNDEFINED;
}

/// Delete directory
fn nativeFsRmdir(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 1) return qjs.JS_ThrowTypeError(ctx, "fs.rmdirSync requires path argument");

    const path = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "path must be a string");
    defer freeStringArg(ctx, path);

    const recursive = if (argc >= 2) qjs.JS_ToBool(ctx, argv[1]) != 0 else false;

    if (recursive) {
        std.fs.cwd().deleteTree(path) catch {
            return qjs.JS_ThrowInternalError(ctx, "failed to delete directory");
        };
    } else {
        std.fs.cwd().deleteDir(path) catch {
            return qjs.JS_ThrowInternalError(ctx, "ENOTEMPTY: directory not empty");
        };
    }

    return qjs.JS_UNDEFINED;
}

/// Rename file/directory
fn nativeFsRename(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "fs.renameSync requires oldPath and newPath arguments");

    const old_path = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "oldPath must be a string");
    defer freeStringArg(ctx, old_path);

    const new_path = getStringArg(ctx, argv[1]) orelse
        return qjs.JS_ThrowTypeError(ctx, "newPath must be a string");
    defer freeStringArg(ctx, new_path);

    std.fs.cwd().rename(old_path, new_path) catch {
        return qjs.JS_ThrowInternalError(ctx, "failed to rename");
    };

    return qjs.JS_UNDEFINED;
}

/// Copy file
fn nativeFsCopy(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "fs.copyFileSync requires src and dest arguments");

    const src = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "src must be a string");
    defer freeStringArg(ctx, src);

    const dest = getStringArg(ctx, argv[1]) orelse
        return qjs.JS_ThrowTypeError(ctx, "dest must be a string");
    defer freeStringArg(ctx, dest);

    std.fs.cwd().copyFile(src, std.fs.cwd(), dest, .{}) catch {
        return qjs.JS_ThrowInternalError(ctx, "failed to copy file");
    };

    return qjs.JS_UNDEFINED;
}

/// Get current working directory
fn nativeCwd(ctx: ?*qjs.JSContext, _: qjs.JSValue, _: c_int, _: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    // Get PWD from environment via WASI
    const allocator = global_allocator orelse {
        return qjs.JS_NewString(ctx, "/");
    };

    // Get environ from WASI
    var environ_count: usize = 0;
    var environ_buf_size: usize = 0;
    _ = std.os.wasi.environ_sizes_get(&environ_count, &environ_buf_size);

    if (environ_count == 0) {
        return qjs.JS_NewString(ctx, "/");
    }

    const environ_ptrs = allocator.alloc([*:0]u8, environ_count) catch {
        return qjs.JS_NewString(ctx, "/");
    };
    defer allocator.free(environ_ptrs);

    const environ_buf = allocator.alloc(u8, environ_buf_size) catch {
        return qjs.JS_NewString(ctx, "/");
    };
    defer allocator.free(environ_buf);

    _ = std.os.wasi.environ_get(environ_ptrs.ptr, environ_buf.ptr);

    for (environ_ptrs) |env_ptr| {
        const env = std.mem.span(env_ptr);
        if (std.mem.startsWith(u8, env, "PWD=")) {
            const pwd = env[4..];
            return qjs.JS_NewStringLen(ctx, pwd.ptr, pwd.len);
        }
    }

    return qjs.JS_NewString(ctx, "/");
}

/// Get home directory
fn nativeHomedir(ctx: ?*qjs.JSContext, _: qjs.JSValue, _: c_int, _: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    const allocator = global_allocator orelse {
        return qjs.JS_NewString(ctx, "/home/user");
    };

    // Get environ from WASI
    var environ_count: usize = 0;
    var environ_buf_size: usize = 0;
    _ = std.os.wasi.environ_sizes_get(&environ_count, &environ_buf_size);

    if (environ_count == 0) {
        return qjs.JS_NewString(ctx, "/home/user");
    }

    const environ_ptrs = allocator.alloc([*:0]u8, environ_count) catch {
        return qjs.JS_NewString(ctx, "/home/user");
    };
    defer allocator.free(environ_ptrs);

    const environ_buf = allocator.alloc(u8, environ_buf_size) catch {
        return qjs.JS_NewString(ctx, "/home/user");
    };
    defer allocator.free(environ_buf);

    _ = std.os.wasi.environ_get(environ_ptrs.ptr, environ_buf.ptr);

    for (environ_ptrs) |env_ptr| {
        const env = std.mem.span(env_ptr);
        if (std.mem.startsWith(u8, env, "HOME=")) {
            const home = env[5..];
            return qjs.JS_NewStringLen(ctx, home.ptr, home.len);
        }
    }

    return qjs.JS_NewString(ctx, "/home/user");
}

// ============================================================================
// Crypto Native Functions
// ============================================================================

const crypto = std.crypto;

/// Native hash function: __edgebox_hash(algorithm, data) -> hex string
/// Supports: sha256, sha384, sha512, sha1, md5
fn nativeHash(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 2) return qjs.JS_ThrowTypeError(ctx, "hash requires algorithm and data arguments");

    const algorithm = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "algorithm must be a string");
    defer freeStringArg(ctx, algorithm);

    const data = getStringArg(ctx, argv[1]) orelse
        return qjs.JS_ThrowTypeError(ctx, "data must be a string");
    defer freeStringArg(ctx, data);

    // Hash based on algorithm
    if (std.mem.eql(u8, algorithm, "sha256")) {
        var hash: [32]u8 = undefined;
        crypto.hash.sha2.Sha256.hash(data, &hash, .{});
        return hexEncode(ctx, &hash);
    } else if (std.mem.eql(u8, algorithm, "sha384")) {
        var hash: [48]u8 = undefined;
        crypto.hash.sha2.Sha384.hash(data, &hash, .{});
        return hexEncode(ctx, &hash);
    } else if (std.mem.eql(u8, algorithm, "sha512")) {
        var hash: [64]u8 = undefined;
        crypto.hash.sha2.Sha512.hash(data, &hash, .{});
        return hexEncode(ctx, &hash);
    } else if (std.mem.eql(u8, algorithm, "sha1")) {
        var hash: [20]u8 = undefined;
        crypto.hash.Sha1.hash(data, &hash, .{});
        return hexEncode(ctx, &hash);
    } else if (std.mem.eql(u8, algorithm, "md5")) {
        var hash: [16]u8 = undefined;
        crypto.hash.Md5.hash(data, &hash, .{});
        return hexEncode(ctx, &hash);
    } else {
        return qjs.JS_ThrowTypeError(ctx, "unsupported algorithm: use sha256, sha384, sha512, sha1, or md5");
    }
}

/// Native HMAC function: __edgebox_hmac(algorithm, key, data) -> hex string
fn nativeHmac(ctx: ?*qjs.JSContext, _: qjs.JSValue, argc: c_int, argv: [*c]qjs.JSValue) callconv(.c) qjs.JSValue {
    if (argc < 3) return qjs.JS_ThrowTypeError(ctx, "hmac requires algorithm, key, and data arguments");

    const algorithm = getStringArg(ctx, argv[0]) orelse
        return qjs.JS_ThrowTypeError(ctx, "algorithm must be a string");
    defer freeStringArg(ctx, algorithm);

    const key = getStringArg(ctx, argv[1]) orelse
        return qjs.JS_ThrowTypeError(ctx, "key must be a string");
    defer freeStringArg(ctx, key);

    const data = getStringArg(ctx, argv[2]) orelse
        return qjs.JS_ThrowTypeError(ctx, "data must be a string");
    defer freeStringArg(ctx, data);

    // HMAC based on algorithm
    if (std.mem.eql(u8, algorithm, "sha256")) {
        var out: [32]u8 = undefined;
        const key_ptr: *const [32]u8 = if (key.len >= 32) @ptrCast(key.ptr) else blk: {
            var padded: [32]u8 = undefined;
            @memset(&padded, 0);
            @memcpy(padded[0..key.len], key);
            break :blk &padded;
        };
        crypto.auth.hmac.sha2.HmacSha256.create(&out, data, key_ptr);
        return hexEncode(ctx, &out);
    } else if (std.mem.eql(u8, algorithm, "sha384")) {
        var out: [48]u8 = undefined;
        const key_ptr: *const [48]u8 = if (key.len >= 48) @ptrCast(key.ptr) else blk: {
            var padded: [48]u8 = undefined;
            @memset(&padded, 0);
            @memcpy(padded[0..key.len], key);
            break :blk &padded;
        };
        crypto.auth.hmac.sha2.HmacSha384.create(&out, data, key_ptr);
        return hexEncode(ctx, &out);
    } else if (std.mem.eql(u8, algorithm, "sha512")) {
        var out: [64]u8 = undefined;
        const key_ptr: *const [64]u8 = if (key.len >= 64) @ptrCast(key.ptr) else blk: {
            var padded: [64]u8 = undefined;
            @memset(&padded, 0);
            @memcpy(padded[0..key.len], key);
            break :blk &padded;
        };
        crypto.auth.hmac.sha2.HmacSha512.create(&out, data, key_ptr);
        return hexEncode(ctx, &out);
    } else {
        return qjs.JS_ThrowTypeError(ctx, "unsupported HMAC algorithm: use sha256, sha384, or sha512");
    }
}

/// Helper to convert bytes to hex string
fn hexEncode(ctx: ?*qjs.JSContext, bytes: []const u8) qjs.JSValue {
    const hex_chars = "0123456789abcdef";
    var hex_buf: [128]u8 = undefined; // Max 64 bytes * 2 = 128 hex chars
    const hex_len = bytes.len * 2;

    if (hex_len > hex_buf.len) {
        return qjs.JS_ThrowInternalError(ctx, "hash too long");
    }

    for (bytes, 0..) |byte, i| {
        hex_buf[i * 2] = hex_chars[byte >> 4];
        hex_buf[i * 2 + 1] = hex_chars[byte & 0x0f];
    }

    return qjs.JS_NewStringLen(ctx, &hex_buf, hex_len);
}
