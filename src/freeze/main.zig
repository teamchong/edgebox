//! edgebox-freeze CLI
//! Bytecode to C transpiler - freezes ALL functions in a module

const std = @import("std");
const opcodes = @import("opcodes.zig");
const parser = @import("bytecode_parser.zig");
const cfg_builder = @import("cfg_builder.zig");
const codegen = @import("codegen.zig");
const codegen_ssa = @import("codegen_ssa.zig");
const module_parser = @import("module_parser.zig");

const BytecodeParser = parser.BytecodeParser;
const Instruction = parser.Instruction;
const ModuleParser = module_parser.ModuleParser;
const SSACodeGen = codegen_ssa.SSACodeGen;

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    if (args.len < 2) {
        printUsage(args[0]);
        return;
    }

    // Parse command line arguments
    var input_file: ?[]const u8 = null;
    var output_file: []const u8 = "frozen_module.c";
    var module_name: []const u8 = "frozen";
    var debug_mode = false;
    var disasm_mode = false;

    var i: usize = 1;
    while (i < args.len) : (i += 1) {
        const arg = args[i];
        if (std.mem.eql(u8, arg, "-o") or std.mem.eql(u8, arg, "--output")) {
            i += 1;
            if (i >= args.len) {
                std.debug.print("Error: -o requires an argument\n", .{});
                return;
            }
            output_file = args[i];
        } else if (std.mem.eql(u8, arg, "-m") or std.mem.eql(u8, arg, "--module")) {
            i += 1;
            if (i >= args.len) {
                std.debug.print("Error: -m requires an argument\n", .{});
                return;
            }
            module_name = args[i];
        } else if (std.mem.eql(u8, arg, "-d") or std.mem.eql(u8, arg, "--debug")) {
            debug_mode = true;
        } else if (std.mem.eql(u8, arg, "--disasm")) {
            disasm_mode = true;
        } else if (std.mem.eql(u8, arg, "-h") or std.mem.eql(u8, arg, "--help")) {
            printUsage(args[0]);
            return;
        } else if (!std.mem.startsWith(u8, arg, "-")) {
            input_file = arg;
        } else {
            std.debug.print("Error: unknown option: {s}\n", .{arg});
            return;
        }
    }

    if (input_file == null) {
        std.debug.print("Error: no input file specified\n", .{});
        printUsage(args[0]);
        return;
    }

    // Read input file
    const file_content = readBytecodeFile(allocator, input_file.?) catch |err| {
        std.debug.print("Error reading input file '{s}': {}\n", .{ input_file.?, err });
        return;
    };
    defer allocator.free(file_content);

    if (debug_mode) std.debug.print("Read {d} bytes of bytecode\n", .{file_content.len});

    // Parse as QuickJS module format
    var mod_parser = ModuleParser.init(allocator, file_content);
    defer mod_parser.deinit();

    mod_parser.parse() catch |err| {
        std.debug.print("Module parse error: {}\n", .{err});
        return;
    };

    if (mod_parser.functions.items.len == 0) {
        std.debug.print("Error: No functions found in module\n", .{});
        return;
    }

    if (debug_mode) std.debug.print("Found {d} functions\n", .{mod_parser.functions.items.len});

    // Disassembly mode - show all functions
    if (disasm_mode) {
        for (mod_parser.functions.items, 0..) |func, idx| {
            std.debug.print("\n=== Function {d} (args={d} vars={d} bc_len={d}) ===\n", .{
                idx, func.arg_count, func.var_count, func.bytecode.len,
            });

            var bc_parser = BytecodeParser.init(func.bytecode);
            const instructions = bc_parser.parseAll(allocator) catch |err| {
                std.debug.print("  Error parsing: {}\n", .{err});
                continue;
            };
            defer allocator.free(instructions);

            for (instructions) |instr| {
                const info = instr.getInfo();
                std.debug.print("{d:>4}: {s}\n", .{ instr.pc, info.name });
            }
        }
        return;
    }

    // Generate frozen C code for ALL functions
    var output = std.ArrayListUnmanaged(u8){};
    defer output.deinit(allocator);

    // Write header
    try appendStr(&output, allocator,
        \\/*
        \\ * Frozen Module - All bytecode unrolled to C
        \\ * Generated by edgebox-freeze
        \\ *
        \\ * This replaces QuickJS interpreter with direct C execution.
        \\ * Expected speedup: 10-20x for CPU-bound code.
        \\ */
        \\
        \\#include "quickjs.h"
        \\#include <stdint.h>
        \\#include <math.h>
        \\
        \\#ifndef likely
        \\#define likely(x) __builtin_expect(!!(x), 1)
        \\#endif
        \\#ifndef unlikely
        \\#define unlikely(x) __builtin_expect(!!(x), 0)
        \\#endif
        \\
        \\/* Call stack limit (matches Node.js behavior) */
        \\#ifndef FROZEN_MAX_CALL_DEPTH
        \\#define FROZEN_MAX_CALL_DEPTH 10000
        \\#endif
        \\static int frozen_call_depth = 0;
        \\
        \\/* Stack overflow check macro - returns RangeError like Node.js */
        \\#define FROZEN_CHECK_STACK(ctx) do { \
        \\    if (unlikely(frozen_call_depth >= FROZEN_MAX_CALL_DEPTH)) { \
        \\        return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded"); \
        \\    } \
        \\    frozen_call_depth++; \
        \\} while(0)
        \\#define FROZEN_EXIT_STACK() (frozen_call_depth--)
        \\
        \\/* Stack operations with bounds checking */
        \\#define PUSH(v) do { \
        \\    if (unlikely(sp >= max_stack)) { \
        \\        FROZEN_EXIT_STACK(); \
        \\        return JS_ThrowRangeError(ctx, "Operand stack overflow"); \
        \\    } \
        \\    stack[sp++] = (v); \
        \\} while(0)
        \\#define POP() (stack[--sp])
        \\#define TOP() (stack[sp-1])
        \\#define SET_TOP(v) (stack[sp-1] = (v))
        \\
        \\
    );

    // Emit helper functions once
    const helpers = try SSACodeGen.emitHelpersOnly(allocator);
    defer allocator.free(helpers);
    try output.appendSlice(allocator, helpers);

    // Track which functions were frozen
    var frozen_indices = std.ArrayListUnmanaged(usize){};
    defer frozen_indices.deinit(allocator);
    var frozen_func_names = std.ArrayListUnmanaged([]const u8){};
    defer {
        for (frozen_func_names.items) |n| allocator.free(n);
        frozen_func_names.deinit(allocator);
    }

    // Process each function
    var frozen_count: usize = 0;
    for (mod_parser.functions.items, 0..) |func, idx| {
        // Skip module wrapper (0 args, usually index 0)
        // These are just initialization code, not user functions
        if (func.arg_count == 0 and idx == 0 and mod_parser.functions.items.len > 1) {
            if (debug_mode) std.debug.print("Skipping module wrapper (function 0)\n", .{});
            continue;
        }

        // Get function name for debug output
        const func_name_debug = mod_parser.getAtomString(func.name_atom);
        // Show raw atom value for debugging
        const decoded_atom = func.name_atom >> 1;
        if (debug_mode) {
            // Only show interesting functions (named or fib-candidate)
            if (func_name_debug != null or (func.arg_count == 1 and func.bytecode.len > 30 and func.bytecode.len < 100)) {
                std.debug.print("Freezing function {d}: args={d} vars={d} name={s} bc_offset={d}-{d} raw_atom={d} decoded={d}\n", .{
                    idx, func.arg_count, func.var_count, func_name_debug orelse "(anonymous)",
                    func.bytecode_offset, func.bytecode_offset + func.bytecode.len,
                    func.name_atom, decoded_atom,
                });
            }
        }

        // Parse bytecode
        if (debug_mode and func.bytecode.len >= 4) {
            std.debug.print("  Bytecode bytes[0..4]: {x:0>2} {x:0>2} {x:0>2} {x:0>2}\n", .{
                func.bytecode[0], func.bytecode[1], func.bytecode[2], func.bytecode[3],
            });
        }
        var bc_parser = BytecodeParser.init(func.bytecode);
        const instructions = bc_parser.parseAll(allocator) catch |err| {
            if (debug_mode) std.debug.print("  Error parsing bytecode: {}\n", .{err});
            continue;
        };
        defer allocator.free(instructions);

        // Check if function can be frozen
        const freeze_check = parser.canFreezeFunction(instructions);
        if (!freeze_check.can_freeze) {
            if (debug_mode) {
                std.debug.print("  Skipping: Contains unfrozen opcode: {s}\n", .{freeze_check.reason.?});
                std.debug.print("  First 10 instructions:\n", .{});
                for (instructions[0..@min(10, instructions.len)]) |instr| {
                    const info = instr.getInfo();
                    std.debug.print("    {d}: {s}\n", .{ instr.pc, info.name });
                }
            }
            continue;
        }

        // Phase 1: Disabled broken self-recursion detection
        // Old logic assumed get_var_ref0 always loads current function, but it can load ANY closure variable
        // This caused false positives like: sum(n) { return otherFunc(n); } being marked as recursive
        // Will be replaced with proper closure metadata tracking in Phase 2
        const is_self_recursive = false;

        // Build CFG
        var cfg = cfg_builder.buildCFG(allocator, instructions) catch |err| {
            if (debug_mode) std.debug.print("  Error building CFG: {}\n", .{err});
            continue;
        };
        defer cfg.deinit();

        // Get function name from atom table (works even with minified names)
        var func_name_buf: [64]u8 = undefined;
        var js_name_buf: [64]u8 = undefined;

        const original_name = mod_parser.getAtomString(func.name_atom);

        // Validate that the name is a valid C identifier (alphanumeric + underscore)
        const has_valid_name = blk: {
            if (original_name == null or original_name.?.len == 0) break :blk false;
            for (original_name.?) |c| {
                if (!((c >= 'a' and c <= 'z') or (c >= 'A' and c <= 'Z') or (c >= '0' and c <= '9') or c == '_')) {
                    break :blk false;
                }
            }
            // First char can't be a digit
            if (original_name.?[0] >= '0' and original_name.?[0] <= '9') break :blk false;
            break :blk true;
        };

        // C function name (for internal use)
        const func_name = if (has_valid_name)
            std.fmt.bufPrint(&func_name_buf, "{s}_{s}", .{ module_name, original_name.? }) catch "frozen_func"
        else
            std.fmt.bufPrint(&func_name_buf, "{s}_func{d}", .{ module_name, idx }) catch "frozen_func";

        // JS name (for globalThis registration) - use __frozen_ prefix for hook interception
        const js_name = if (has_valid_name)
            std.fmt.bufPrint(&js_name_buf, "__frozen_{s}", .{original_name.?}) catch func_name
        else
            func_name;

        if (has_valid_name and debug_mode) {
            std.debug.print("  Using name: '{s}' (will register as globalThis.{s})\n", .{ func_name, js_name });
        }

        // Generate C code using SSA codegen
        var gen = SSACodeGen.init(allocator, &cfg, .{
            .func_name = func_name,
            .js_name = js_name, // Name for globalThis registration
            .debug_comments = debug_mode,
            .arg_count = @intCast(func.arg_count),
            .var_count = @intCast(func.var_count),
            .emit_helpers = false, // Helpers already emitted once at top
            .is_self_recursive = is_self_recursive, // Enable direct C recursion
            .constants = func.constants, // Constant pool for push_const
            .atom_strings = mod_parser.atom_strings.items, // Atom table for variable/property names
        });
        defer gen.deinit();

        const code = gen.generate() catch |err| {
            if (err == error.UnsupportedOpcodes) {
                // Only print warning in debug mode (use -d flag)
                if (debug_mode) {
                    std.debug.print("  Skipping '{s}': unsupported opcodes: ", .{func_name});
                    for (gen.getUnsupportedOpcodeNames(), 0..) |opname, op_idx| {
                        if (op_idx > 0) std.debug.print(", ", .{});
                        std.debug.print("{s}", .{opname});
                        if (op_idx >= 4) {
                            std.debug.print(" (+{d} more)", .{gen.getUnsupportedOpcodeNames().len - 5});
                            break;
                        }
                    }
                    std.debug.print("\n", .{});
                }
            } else if (debug_mode) {
                std.debug.print("  Error generating code for '{s}': {}\n", .{ func_name, err });
            }
            continue;
        };

        try output.appendSlice(allocator, code);
        try appendStr(&output, allocator, "\n");

        // Store the actual C function name for the module init
        const func_name_copy = try allocator.dupe(u8, func_name);
        try frozen_func_names.append(allocator, func_name_copy);
        try frozen_indices.append(allocator, idx);
        frozen_count += 1;
    }

    if (frozen_count == 0) {
        // Always print this warning - it's important to know nothing was frozen
        std.debug.print("Warning: No functions could be frozen.\n", .{});
        // Still write an empty stub file so the build doesn't break
    }

    // Generate init function that registers all frozen functions
    try appendFmt(&output, allocator,
        \\/*
        \\ * Initialize all frozen functions
        \\ * Call this after creating JSContext
        \\ */
        \\int {s}_init(JSContext *ctx)
        \\{{
        \\    (void)ctx;
        \\    /* Functions are registered individually via their *_init() calls */
        \\    /* Call each function's init: */
        \\
    , .{module_name});

    for (frozen_func_names.items) |fname| {
        try appendFmt(&output, allocator, "    {s}_init(ctx);\n", .{fname});
    }

    try appendStr(&output, allocator,
        \\    return 0;
        \\}
        \\
    );

    // Write output
    writeOutputFile(output_file, output.items) catch return;
    if (debug_mode) std.debug.print("\nGenerated {d} frozen functions to '{s}'\n", .{ frozen_count, output_file });
}

/// Public API: Freeze bytecode from C array content to optimized C code
/// Called directly from runtime.zig - no subprocess needed
/// All frozen functions stay in WASM/AOT (sandboxed) - no host function exports
pub fn freezeModule(allocator: std.mem.Allocator, input_content: []const u8, module_name: []const u8, debug_mode: bool) ![]u8 {
    // Parse bytecode from C array format
    const file_content = try parseCArrayBytecode(allocator, input_content);
    defer allocator.free(file_content);

    // Parse as QuickJS module format
    var mod_parser = ModuleParser.init(allocator, file_content);
    defer mod_parser.deinit();

    mod_parser.parse() catch |err| {
        std.debug.print("[freeze] Module parse error: {}\n", .{err});
        return err;
    };

    if (mod_parser.functions.items.len == 0) {
        std.debug.print("[freeze] Error: No functions found in module\n", .{});
        return error.NoFunctions;
    }

    if (debug_mode) std.debug.print("[freeze] Found {d} functions\n", .{mod_parser.functions.items.len});

    // Generate frozen C code - same logic as main()
    var output = std.ArrayListUnmanaged(u8){};
    errdefer output.deinit(allocator);

    // Write header
    try appendStr(&output, allocator,
        \\/*
        \\ * Frozen Module - All bytecode unrolled to C
        \\ * Generated by edgebox-freeze
        \\ */
        \\
        \\#include "quickjs.h"
        \\#include <stdint.h>
        \\#include <math.h>
        \\
        \\#ifndef likely
        \\#define likely(x) __builtin_expect(!!(x), 1)
        \\#endif
        \\#ifndef unlikely
        \\#define unlikely(x) __builtin_expect(!!(x), 0)
        \\#endif
        \\
        \\#ifndef FROZEN_MAX_CALL_DEPTH
        \\#define FROZEN_MAX_CALL_DEPTH 10000
        \\#endif
        \\static int frozen_call_depth = 0;
        \\
        \\#define FROZEN_CHECK_STACK(ctx) do { \
        \\    if (unlikely(frozen_call_depth >= FROZEN_MAX_CALL_DEPTH)) { \
        \\        return JS_ThrowRangeError(ctx, "Maximum call stack size exceeded"); \
        \\    } \
        \\    frozen_call_depth++; \
        \\} while(0)
        \\#define FROZEN_EXIT_STACK() (frozen_call_depth--)
        \\
        \\#define PUSH(v) do { \
        \\    if (unlikely(sp >= max_stack)) { \
        \\        FROZEN_EXIT_STACK(); \
        \\        return JS_ThrowRangeError(ctx, "Operand stack overflow"); \
        \\    } \
        \\    stack[sp++] = (v); \
        \\} while(0)
        \\#define POP() (stack[--sp])
        \\#define TOP() (stack[sp-1])
        \\#define SET_TOP(v) (stack[sp-1] = (v))
        \\
        \\
    );

    // Emit helper functions
    const helpers = try SSACodeGen.emitHelpersOnly(allocator);
    defer allocator.free(helpers);
    try output.appendSlice(allocator, helpers);

    // Track frozen functions
    var frozen_func_names = std.ArrayListUnmanaged([]const u8){};
    defer {
        for (frozen_func_names.items) |n| allocator.free(n);
        frozen_func_names.deinit(allocator);
    }

    // First pass: collect info about each function (self-recursive, name, etc.)
    const FuncInfo = struct {
        idx: usize,
        is_self_recursive: bool,
        original_name: ?[]const u8,
        func_name: []const u8,
        js_name: []const u8,
        arg_count: u16,
        var_count: u16,
    };
    var func_infos = std.ArrayListUnmanaged(FuncInfo){};
    defer {
        for (func_infos.items) |info| {
            allocator.free(info.func_name);
            allocator.free(info.js_name);
        }
        func_infos.deinit(allocator);
    }

    // Collect function info first
    for (mod_parser.functions.items, 0..) |func, idx| {
        if (func.arg_count == 0 and idx == 0 and mod_parser.functions.items.len > 1) continue;

        var bc_parser = BytecodeParser.init(func.bytecode);
        const instructions = bc_parser.parseAll(allocator) catch continue;
        defer allocator.free(instructions);

        // Detect self-recursion
        const is_self_recursive = blk: {
            for (instructions, 0..) |instr, instr_idx| {
                if (instr.opcode == .tail_call) break :blk true;
                if (instr.opcode == .get_var_ref0) {
                    if (instr_idx + 2 < instructions.len) {
                        for (instructions[instr_idx + 1 ..]) |next_instr| {
                            if (next_instr.opcode == .call1) break :blk true;
                            if (next_instr.opcode == .call0 or
                                next_instr.opcode == .call2 or
                                next_instr.opcode == .call3 or
                                next_instr.opcode == .@"return" or
                                next_instr.opcode == .return_undef)
                            {
                                break;
                            }
                        }
                    }
                }
            }
            break :blk false;
        };

        const original_name = mod_parser.getAtomString(func.name_atom);
        const has_valid_name = blk: {
            if (original_name == null or original_name.?.len == 0) break :blk false;
            for (original_name.?) |c| {
                if (!((c >= 'a' and c <= 'z') or (c >= 'A' and c <= 'Z') or (c >= '0' and c <= '9') or c == '_')) break :blk false;
            }
            if (original_name.?[0] >= '0' and original_name.?[0] <= '9') break :blk false;
            break :blk true;
        };

        const func_name = if (has_valid_name)
            try std.fmt.allocPrint(allocator, "{s}_{s}", .{ module_name, original_name.? })
        else
            try std.fmt.allocPrint(allocator, "{s}_func{d}", .{ module_name, idx });

        const js_name = if (has_valid_name)
            try std.fmt.allocPrint(allocator, "__frozen_{s}", .{original_name.?})
        else
            try allocator.dupe(u8, func_name);

        try func_infos.append(allocator, .{
            .idx = idx,
            .is_self_recursive = is_self_recursive,
            .original_name = original_name,
            .func_name = func_name,
            .js_name = js_name,
            .arg_count = @intCast(func.arg_count),
            .var_count = @intCast(func.var_count),
        });
    }

    // Process each function
    var frozen_count: usize = 0;
    for (func_infos.items) |info| {
        const func = mod_parser.functions.items[info.idx];

        var bc_parser = BytecodeParser.init(func.bytecode);
        const instructions = bc_parser.parseAll(allocator) catch continue;
        defer allocator.free(instructions);

        var cfg = cfg_builder.buildCFG(allocator, instructions) catch continue;
        defer cfg.deinit();

        // All functions use SSA codegen (stays in WASM/AOT, sandboxed)
        var gen = SSACodeGen.init(allocator, &cfg, .{
            .func_name = info.func_name,
            .js_name = info.js_name,
            .debug_comments = debug_mode,
            .arg_count = @intCast(info.arg_count),
            .var_count = @intCast(info.var_count),
            .emit_helpers = false,
            .is_self_recursive = info.is_self_recursive,
            .constants = func.constants, // Constant pool for push_const
            .atom_strings = mod_parser.atom_strings.items, // Atom table for variable/property names
        });
        defer gen.deinit();

        const code = gen.generate() catch |err| {
            if (err == error.UnsupportedOpcodes and debug_mode) {
                std.debug.print("  Skipping '{s}': unsupported opcodes: ", .{info.func_name});
                for (gen.getUnsupportedOpcodeNames(), 0..) |opname, op_idx| {
                    if (op_idx > 0) std.debug.print(", ", .{});
                    std.debug.print("{s}", .{opname});
                    if (op_idx >= 4) {
                        std.debug.print(" (+{d} more)", .{gen.getUnsupportedOpcodeNames().len - 5});
                        break;
                    }
                }
                std.debug.print("\n", .{});
            }
            continue;
        };
        try output.appendSlice(allocator, code);
        try appendStr(&output, allocator, "\n");

        const func_name_copy = try allocator.dupe(u8, info.func_name);
        try frozen_func_names.append(allocator, func_name_copy);
        frozen_count += 1;
    }

    // Generate init function
    try appendFmt(&output, allocator,
        \\int {s}_init(JSContext *ctx)
        \\{{
        \\    (void)ctx;
        \\
    , .{module_name});

    for (frozen_func_names.items) |fname| {
        try appendFmt(&output, allocator, "    {s}_init(ctx);\n", .{fname});
    }

    try appendStr(&output, allocator,
        \\    return 0;
        \\}
        \\
    );

    if (debug_mode) std.debug.print("[freeze] Generated {d} frozen functions\n", .{frozen_count});

    return output.toOwnedSlice(allocator);
}

fn appendStr(list: *std.ArrayListUnmanaged(u8), alloc: std.mem.Allocator, str: []const u8) !void {
    try list.appendSlice(alloc, str);
}

fn appendFmt(list: *std.ArrayListUnmanaged(u8), alloc: std.mem.Allocator, comptime fmt: []const u8, args: anytype) !void {
    const len = std.fmt.count(fmt, args);
    try list.ensureUnusedCapacity(alloc, len);
    _ = std.fmt.bufPrint(list.unusedCapacitySlice(), fmt, args) catch unreachable;
    list.items.len += len;
}

fn writeOutputFile(path: []const u8, content: []const u8) !void {
    const file = std.fs.cwd().createFile(path, .{}) catch |err| {
        std.debug.print("Error creating output file '{s}': {}\n", .{ path, err });
        return err;
    };
    defer file.close();

    file.writeAll(content) catch |err| {
        std.debug.print("Error writing output file: {}\n", .{err});
        return err;
    };
}

fn printUsage(prog: []const u8) void {
    std.debug.print(
        \\Usage: {s} [options] <bytecode_file>
        \\
        \\Freeze ALL bytecode in a QuickJS module into optimized C code.
        \\This unrolls the interpreter loop for 10-20x speedup.
        \\
        \\Options:
        \\  -o, --output <file>   Output C file (default: frozen_module.c)
        \\  -m, --module <name>   Module name prefix (default: frozen)
        \\  -d, --debug           Include debug comments
        \\  --disasm              Disassemble all functions
        \\  -h, --help            Show this help
        \\
        \\Workflow:
        \\  1. Compile JS to bytecode:
        \\     qjsc -e -o app.c app.js
        \\
        \\  2. Freeze all bytecode to C:
        \\     edgebox-freeze app.c -o frozen_app.c -m myapp
        \\
        \\  3. Compile frozen C into your app/WASM:
        \\     Link frozen_app.c with QuickJS
        \\
        \\  4. Initialize at runtime:
        \\     myapp_init(ctx);  // Registers all frozen functions
        \\
    , .{prog});
}

/// Read bytecode from file
/// Supports both raw binary and C array format from qjsc
fn readBytecodeFile(allocator: std.mem.Allocator, path: []const u8) ![]u8 {
    const file = try std.fs.cwd().openFile(path, .{});
    defer file.close();

    const content = try file.readToEndAlloc(allocator, 10 * 1024 * 1024); // 10MB max
    defer allocator.free(content);

    // Check if it's a C array format
    if (std.mem.indexOf(u8, content, "const uint8_t") != null or
        std.mem.indexOf(u8, content, "static const uint8_t") != null)
    {
        return parseCArrayBytecode(allocator, content);
    }

    // Raw binary
    return allocator.dupe(u8, content);
}

/// Parse bytecode from C array format (qjsc -e output)
fn parseCArrayBytecode(allocator: std.mem.Allocator, content: []const u8) ![]u8 {
    var bytes = std.ArrayListUnmanaged(u8){};
    errdefer bytes.deinit(allocator);

    // Find the array body between { and }
    const start = std.mem.indexOf(u8, content, "{") orelse return error.InvalidFormat;
    const end = std.mem.lastIndexOf(u8, content, "}") orelse return error.InvalidFormat;

    if (start >= end) return error.InvalidFormat;

    const array_content = content[start + 1 .. end];

    // Parse hex bytes: 0xNN, 0xNN, ...
    var i: usize = 0;
    while (i < array_content.len) {
        // Skip whitespace and commas
        while (i < array_content.len and (array_content[i] == ' ' or
            array_content[i] == '\n' or
            array_content[i] == '\r' or
            array_content[i] == '\t' or
            array_content[i] == ','))
        {
            i += 1;
        }

        if (i >= array_content.len) break;

        // Parse 0xNN
        if (i + 3 < array_content.len and
            array_content[i] == '0' and
            (array_content[i + 1] == 'x' or array_content[i + 1] == 'X'))
        {
            const hex = array_content[i + 2 .. i + 4];
            const byte = std.fmt.parseInt(u8, hex, 16) catch {
                i += 1;
                continue;
            };
            try bytes.append(allocator, byte);
            i += 4;
        } else {
            i += 1;
        }
    }

    return bytes.toOwnedSlice(allocator);
}
