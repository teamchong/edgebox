//! edgebox-freeze CLI
//! Bytecode to C transpiler - freezes ALL functions in a module

const std = @import("std");
const opcodes = @import("opcodes.zig");
const parser = @import("bytecode_parser.zig");
const cfg_builder = @import("cfg_builder.zig");
const codegen = @import("codegen.zig");
const codegen_ssa = @import("codegen_ssa.zig");
const module_parser = @import("module_parser.zig");

const BytecodeParser = parser.BytecodeParser;
const Instruction = parser.Instruction;
const ModuleParser = module_parser.ModuleParser;
const SSACodeGen = codegen_ssa.SSACodeGen;

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    if (args.len < 2) {
        printUsage(args[0]);
        return;
    }

    // Parse command line arguments
    var input_file: ?[]const u8 = null;
    var output_file: []const u8 = "frozen_module.c";
    var module_name: []const u8 = "frozen";
    var debug_mode = false;
    var disasm_mode = false;
    var single_func: ?[]const u8 = null; // For backwards compat: freeze single function

    var i: usize = 1;
    while (i < args.len) : (i += 1) {
        const arg = args[i];
        if (std.mem.eql(u8, arg, "-o") or std.mem.eql(u8, arg, "--output")) {
            i += 1;
            if (i >= args.len) {
                std.debug.print("Error: -o requires an argument\n", .{});
                return;
            }
            output_file = args[i];
        } else if (std.mem.eql(u8, arg, "-m") or std.mem.eql(u8, arg, "--module")) {
            i += 1;
            if (i >= args.len) {
                std.debug.print("Error: -m requires an argument\n", .{});
                return;
            }
            module_name = args[i];
        } else if (std.mem.eql(u8, arg, "-n") or std.mem.eql(u8, arg, "--name")) {
            // Legacy: single function mode
            i += 1;
            if (i >= args.len) {
                std.debug.print("Error: -n requires an argument\n", .{});
                return;
            }
            single_func = args[i];
        } else if (std.mem.eql(u8, arg, "-d") or std.mem.eql(u8, arg, "--debug")) {
            debug_mode = true;
        } else if (std.mem.eql(u8, arg, "--disasm")) {
            disasm_mode = true;
        } else if (std.mem.eql(u8, arg, "-h") or std.mem.eql(u8, arg, "--help")) {
            printUsage(args[0]);
            return;
        } else if (!std.mem.startsWith(u8, arg, "-")) {
            input_file = arg;
        } else {
            std.debug.print("Error: unknown option: {s}\n", .{arg});
            return;
        }
    }

    if (input_file == null) {
        std.debug.print("Error: no input file specified\n", .{});
        printUsage(args[0]);
        return;
    }

    // Read input file
    const file_content = readBytecodeFile(allocator, input_file.?) catch |err| {
        std.debug.print("Error reading input file '{s}': {}\n", .{ input_file.?, err });
        return;
    };
    defer allocator.free(file_content);

    std.debug.print("Read {d} bytes of bytecode\n", .{file_content.len});

    // Parse as QuickJS module format
    var mod_parser = ModuleParser.init(allocator, file_content);
    defer mod_parser.deinit();

    mod_parser.parse() catch |err| {
        std.debug.print("Module parse error: {}\n", .{err});
        return;
    };

    if (mod_parser.functions.items.len == 0) {
        std.debug.print("Error: No functions found in module\n", .{});
        return;
    }

    std.debug.print("Found {d} functions\n", .{mod_parser.functions.items.len});

    // Disassembly mode - show all functions
    if (disasm_mode) {
        for (mod_parser.functions.items, 0..) |func, idx| {
            std.debug.print("\n=== Function {d} (args={d} vars={d} bc_len={d}) ===\n", .{
                idx, func.arg_count, func.var_count, func.bytecode.len,
            });

            var bc_parser = BytecodeParser.init(func.bytecode);
            const instructions = bc_parser.parseAll(allocator) catch |err| {
                std.debug.print("  Error parsing: {}\n", .{err});
                continue;
            };
            defer allocator.free(instructions);

            for (instructions) |instr| {
                const info = instr.getInfo();
                std.debug.print("{d:>4}: {s}\n", .{ instr.pc, info.name });
            }
        }
        return;
    }

    // Generate frozen C code for ALL functions
    var output = std.ArrayListUnmanaged(u8){};
    defer output.deinit(allocator);

    // Write header
    try appendStr(&output, allocator,
        \\/*
        \\ * Frozen Module - All bytecode unrolled to C
        \\ * Generated by edgebox-freeze
        \\ *
        \\ * This replaces QuickJS interpreter with direct C execution.
        \\ * Expected speedup: 10-20x for CPU-bound code.
        \\ */
        \\
        \\#include "quickjs.h"
        \\#include <stdint.h>
        \\#include <math.h>
        \\
        \\#ifndef likely
        \\#define likely(x) __builtin_expect(!!(x), 1)
        \\#endif
        \\#ifndef unlikely
        \\#define unlikely(x) __builtin_expect(!!(x), 0)
        \\#endif
        \\
        \\/* Stack operations */
        \\#define PUSH(v) (stack[sp++] = (v))
        \\#define POP() (stack[--sp])
        \\#define TOP() (stack[sp-1])
        \\#define SET_TOP(v) (stack[sp-1] = (v))
        \\
        \\
    );

    // Emit helper functions once
    const helpers = try SSACodeGen.emitHelpersOnly(allocator);
    defer allocator.free(helpers);
    try output.appendSlice(allocator, helpers);

    // Track which functions were frozen
    var frozen_indices = std.ArrayListUnmanaged(usize){};
    defer frozen_indices.deinit(allocator);

    // Process each function
    var frozen_count: usize = 0;
    for (mod_parser.functions.items, 0..) |func, idx| {
        // Skip module wrapper (0 args, usually index 0)
        // These are just initialization code, not user functions
        if (func.arg_count == 0 and idx == 0 and mod_parser.functions.items.len > 1) {
            std.debug.print("Skipping module wrapper (function 0)\n", .{});
            continue;
        }

        std.debug.print("Freezing function {d}: args={d} vars={d}\n", .{ idx, func.arg_count, func.var_count });

        // Parse bytecode
        var bc_parser = BytecodeParser.init(func.bytecode);
        const instructions = bc_parser.parseAll(allocator) catch |err| {
            std.debug.print("  Error parsing bytecode: {}\n", .{err});
            continue;
        };
        defer allocator.free(instructions);

        // Check if function can be frozen
        const freeze_check = parser.canFreezeFunction(instructions);
        if (!freeze_check.can_freeze) {
            std.debug.print("  Skipping: Contains unfrozen opcode: {s}\n", .{freeze_check.reason.?});
            continue;
        }

        // Detect self-recursion: look for get_var_ref0 followed by call1
        // This pattern indicates a function calling itself
        var is_self_recursive = false;
        for (instructions, 0..) |instr, instr_idx| {
            if (instr.opcode == .get_var_ref0) {
                // Check if next instruction is call1
                if (instr_idx + 2 < instructions.len) {
                    // Pattern: get_var_ref0, <push args>, call1
                    for (instructions[instr_idx + 1 ..]) |next_instr| {
                        if (next_instr.opcode == .call1) {
                            is_self_recursive = true;
                            break;
                        }
                        // Stop looking if we hit another call or return
                        if (next_instr.opcode == .call0 or
                            next_instr.opcode == .call2 or
                            next_instr.opcode == .call3 or
                            next_instr.opcode == .@"return" or
                            next_instr.opcode == .return_undef)
                        {
                            break;
                        }
                    }
                }
                if (is_self_recursive) break;
            }
        }
        if (is_self_recursive) {
            std.debug.print("  Detected self-recursion: enabling direct C recursion\n", .{});
        }

        // Build CFG
        var cfg = cfg_builder.buildCFG(allocator, instructions) catch |err| {
            std.debug.print("  Error building CFG: {}\n", .{err});
            continue;
        };
        defer cfg.deinit();

        // Generate function name
        var func_name_buf: [64]u8 = undefined;
        const func_name = std.fmt.bufPrint(&func_name_buf, "{s}_func{d}", .{ module_name, idx }) catch "frozen_func";

        // Generate C code using SSA codegen
        var gen = SSACodeGen.init(allocator, &cfg, .{
            .func_name = func_name,
            .debug_comments = debug_mode,
            .arg_count = @intCast(func.arg_count),
            .var_count = @intCast(func.var_count),
            .emit_helpers = false, // Helpers already emitted once at top
            .is_self_recursive = is_self_recursive, // Enable direct C recursion
        });
        defer gen.deinit();

        const code = gen.generate() catch |err| {
            std.debug.print("  Error generating code: {}\n", .{err});
            continue;
        };

        try output.appendSlice(allocator, code);
        try appendStr(&output, allocator, "\n");
        try frozen_indices.append(allocator, idx);
        frozen_count += 1;
    }

    if (frozen_count == 0) {
        std.debug.print("No functions could be frozen.\n", .{});
        return;
    }

    // Generate init function that registers all frozen functions
    try appendFmt(&output, allocator,
        \\/*
        \\ * Initialize all frozen functions
        \\ * Call this after creating JSContext
        \\ */
        \\int {s}_init(JSContext *ctx)
        \\{{
        \\    (void)ctx;
        \\    /* Functions are registered individually via their *_init() calls */
        \\    /* Call each function's init: */
        \\
    , .{module_name});

    for (frozen_indices.items) |idx| {
        try appendFmt(&output, allocator, "    {s}_func{d}_init(ctx);\n", .{ module_name, idx });
    }

    try appendStr(&output, allocator,
        \\    return 0;
        \\}
        \\
    );

    // Write output
    writeOutputFile(output_file, output.items) catch return;
    std.debug.print("\nGenerated {d} frozen functions to '{s}'\n", .{ frozen_count, output_file });
}

fn appendStr(list: *std.ArrayListUnmanaged(u8), alloc: std.mem.Allocator, str: []const u8) !void {
    try list.appendSlice(alloc, str);
}

fn appendFmt(list: *std.ArrayListUnmanaged(u8), alloc: std.mem.Allocator, comptime fmt: []const u8, args: anytype) !void {
    const len = std.fmt.count(fmt, args);
    try list.ensureUnusedCapacity(alloc, len);
    _ = std.fmt.bufPrint(list.unusedCapacitySlice(), fmt, args) catch unreachable;
    list.items.len += len;
}

fn writeOutputFile(path: []const u8, content: []const u8) !void {
    const file = std.fs.cwd().createFile(path, .{}) catch |err| {
        std.debug.print("Error creating output file '{s}': {}\n", .{ path, err });
        return err;
    };
    defer file.close();

    file.writeAll(content) catch |err| {
        std.debug.print("Error writing output file: {}\n", .{err});
        return err;
    };
}

fn printUsage(prog: []const u8) void {
    std.debug.print(
        \\Usage: {s} [options] <bytecode_file>
        \\
        \\Freeze ALL bytecode in a QuickJS module into optimized C code.
        \\This unrolls the interpreter loop for 10-20x speedup.
        \\
        \\Options:
        \\  -o, --output <file>   Output C file (default: frozen_module.c)
        \\  -m, --module <name>   Module name prefix (default: frozen)
        \\  -d, --debug           Include debug comments
        \\  --disasm              Disassemble all functions
        \\  -h, --help            Show this help
        \\
        \\Workflow:
        \\  1. Compile JS to bytecode:
        \\     qjsc -e -o app.c app.js
        \\
        \\  2. Freeze all bytecode to C:
        \\     edgebox-freeze app.c -o frozen_app.c -m myapp
        \\
        \\  3. Compile frozen C into your app/WASM:
        \\     Link frozen_app.c with QuickJS
        \\
        \\  4. Initialize at runtime:
        \\     myapp_init(ctx);  // Registers all frozen functions
        \\
    , .{prog});
}

/// Read bytecode from file
/// Supports both raw binary and C array format from qjsc
fn readBytecodeFile(allocator: std.mem.Allocator, path: []const u8) ![]u8 {
    const file = try std.fs.cwd().openFile(path, .{});
    defer file.close();

    const content = try file.readToEndAlloc(allocator, 10 * 1024 * 1024); // 10MB max
    defer allocator.free(content);

    // Check if it's a C array format
    if (std.mem.indexOf(u8, content, "const uint8_t") != null or
        std.mem.indexOf(u8, content, "static const uint8_t") != null)
    {
        return parseCArrayBytecode(allocator, content);
    }

    // Raw binary
    return allocator.dupe(u8, content);
}

/// Parse bytecode from C array format (qjsc -e output)
fn parseCArrayBytecode(allocator: std.mem.Allocator, content: []const u8) ![]u8 {
    var bytes = std.ArrayListUnmanaged(u8){};
    errdefer bytes.deinit(allocator);

    // Find the array body between { and }
    const start = std.mem.indexOf(u8, content, "{") orelse return error.InvalidFormat;
    const end = std.mem.lastIndexOf(u8, content, "}") orelse return error.InvalidFormat;

    if (start >= end) return error.InvalidFormat;

    const array_content = content[start + 1 .. end];

    // Parse hex bytes: 0xNN, 0xNN, ...
    var i: usize = 0;
    while (i < array_content.len) {
        // Skip whitespace and commas
        while (i < array_content.len and (array_content[i] == ' ' or
            array_content[i] == '\n' or
            array_content[i] == '\r' or
            array_content[i] == '\t' or
            array_content[i] == ','))
        {
            i += 1;
        }

        if (i >= array_content.len) break;

        // Parse 0xNN
        if (i + 3 < array_content.len and
            array_content[i] == '0' and
            (array_content[i + 1] == 'x' or array_content[i + 1] == 'X'))
        {
            const hex = array_content[i + 2 .. i + 4];
            const byte = std.fmt.parseInt(u8, hex, 16) catch {
                i += 1;
                continue;
            };
            try bytes.append(allocator, byte);
            i += 4;
        } else {
            i += 1;
        }
    }

    return bytes.toOwnedSlice(allocator);
}
